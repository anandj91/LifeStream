// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class TemporalArrayEgressTemplate : CommonPipeTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Diagnostics.Contracts;
using System.Linq.Expressions;
using System.Runtime.Serialization;
using Microsoft.StreamProcessing.Internal;

[DataContract]
internal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write(this.ToStringHelper.ToStringWithCulture(ingressType));
            this.Write("EgressPipe : EgressBoundary<");
            this.Write(this.ToStringHelper.ToStringWithCulture(inputKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ArraySegment<");
            this.Write(this.ToStringHelper.ToStringWithCulture(egress));
            this.Write(">\r\n{\r\n    private readonly Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(egress));
            this.Write("[]> generator;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(egress));
            this.Write("[] array;\r\n    [DataMember]\r\n    private int arrayLength;\r\n    [DataMember]\r\n    " +
                    "private int populationCount = 0;\r\n\r\n    [Obsolete(\"Used only by serialization. D" +
                    "o not call directly.\")]\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write(this.ToStringHelper.ToStringWithCulture(ingressType));
            this.Write("EgressPipe() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write(this.ToStringHelper.ToStringWithCulture(ingressType));
            this.Write("EgressPipe(\r\n        Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(egress));
            this.Write("[]> generator,\r\n        IObserver<ArraySegment<");
            this.Write(this.ToStringHelper.ToStringWithCulture(egress));
            this.Write(@">> observer)
        : base(observer, null)
    {
        this.generator = generator;
        this.array = this.generator();
        this.arrayLength = this.array.Length;
        this.observer = observer;
    }

    public override void OnNext(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(inputKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> batch)\r\n    {\r\n");
  if (!string.IsNullOrEmpty(partitionString))
    { 
            this.Write("        var colkey = batch.key.col;\r\n");
  } 
            this.Write("        var col_bv = batch.bitvector.col;\r\n        var col_vsync = batch.vsync.co" +
                    "l;\r\n        var col_vother = batch.vother.col;\r\n\r\n        for (int i = 0; i < ba" +
                    "tch.Count; i++)\r\n        {\r\n            if ((col_bv[i >> 6] & (1L << (i & 0x3f))" +
                    ") != 0");
 if (ingressType == "StreamEvent") { 
            this.Write(" && col_vother[i] >= 0");
 } 
            this.Write(")\r\n                continue;\r\n");
      if (ingressType == "StreamEvent")
        { 
            this.Write("            else if (col_vother[i] == StreamEvent.PunctuationOtherTime)\r\n        " +
                    "        this.array[this.populationCount++] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent.CreatePunctuation<");
            this.Write(this.ToStringHelper.ToStringWithCulture(genericArguments));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionKeyArgument));
            this.Write("col_vsync[i]);\r\n");
          if (partitionString == "Partitioned")
            { 
            this.Write("            else if (col_vother[i] == PartitionedStreamEvent.LowWatermarkOtherTim" +
                    "e)\r\n                this.array[this.populationCount++] = PartitionedStreamEvent." +
                    "CreateLowWatermark<TKey, TPayload>(batch.Timestamp);\r\n");
          }
        }
    switch (ingressType)
    {
        case "StartEdge": 
            this.Write("            else if (col_vother[i] == StreamEvent.InfinitySyncTime)\r\n            " +
                    "{\r\n                this.array[this.populationCount++] = this.constructor(");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionKeyArgument));
            this.Write("col_vsync[i], batch[i]);\r\n            }\r\n            else throw new StreamProcess" +
                    "ingException(\"The query has encountered either an end edge or an interval, while" +
                    " the egress point expects only start edges.\");\r\n");
          break;
        case "Interval": 
            this.Write("            else this.array[this.populationCount++] = this.constructor(");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionKeyArgument));
            this.Write("col_vsync[i], col_vother[i], batch[i]);\r\n");
          break;
        default: 
            this.Write("            else this.array[this.populationCount++] = new ");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionString));
            this.Write("StreamEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(genericArguments));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(partitionKeyArgument));
            this.Write("col_vsync[i], col_vother[i], batch[i]);\r\n");
          break;
    } 
            this.Write("\r\n            if (this.populationCount == this.arrayLength)\r\n            {\r\n     " +
                    "           this.observer.OnNext(new ArraySegment<");
            this.Write(this.ToStringHelper.ToStringWithCulture(egress));
            this.Write(@">(this.array, 0, this.arrayLength));
                this.populationCount = 0;
                this.array = this.generator();
                this.arrayLength = this.array.Length;
            }
        }
        batch.Free();
    }

    public override void OnCompleted()
    {
        OnFlush();
        base.OnCompleted();
    }

    public override void OnFlush()
    {
        if (this.populationCount > 0)
        {
            this.observer.OnNext(new ArraySegment<");
            this.Write(this.ToStringHelper.ToStringWithCulture(egress));
            this.Write(@">(this.array, 0, this.populationCount));
            this.populationCount = 0;
            this.array = this.generator();
            this.arrayLength = this.array.Length;
        }
    }

    public override int CurrentlyBufferedOutputCount => this.populationCount;

    public override int CurrentlyBufferedInputCount => 0;
}");
            return this.GenerationEnvironment.ToString();
        }
    }
}
