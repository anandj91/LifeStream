// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System.Reflection;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class LeftAntiSemiJoinTemplate : CommonBinaryTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;
[assembly: IgnoresAccessChecksTo(""Microsoft.StreamProcessing"")]

// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TLeft: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("\r\n// TRight: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("\r\n\r\n");

    var leftBatchTypeName = Transformer.GetBatchClassName(this.keyType, this.leftType) + this.TKeyTLeftGenericParameters;
    var rightBatchTypeName = Transformer.GetBatchClassName(this.keyType, this.rightType) + this.TKeyTRightGenericParameters;

            this.Write("\r\n[DataContract]\r\n[KnownType(typeof(EndPointHeap))]\r\n[KnownType(typeof(EndPointQu" +
                    "eue))]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(genericParameters));
            this.Write(" : BinaryPipe<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(">, IBinaryObserver\r\n{\r\n    private const long NotActive = long.MaxValue;\r\n    pri" +
                    "vate readonly MemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> pool;\r\n\r\n    [SchemaSerialization]\r\n    private readonly Expression<Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", bool>> keyComparer;\r\n    [SchemaSerialization]\r\n    private readonly Expression" +
                    "<Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(", bool>> leftComparer;\r\n\r\n    private StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> genericOutputBatch;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TLeft));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTLeftGenericParameters));
            this.Write(@" output;
    [DataMember]
    private FastMap<LeftEvent> leftIntervalMap = new FastMap<LeftEvent>();
    [DataMember]
    private FastMap<LeftEvent> leftEdgeMap = new FastMap<LeftEvent>();
    [DataMember]
    private IEndPointOrderer leftEndPointHeap;
    [DataMember]
    private FastMap<RightEvent> rightMap = new FastMap<RightEvent>();
    [DataMember]
    private FastStack<QueuedEndEdge> rightEndEdges = new FastStack<QueuedEndEdge>();
    [DataMember]
    private IEndPointOrderer rightEndPointHeap;
    [DataMember]
    private long nextLeftTime = long.MinValue;
    [DataMember]
    private long nextRightTime = long.MinValue;
    [DataMember]
    private long currTime = long.MinValue;

    private readonly Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> queryPlanGenerator;

    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    [Obsolete(\"Used only by serialization. Do not call directly.\")]\r\n    publ" +
                    "ic ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> observer,\r\n        IEqualityComparerExpression<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("> keyEqualityComparer,\r\n        IEqualityComparerExpression<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(@"> leftComparer,
        Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> queryPlanGenerator,
        bool leftIsConstantDuration,
        bool rightIsConstantDuration)
        : base(stream, observer)
    {
        this.queryPlanGenerator = queryPlanGenerator;

        this.keyComparer = keyEqualityComparer.GetEqualsExpr();
        this.leftComparer = leftComparer.GetEqualsExpr();

        if (leftIsConstantDuration) this.leftEndPointHeap = new EndPointQueue();
        else this.leftEndPointHeap = new EndPointHeap();

        if (rightIsConstantDuration) this.rightEndPointHeap = new EndPointQueue();
        else this.rightEndPointHeap = new EndPointHeap();

        this.pool = MemoryManager.GetMemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(">(true);\r\n        GetOutputBatch();\r\n    }\r\n\r\n    public override int CurrentlyBu" +
                    "fferedOutputCount => this.output.Count;\r\n    public override int CurrentlyBuffer" +
                    "edLeftInputCount => base.CurrentlyBufferedLeftInputCount + this.leftEdgeMap.Coun" +
                    "t + this.leftIntervalMap.Count;\r\n    public override int CurrentlyBufferedRightI" +
                    "nputCount => base.CurrentlyBufferedRightInputCount + this.rightEndEdges.Count + " +
                    "this.rightMap.Count;\r\n\r\n    protected override void ProduceBinaryQueryPlan(PlanN" +
                    "ode left, PlanNode right)\r\n    {\r\n        Observer.ProduceQueryPlan(queryPlanGen" +
                    "erator(left, right, this));\r\n    }\r\n\r\n    protected override void DisposeState()" +
                    "\r\n    {\r\n        this.output.Free();\r\n\r\n        var allLeftEdgeTraverser = this." +
                    "leftEdgeMap.Traverse();\r\n        allLeftEdgeTraverser.currIndex = 0;\r\n        in" +
                    "t x, y;\r\n        while (allLeftEdgeTraverser.Next(out x, out y))\r\n        {\r\n   " +
                    "         var leftInterval = this.leftEdgeMap.Values[x];\r\n        }\r\n        var " +
                    "allLeftEdgeInvisibleTraverser = this.leftEdgeMap.TraverseInvisible();\r\n        w" +
                    "hile (allLeftEdgeInvisibleTraverser.Next(out x, out y))\r\n        {\r\n            " +
                    "var leftEdge = this.leftEdgeMap.Values[x];\r\n        }\r\n\r\n        var allLeftInte" +
                    "rvalTraverser = this.leftIntervalMap.Traverse();\r\n        allLeftIntervalTravers" +
                    "er.currIndex = 0;\r\n        while (allLeftIntervalTraverser.Next(out x, out y))\r\n" +
                    "        {\r\n            var leftInterval = this.leftIntervalMap.Values[x];\r\n     " +
                    "   }\r\n        var allLeftIntervalInvisibleTraverser = this.leftIntervalMap.Trave" +
                    "rseInvisible();\r\n        while (allLeftIntervalInvisibleTraverser.Next(out x, ou" +
                    "t y))\r\n        {\r\n            var leftInterval = this.leftIntervalMap.Values[x];" +
                    "\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n  " +
                    "  protected override void ProcessBothBatches(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> genericLeftBatch, StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("> genericRightBatch, out bool leftBatchDone, out bool rightBatchDone, out bool le" +
                    "ftBatchFree, out bool rightBatchFree)\r\n    {\r\n        var leftBatch = genericLef" +
                    "tBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(";\r\n        var rightBatch = genericRightBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchTypeName));
            this.Write(";\r\n\r\n        leftBatchFree = rightBatchFree = true;\r\n        if (!GoToVisibleRow(" +
                    "leftBatch))\r\n        {\r\n            leftBatchDone = true;\r\n            rightBatc" +
                    "hDone = false;\r\n            return;\r\n        }\r\n\r\n        this.nextLeftTime = le" +
                    "ftBatch.vsync.col[leftBatch.iter];\r\n\r\n        if (!GoToVisibleRow(rightBatch))\r\n" +
                    "        {\r\n            leftBatchDone = false;\r\n            rightBatchDone = true" +
                    ";\r\n            return;\r\n        }\r\n\r\n        this.nextRightTime = rightBatch.vsy" +
                    "nc.col[rightBatch.iter];\r\n\r\n        while (true)\r\n        {\r\n            if (thi" +
                    "s.nextLeftTime <= this.nextRightTime)\r\n            {\r\n                UpdateTime" +
                    "(this.nextLeftTime);\r\n\r\n                ProcessLeftEvent(\r\n                    t" +
                    "his.nextLeftTime,\r\n                    leftBatch.vother.col[leftBatch.iter],\r\n  " +
                    "                  ref leftBatch.key.col[leftBatch.iter],\r\n                    le" +
                    "ftBatch,\r\n                    leftBatch.iter,\r\n                    leftBatch.has" +
                    "h.col[leftBatch.iter]);\r\n\r\n                leftBatch.iter++;\r\n\r\n                " +
                    "if (!GoToVisibleRow(leftBatch))\r\n                {\r\n                    leftBatc" +
                    "hDone = true;\r\n                    rightBatchDone = false;\r\n                    " +
                    "return;\r\n                }\r\n\r\n                this.nextLeftTime = leftBatch.vsyn" +
                    "c.col[leftBatch.iter];\r\n            }\r\n            else\r\n            {\r\n        " +
                    "        UpdateTime(this.nextRightTime);\r\n\r\n                ProcessRightEvent(\r\n " +
                    "                   this.nextRightTime,\r\n                    rightBatch.vother.co" +
                    "l[rightBatch.iter],\r\n                    ref rightBatch.key.col[rightBatch.iter]" +
                    ",\r\n                    rightBatch.hash.col[rightBatch.iter]);\r\n\r\n               " +
                    " rightBatch.iter++;\r\n\r\n                if (!GoToVisibleRow(rightBatch))\r\n       " +
                    "         {\r\n                    leftBatchDone = false;\r\n                    righ" +
                    "tBatchDone = true;\r\n                    return;\r\n                }\r\n\r\n          " +
                    "      this.nextRightTime = rightBatch.vsync.col[rightBatch.iter];\r\n            }" +
                    "\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n  " +
                    "  protected override void ProcessLeftBatch(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> genericBatch, out bool isBatchDone, out bool isBatchFree)\r\n    {\r\n        var b" +
                    "atch = genericBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(@";

        isBatchFree = true;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                return;
            }

            this.nextLeftTime = batch.vsync.col[batch.iter];

            if (this.nextLeftTime > this.nextRightTime)
            {
                isBatchDone = false;
                return;
            }

            UpdateTime(this.nextLeftTime);

            ProcessLeftEvent(
                this.nextLeftTime,
                batch.vother.col[batch.iter],
                ref batch.key.col[batch.iter],
                batch,
                batch.iter,
                batch.hash.col[batch.iter]);

            batch.iter++;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessRightBatch(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("> genericBatch, out bool isBatchDone, out bool isBatchFree)\r\n    {\r\n        var b" +
                    "atch = genericBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchTypeName));
            this.Write(@";

        isBatchFree = true;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                return;
            }

            this.nextRightTime = batch.vsync.col[batch.iter];

            if (this.nextRightTime > this.nextLeftTime)
            {
                isBatchDone = false;
                return;
            }

            UpdateTime(this.nextRightTime);

            ProcessRightEvent(
                this.nextRightTime,
                batch.vother.col[batch.iter],
                ref batch.key.col[batch.iter],
                batch.hash.col[batch.iter]);

            batch.iter++;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool GoToVisibleRow<TPayload>(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@", TPayload> batch)
    {
        while (batch.iter < batch.Count && (batch.bitvector.col[batch.iter >> 6] & (1L << (batch.iter & 0x3f))) != 00 && batch.vother.col[batch.iter] >= 0)
        {
            batch.iter++;
        }

        if (batch.iter == batch.Count)
        {
            return false;
        }

        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdateTime(long time)
    {
        if (time != this.currTime)
        {
            LeaveTime();
            this.currTime = time;
            ReachTime();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ProcessLeftEvent(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(" batch, int batchIndex, int hash)\r\n    {\r\n        if (start < end)\r\n        {\r\n  " +
                    "          // Row is a start edge or interval.\r\n            bool isProcessable = " +
                    "this.nextRightTime > start;\r\n            bool isInterval = end < StreamEvent.Inf" +
                    "initySyncTime;\r\n            var map = isInterval ? this.leftIntervalMap : this.l" +
                    "eftEdgeMap;\r\n            if (isProcessable)\r\n            {\r\n                int " +
                    "matchingRight;\r\n                if (FindOnRight(ref key, hash, out matchingRight" +
                    "))\r\n                {\r\n                    // Row joins with something on right," +
                    " so not currently visible.\r\n                    int index = map.Insert(hash);\r\n " +
                    "                   map.Values[index].Populate(start, NotActive, end, ref key, ba" +
                    "tch, batchIndex);\r\n                    if (isInterval)\r\n                    {\r\n " +
                    "                       this.leftEndPointHeap.Insert(end, index);\r\n              " +
                    "      }\r\n                }\r\n                else\r\n                {\r\n           " +
                    "         // Row does not join (and it is processable).\r\n                    bool" +
                    " isFullyOutputtable = isInterval && this.nextRightTime >= end;\r\n                " +
                    "    if (isFullyOutputtable)\r\n                    {\r\n                        // W" +
                    "ill never join because right has advanced beyond endtime, so output interval.\r\n " +
                    "                       AddToBatch(start, end, ref key, batch, batchIndex, hash);" +
                    "\r\n                    }\r\n                    else\r\n                    {\r\n      " +
                    "                  // Output start edge.\r\n                        int index = map" +
                    ".Insert(hash);\r\n                        map.Values[index].Populate(start, start," +
                    " end, ref key, batch, batchIndex);\r\n                        AddToBatch(start, St" +
                    "reamEvent.InfinitySyncTime, ref key, batch, batchIndex, hash);\r\n                " +
                    "        if (isInterval)\r\n                        {\r\n                            " +
                    "this.leftEndPointHeap.Insert(end, index);\r\n                        }\r\n          " +
                    "          }\r\n                }\r\n            }\r\n            else\r\n            {\r\n" +
                    "                // Row is not yet processable, so insert as invisible.\r\n        " +
                    "        int index = map.InsertInvisible(hash);\r\n                map.Values[index" +
                    "].Populate(start, NotActive, end, ref key, batch, batchIndex);\r\n            }\r\n " +
                    "       }\r\n        else if (end == StreamEvent.PunctuationOtherTime)\r\n        {\r\n" +
                    "            AddPunctuationToBatch(start);\r\n        }\r\n        else\r\n        {\r\n " +
                    "           // Row is an end edge.\r\n\r\n            // Remove from this.leftEdgeMap" +
                    ".\r\n            var leftEvents = this.leftEdgeMap.Find(hash);\r\n            int in" +
                    "dex;\r\n            while (leftEvents.Next(out index))\r\n            {\r\n           " +
                    "     var leftEdge = this.leftEdgeMap.Values[index];\r\n                if (AreSame" +
                    "(end, StreamEvent.InfinitySyncTime, ref key, batch, batchIndex, ref leftEdge))\r\n" +
                    "                {\r\n                    long currentStart = leftEdge.CurrentStart" +
                    ";\r\n                    if (currentStart != NotActive)\r\n                    {\r\n  " +
                    "                      // Matching left start edge is currently visible, so outpu" +
                    "t end edge.\r\n                        AddToBatch(start, currentStart, ref key, ba" +
                    "tch, batchIndex, hash);\r\n                    }\r\n\r\n                    leftEvents" +
                    ".Remove();\r\n                    break;\r\n                }\r\n            }\r\n      " +
                    "  }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    privat" +
                    "e void ProcessRightEvent(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, int hash)\r\n    {\r\n        if (start < end)\r\n        {\r\n            // Row i" +
                    "s a start edge or interval.\r\n            int index;\r\n            if (FindOnRight" +
                    "(ref key, hash, out index))\r\n            {\r\n                // Corresponding key" +
                    " already exists in map, so any joining on left and already not active.\r\n        " +
                    "        this.rightMap.Values[index].Count++;\r\n            }\r\n            else\r\n " +
                    "           {\r\n                // First instance of this key, so insert and make " +
                    "any joining left entries not active.\r\n                index = this.rightMap.Inse" +
                    "rt(hash);\r\n                this.rightMap.Values[index].Initialize(ref key);\r\n   " +
                    "             MakeMatchingLeftInvisible(start, ref key, hash);\r\n            }\r\n\r\n" +
                    "            if (end != StreamEvent.InfinitySyncTime)\r\n            {\r\n           " +
                    "     // Row is an interval, so schedule removal of interval.\r\n                th" +
                    "is.rightEndPointHeap.Insert(end, index);\r\n            }\r\n        }\r\n        else" +
                    " if (end == StreamEvent.PunctuationOtherTime)\r\n        {\r\n            AddPunctua" +
                    "tionToBatch(start);\r\n        }\r\n        else\r\n        {\r\n            // Row is a" +
                    "n end edge.\r\n\r\n            // Queue for removal when time advances.\r\n           " +
                    " int index = this.rightEndEdges.Push();\r\n            this.rightEndEdges.Values[i" +
                    "ndex].Populate(ref key, hash);\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOp" +
                    "tions.AggressiveInlining)]\r\n    private void LeaveTime()\r\n    {\r\n        // Carr" +
                    "y-out all queued end edges for right events.\r\n        int index;\r\n        int ha" +
                    "sh;\r\n        for (int i = 0; i < this.rightEndEdges.Count; i++)\r\n        {\r\n    " +
                    "        hash = this.rightEndEdges.Values[i].Hash;\r\n            if (FindOnRight(r" +
                    "ef this.rightEndEdges.Values[i].Key, hash, out index))\r\n            {\r\n         " +
                    "       int count = this.rightMap.Values[index].Count - 1;\r\n                if (c" +
                    "ount > 0)\r\n                {\r\n                    this.rightMap.Values[index].Co" +
                    "unt = count;\r\n                }\r\n                else\r\n                {\r\n      " +
                    "              MakeMatchingLeftVisible(this.currTime, ref this.rightMap.Values[in" +
                    "dex].Key, hash);\r\n                    this.rightMap.Remove(index);\r\n            " +
                    "    }\r\n            }\r\n        }\r\n\r\n        this.rightEndEdges.Clear();\r\n\r\n      " +
                    "  // Actually insert all pending left start intervals.\r\n        var leftEvents =" +
                    " this.leftIntervalMap.TraverseInvisible();\r\n        while (leftEvents.Next(out i" +
                    "ndex, out hash))\r\n        {\r\n            var leftInterval = this.leftIntervalMap" +
                    ".Values[index];\r\n            long end = leftInterval.End;\r\n            int match" +
                    "ingRight;\r\n            if (FindOnRight(ref leftInterval.Key, hash, out matchingR" +
                    "ight))\r\n            {\r\n                leftEvents.MakeVisible();\r\n              " +
                    "  this.leftEndPointHeap.Insert(end, index);\r\n            }\r\n            else\r\n  " +
                    "          {\r\n                // Row does not join.\r\n                bool isFully" +
                    "Outputtable = this.nextRightTime >= end;\r\n                if (isFullyOutputtable" +
                    ")\r\n                {\r\n                    AddToBatch(\r\n                        t" +
                    "his.currTime,\r\n                        end,\r\n                        ref leftInt" +
                    "erval.Key,\r\n                        ref leftInterval,\r\n                        h" +
                    "ash);\r\n                    leftEvents.Remove();\r\n                }\r\n            " +
                    "    else\r\n                {\r\n                    leftEvents.MakeVisible();\r\n    " +
                    "                this.leftIntervalMap.Values[index].CurrentStart = this.currTime;" +
                    "\r\n                    AddToBatch(\r\n                        this.currTime,\r\n     " +
                    "                   StreamEvent.InfinitySyncTime,\r\n                        ref th" +
                    "is.leftIntervalMap.Values[index].Key,\r\n                        ref this.leftInte" +
                    "rvalMap.Values[index],\r\n                        hash);\r\n\r\n                    th" +
                    "is.leftEndPointHeap.Insert(end, index);\r\n                }\r\n            }\r\n     " +
                    "   }\r\n\r\n        // Actually insert all pending left start edges.\r\n        leftEv" +
                    "ents = this.leftEdgeMap.TraverseInvisible();\r\n        while (leftEvents.Next(out" +
                    " index, out hash))\r\n        {\r\n            int matchingRight;\r\n            if (!" +
                    "FindOnRight(ref this.leftEdgeMap.Values[index].Key, hash, out matchingRight))\r\n " +
                    "           {\r\n                // Row does not join, so output start edge.\r\n     " +
                    "           this.leftEdgeMap.Values[index].CurrentStart = this.currTime;\r\n       " +
                    "         AddToBatch(\r\n                    this.currTime,\r\n                    St" +
                    "reamEvent.InfinitySyncTime,\r\n                    ref this.leftEdgeMap.Values[ind" +
                    "ex].Key,\r\n                    ref this.leftEdgeMap.Values[index],\r\n             " +
                    "       hash);\r\n            }\r\n\r\n            leftEvents.MakeVisible();\r\n        }" +
                    "\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    private v" +
                    "oid ReachTime()\r\n    {\r\n        // Carry-out all interval endpoints for left int" +
                    "ervals that end prior to (or at) new current time.\r\n        long leftTime;\r\n    " +
                    "    int leftIndex;\r\n        if (!this.leftEndPointHeap.TryPeekNext(out leftTime," +
                    " out leftIndex))\r\n        {\r\n            leftTime = long.MaxValue;\r\n        }\r\n\r" +
                    "\n        long rightTime;\r\n        int rightIndex;\r\n        if (!this.rightEndPoi" +
                    "ntHeap.TryPeekNext(out rightTime, out rightIndex))\r\n        {\r\n            right" +
                    "Time = long.MaxValue;\r\n        }\r\n\r\n        while (leftTime <= this.currTime || " +
                    "rightTime < this.currTime)\r\n        {\r\n            if (leftTime <= rightTime)\r\n " +
                    "           {\r\n                // Always process left end-points first as they ma" +
                    "y end intervals that right end-points may\r\n                // try to make visibl" +
                    "e.\r\n                var leftInterval = this.leftIntervalMap.Values[leftIndex];\r\n" +
                    "                long currentStart = leftInterval.CurrentStart;\r\n                " +
                    "if (currentStart != NotActive)\r\n                {\r\n                    // Matchi" +
                    "ng left start edge is currently visible, so output end edge.\r\n                  " +
                    "  AddToBatch(\r\n                        leftTime,\r\n                        curren" +
                    "tStart,\r\n                        ref leftInterval.Key,\r\n                        " +
                    "ref leftInterval,\r\n                        this.leftIntervalMap.GetHash(leftInde" +
                    "x));\r\n                }\r\n\r\n                this.leftIntervalMap.Remove(leftIndex" +
                    ");\r\n\r\n                this.leftEndPointHeap.RemoveTop();\r\n                if (!t" +
                    "his.leftEndPointHeap.TryPeekNext(out leftTime, out leftIndex))\r\n                " +
                    "{\r\n                    leftTime = long.MaxValue;\r\n                }\r\n           " +
                    " }\r\n            else\r\n            {\r\n                // Process right end-point " +
                    "up to but not including the current time.\r\n                int count = this.righ" +
                    "tMap.Values[rightIndex].Count - 1;\r\n                if (count > 0)\r\n            " +
                    "    {\r\n                    this.rightMap.Values[rightIndex].Count = count;\r\n    " +
                    "            }\r\n                else\r\n                {\r\n                    Make" +
                    "MatchingLeftVisible(rightTime, ref this.rightMap.Values[rightIndex].Key, this.ri" +
                    "ghtMap.GetHash(rightIndex));\r\n                    this.rightMap.Remove(rightInde" +
                    "x);\r\n                }\r\n\r\n                this.rightEndPointHeap.RemoveTop();\r\n " +
                    "               if (!this.rightEndPointHeap.TryPeekNext(out rightTime, out rightI" +
                    "ndex))\r\n                {\r\n                    rightTime = long.MaxValue;\r\n     " +
                    "           }\r\n            }\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptio" +
                    "ns.AggressiveInlining)]\r\n    private bool FindOnRight(ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, int hash, out int index)\r\n    {\r\n        int rightIndex;\r\n        var right" +
                    "Events = this.rightMap.Find(hash);\r\n        while (rightEvents.Next(out rightInd" +
                    "ex))\r\n        {\r\n            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparer("key", "this.rightMap.Values[rightIndex].Key")));
            this.Write(@")
            {
                index = rightIndex;
                return true;
            }
        }

        index = 0;
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void MakeMatchingLeftInvisible(long time, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, int hash)\r\n    {\r\n        // Make matching left intervals invisible.\r\n     " +
                    "   int index;\r\n        var leftEvents = this.leftIntervalMap.Find(hash);\r\n      " +
                    "  while (leftEvents.Next(out index))\r\n        {\r\n            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparer("key", "this.leftIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                // Output end edge.
                AddToBatch(
                    time,
                    this.leftIntervalMap.Values[index].CurrentStart,
                    ref this.leftIntervalMap.Values[index].Key,
                    ref this.leftIntervalMap.Values[index],
                    hash);

                // Mark left event as not visible.
                this.leftIntervalMap.Values[index].CurrentStart = NotActive;
            }
        }

        // Make matching left edges invisible.
        leftEvents = this.leftEdgeMap.Find(hash);
        while (leftEvents.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparer("key", "this.leftEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                // Output end edge.
                AddToBatch(
                    time,
                    this.leftEdgeMap.Values[index].CurrentStart,
                    ref this.leftEdgeMap.Values[index].Key,
                    ref this.leftEdgeMap.Values[index],
                    hash);

                // Mark left event as not visible.
                this.leftEdgeMap.Values[index].CurrentStart = NotActive;
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void MakeMatchingLeftVisible(long time, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, int hash)\r\n    {\r\n        // Make matching left intervals visible.\r\n       " +
                    " int index;\r\n        var leftEvents = this.leftIntervalMap.Find(hash);\r\n        " +
                    "while (leftEvents.Next(out index))\r\n        {\r\n            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparer("key", "this.leftIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                long end = this.leftIntervalMap.Values[index].End;
                bool isFullyOutputtable = this.nextRightTime >= end;
                if (isFullyOutputtable)
                {
                    // Output interval.
                    AddToBatch(
                        time,
                        end,
                        ref this.leftIntervalMap.Values[index].Key,
                        ref this.leftIntervalMap.Values[index],
                        hash);

                    // Mark left event as not visible so that an end-edge is not outputted when the interval actually endss.
                    this.leftIntervalMap.Values[index].CurrentStart = NotActive;
                }
                else
                {
                    // Output start edge.
                    AddToBatch(
                        time,
                        StreamEvent.InfinitySyncTime,
                        ref this.leftIntervalMap.Values[index].Key,
                        ref this.leftIntervalMap.Values[index],
                        hash);

                    // Mark left event as visible.
                    this.leftIntervalMap.Values[index].CurrentStart = time;
                }
            }
        }

        // Make matching left edges visible.
        leftEvents = this.leftEdgeMap.Find(hash);
        while (leftEvents.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparer("key", "this.leftEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                // Output start edge.
                AddToBatch(
                    time,
                    StreamEvent.InfinitySyncTime,
                    ref this.leftEdgeMap.Values[index].Key,
                    ref this.leftEdgeMap.Values[index],
                    hash);

                // Mark left event as visible.
                this.leftEdgeMap.Values[index].CurrentStart = time;
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddPunctuationToBatch(long start)
    {
        if (start > lastCTI)
        {
            lastCTI = start;

            int index = this.output.Count++;
            this.output.vsync.col[index] = start;
            this.output.vother.col[index] = StreamEvent.PunctuationOtherTime;
            this.output.key.col[index] = default;
");
     foreach (var f in this.leftFields) { 
       if (f.OptimizeString()) { 
            this.Write("            this.output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(string.Empty);\r\n");
       } else { 
            this.Write("            this.output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[index] = default;\r\n");
       } 
     } 
            this.Write(@"            this.output.hash.col[index] = 0;
            this.output.bitvector.col[index >> 6] |= (1L << (index & 0x3f));

            if (this.output.Count == Config.DataBatchSize) FlushContents();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(" batch, int batchIndex, int hash)\r\n    {\r\n        int index = this.output.Count++" +
                    ";\r\n        this.output.vsync.col[index] = start;\r\n        this.output.vother.col" +
                    "[index] = end;\r\n        this.output.key.col[index] = key;\r\n");
     foreach (var f in this.leftFields) { 
       if (f.OptimizeString()) { 
            this.Write("        this.output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write("[batchIndex]);\r\n");
       } else { 
            this.Write("        this.output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[index] = batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[batchIndex];\r\n");
       } 
     } 
            this.Write(@"        this.output.hash.col[index] = hash;

        if (this.output.Count == Config.DataBatchSize)
        {
            this.output.Seal();
            this.Observer.OnNext(this.output);
            GetOutputBatch();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref LeftEvent leftEvent, int hash)\r\n    {\r\n        int index = this.output." +
                    "Count++;\r\n        this.output.vsync.col[index] = start;\r\n        this.output.vot" +
                    "her.col[index] = end;\r\n        this.output.key.col[index] = key;\r\n");
     foreach (var f in this.leftFields) {
         string source;
         if (noLeftFields)
           source = "leftEvent.Payload";
         else
           source = "leftEvent.Payload." + f.OriginalName;

       if (f.OptimizeString()) { 
            this.Write("        this.output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(");
            this.Write(this.ToStringHelper.ToStringWithCulture(source));
            this.Write(");\r\n");
       } else { 
            this.Write("        this.output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[index] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(source));
            this.Write(";\r\n");
       } 
     } 
            this.Write("        this.output.hash.col[index] = hash;\r\n\r\n        if (this.output.Count == C" +
                    "onfig.DataBatchSize) FlushContents();\r\n    }\r\n\r\n    [MethodImpl(MethodImplOption" +
                    "s.AggressiveInlining)]\r\n    private bool AreSame(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(" batch, int index, ref LeftEvent active)\r\n    {\r\n        return start == active.S" +
                    "tart &&\r\n            end == active.End &&\r\n            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparer("key", "active.Key")));
            this.Write(" &&\r\n            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftComparer("batch", "active.Payload")));
            this.Write(@";
    }

    protected override void FlushContents()
    {
        if (this.output.Count == 0) return;
        this.output.Seal();
        this.Observer.OnNext(this.output);
        GetOutputBatch();
    }

    private void GetOutputBatch()
    {
        this.pool.Get(out this.genericOutputBatch);
        this.genericOutputBatch.Allocate();
        this.output = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(")this.genericOutputBatch;\r\n");
 foreach (var f in this.leftFields.Where(fld => fld.OptimizeString())) {  
            this.Write("        this.output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Initialize();\r\n");
 } 
            this.Write("    }\r\n\r\n");
 if (!noLeftFields && !this.leftType.GetTypeInfo().IsValueType) { 
            this.Write("    [DataContract]\r\n    private struct ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write("\r\n    {\r\n        ");
 foreach (var f in this.leftFields) { 
            this.Write("        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n        ");
 } 
            this.Write("    }\r\n");
 } 
            this.Write("\r\n    [DataContract]\r\n    private struct LeftEvent\r\n    {\r\n        [DataMember]\r\n" +
                    "        public long Start;\r\n        [DataMember]\r\n        public long CurrentSta" +
                    "rt;\r\n        [DataMember]\r\n        public long End;\r\n        [DataMember]\r\n     " +
                    "   public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write(" Payload;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        " +
                    "public void Populate(long start, long currentStart, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(" batch, int index)\r\n        {\r\n            Start = start;\r\n            CurrentSta" +
                    "rt = currentStart;\r\n            End = end;\r\n            Key = key;\r\n");
 if (noLeftFields) { 
            this.Write("            this.Payload = batch.payload.col[index];\r\n");
 } else { 
     foreach (var f in leftFields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
     } 
 } 
            this.Write("        }\r\n\r\n        public override string ToString()\r\n        {\r\n            Sy" +
                    "stem.Text.StringBuilder sb = new System.Text.StringBuilder();\r\n            sb.Ap" +
                    "pendFormat(\"[Start={0}\", Start);\r\n            sb.AppendFormat(\", Key=\'{0}\'\", Key" +
                    ");\r\n");
 if (noLeftFields) { 
            this.Write("            sb.AppendFormat(\", payload={0}, \", this.Payload);\r\n");
 } else { 
     foreach (var f in leftFields) { 
            this.Write("            sb.AppendFormat(\", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write("={0}, \", this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(");\r\n");
     } 
 } 
            this.Write("            sb.Append(\"]\");\r\n            return sb.ToString();\r\n        }\r\n    }\r" +
                    "\n\r\n    [DataContract]\r\n    private struct RightEvent\r\n    {\r\n        [DataMember" +
                    "]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public int Count;\r\n\r\n        [MethodImpl(Met" +
                    "hodImplOptions.AggressiveInlining)]\r\n        public void Initialize(ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@" key)
        {
            Key = key;
            Count = 1;
        }

        public override string ToString()
        {
            return ""[Key='"" + Key + ""', Count="" + Count + ""]"";
        }
    }

    [DataContract]
    private struct QueuedEndEdge
    {
        [DataMember]
        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public int Hash;\r\n\r\n        [MethodImpl(Meth" +
                    "odImplOptions.AggressiveInlining)]\r\n        public void Populate(ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, int hash)\r\n        {\r\n            Key = key;\r\n            Hash = hash;\r\n   " +
                    "     }\r\n\r\n        public override string ToString()\r\n        {\r\n            retu" +
                    "rn \"[Key=\'\" + Key + \"\', Hash=\" + Hash + \"]\";\r\n        }\r\n    }\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
}
