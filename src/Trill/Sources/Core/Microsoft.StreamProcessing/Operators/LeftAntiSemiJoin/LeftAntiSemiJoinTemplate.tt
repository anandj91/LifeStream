<#@ template language="C#" inherits="CommonBinaryTemplate" visibility="internal" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;
[assembly: IgnoresAccessChecksTo("Microsoft.StreamProcessing")]

// TKey: <#= TKey #>
// TLeft: <#= TLeft #>
// TRight: <#= TRight #>

<#
    var leftBatchTypeName = Transformer.GetBatchClassName(this.keyType, this.leftType) + this.TKeyTLeftGenericParameters;
    var rightBatchTypeName = Transformer.GetBatchClassName(this.keyType, this.rightType) + this.TKeyTRightGenericParameters;
#>

[DataContract]
[KnownType(typeof(EndPointHeap))]
[KnownType(typeof(EndPointQueue))]
internal sealed class <#= className #><#= genericParameters #> : BinaryPipe<<#= TKey #>, <#= TLeft #>, <#= TRight #>, <#= TLeft #>>, IBinaryObserver
{
    private const long NotActive = long.MaxValue;
    private readonly MemoryPool<<#= TKey #>, <#= TLeft #>> pool;

    [SchemaSerialization]
    private readonly Expression<Func<<#= TKey #>, <#= TKey #>, bool>> keyComparer;
    [SchemaSerialization]
    private readonly Expression<Func<<#= TLeft #>, <#= TLeft #>, bool>> leftComparer;

    private StreamMessage<<#= TKey #>, <#= TLeft #>> genericOutputBatch;
    [DataMember]
    private <#= BatchGeneratedFrom_TKey_TLeft #><#= TKeyTLeftGenericParameters #> output;
    [DataMember]
    private FastMap<LeftEvent> leftIntervalMap = new FastMap<LeftEvent>();
    [DataMember]
    private FastMap<LeftEvent> leftEdgeMap = new FastMap<LeftEvent>();
    [DataMember]
    private IEndPointOrderer leftEndPointHeap;
    [DataMember]
    private FastMap<RightEvent> rightMap = new FastMap<RightEvent>();
    [DataMember]
    private FastStack<QueuedEndEdge> rightEndEdges = new FastStack<QueuedEndEdge>();
    [DataMember]
    private IEndPointOrderer rightEndPointHeap;
    [DataMember]
    private long nextLeftTime = long.MinValue;
    [DataMember]
    private long nextRightTime = long.MinValue;
    [DataMember]
    private long currTime = long.MinValue;

    private readonly Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> queryPlanGenerator;

    <#= staticCtor #>

    [Obsolete("Used only by serialization. Do not call directly.")]
    public <#= className #>() { }

    public <#= className #>(
        IStreamable<<#= TKey #>, <#= TLeft #>> stream,
        IStreamObserver<<#= TKey #>, <#= TLeft #>> observer,
        IEqualityComparerExpression<<#= TKey #>> keyEqualityComparer,
        IEqualityComparerExpression<<#= TLeft #>> leftComparer,
        Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> queryPlanGenerator,
        bool leftIsConstantDuration,
        bool rightIsConstantDuration)
        : base(stream, observer)
    {
        this.queryPlanGenerator = queryPlanGenerator;

        this.keyComparer = keyEqualityComparer.GetEqualsExpr();
        this.leftComparer = leftComparer.GetEqualsExpr();

        if (leftIsConstantDuration) this.leftEndPointHeap = new EndPointQueue();
        else this.leftEndPointHeap = new EndPointHeap();

        if (rightIsConstantDuration) this.rightEndPointHeap = new EndPointQueue();
        else this.rightEndPointHeap = new EndPointHeap();

        this.pool = MemoryManager.GetMemoryPool<<#= TKey #>, <#= TLeft #>>(true);
        GetOutputBatch();
    }

    public override int CurrentlyBufferedOutputCount => this.output.Count;
    public override int CurrentlyBufferedLeftInputCount => base.CurrentlyBufferedLeftInputCount + this.leftEdgeMap.Count + this.leftIntervalMap.Count;
    public override int CurrentlyBufferedRightInputCount => base.CurrentlyBufferedRightInputCount + this.rightEndEdges.Count + this.rightMap.Count;

    protected override void ProduceBinaryQueryPlan(PlanNode left, PlanNode right)
    {
        Observer.ProduceQueryPlan(queryPlanGenerator(left, right, this));
    }

    protected override void DisposeState()
    {
        this.output.Free();

        var allLeftEdgeTraverser = this.leftEdgeMap.Traverse();
        allLeftEdgeTraverser.currIndex = 0;
        int x, y;
        while (allLeftEdgeTraverser.Next(out x, out y))
        {
            var leftInterval = this.leftEdgeMap.Values[x];
        }
        var allLeftEdgeInvisibleTraverser = this.leftEdgeMap.TraverseInvisible();
        while (allLeftEdgeInvisibleTraverser.Next(out x, out y))
        {
            var leftEdge = this.leftEdgeMap.Values[x];
        }

        var allLeftIntervalTraverser = this.leftIntervalMap.Traverse();
        allLeftIntervalTraverser.currIndex = 0;
        while (allLeftIntervalTraverser.Next(out x, out y))
        {
            var leftInterval = this.leftIntervalMap.Values[x];
        }
        var allLeftIntervalInvisibleTraverser = this.leftIntervalMap.TraverseInvisible();
        while (allLeftIntervalInvisibleTraverser.Next(out x, out y))
        {
            var leftInterval = this.leftIntervalMap.Values[x];
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessBothBatches(StreamMessage<<#= TKey #>, <#= TLeft #>> genericLeftBatch, StreamMessage<<#= TKey #>, <#= TRight #>> genericRightBatch, out bool leftBatchDone, out bool rightBatchDone, out bool leftBatchFree, out bool rightBatchFree)
    {
        var leftBatch = genericLeftBatch as <#= leftBatchTypeName #>;
        var rightBatch = genericRightBatch as <#= rightBatchTypeName #>;

        leftBatchFree = rightBatchFree = true;
        if (!GoToVisibleRow(leftBatch))
        {
            leftBatchDone = true;
            rightBatchDone = false;
            return;
        }

        this.nextLeftTime = leftBatch.vsync.col[leftBatch.iter];

        if (!GoToVisibleRow(rightBatch))
        {
            leftBatchDone = false;
            rightBatchDone = true;
            return;
        }

        this.nextRightTime = rightBatch.vsync.col[rightBatch.iter];

        while (true)
        {
            if (this.nextLeftTime <= this.nextRightTime)
            {
                UpdateTime(this.nextLeftTime);

                ProcessLeftEvent(
                    this.nextLeftTime,
                    leftBatch.vother.col[leftBatch.iter],
                    ref leftBatch.key.col[leftBatch.iter],
                    leftBatch,
                    leftBatch.iter,
                    leftBatch.hash.col[leftBatch.iter]);

                leftBatch.iter++;

                if (!GoToVisibleRow(leftBatch))
                {
                    leftBatchDone = true;
                    rightBatchDone = false;
                    return;
                }

                this.nextLeftTime = leftBatch.vsync.col[leftBatch.iter];
            }
            else
            {
                UpdateTime(this.nextRightTime);

                ProcessRightEvent(
                    this.nextRightTime,
                    rightBatch.vother.col[rightBatch.iter],
                    ref rightBatch.key.col[rightBatch.iter],
                    rightBatch.hash.col[rightBatch.iter]);

                rightBatch.iter++;

                if (!GoToVisibleRow(rightBatch))
                {
                    leftBatchDone = false;
                    rightBatchDone = true;
                    return;
                }

                this.nextRightTime = rightBatch.vsync.col[rightBatch.iter];
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessLeftBatch(StreamMessage<<#= TKey #>, <#= TLeft #>> genericBatch, out bool isBatchDone, out bool isBatchFree)
    {
        var batch = genericBatch as <#= leftBatchTypeName #>;

        isBatchFree = true;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                return;
            }

            this.nextLeftTime = batch.vsync.col[batch.iter];

            if (this.nextLeftTime > this.nextRightTime)
            {
                isBatchDone = false;
                return;
            }

            UpdateTime(this.nextLeftTime);

            ProcessLeftEvent(
                this.nextLeftTime,
                batch.vother.col[batch.iter],
                ref batch.key.col[batch.iter],
                batch,
                batch.iter,
                batch.hash.col[batch.iter]);

            batch.iter++;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessRightBatch(StreamMessage<<#= TKey #>, <#= TRight #>> genericBatch, out bool isBatchDone, out bool isBatchFree)
    {
        var batch = genericBatch as <#= rightBatchTypeName #>;

        isBatchFree = true;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                return;
            }

            this.nextRightTime = batch.vsync.col[batch.iter];

            if (this.nextRightTime > this.nextLeftTime)
            {
                isBatchDone = false;
                return;
            }

            UpdateTime(this.nextRightTime);

            ProcessRightEvent(
                this.nextRightTime,
                batch.vother.col[batch.iter],
                ref batch.key.col[batch.iter],
                batch.hash.col[batch.iter]);

            batch.iter++;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool GoToVisibleRow<TPayload>(StreamMessage<<#= TKey #>, TPayload> batch)
    {
        while (batch.iter < batch.Count && (batch.bitvector.col[batch.iter >> 6] & (1L << (batch.iter & 0x3f))) != 00 && batch.vother.col[batch.iter] >= 0)
        {
            batch.iter++;
        }

        if (batch.iter == batch.Count)
        {
            return false;
        }

        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdateTime(long time)
    {
        if (time != this.currTime)
        {
            LeaveTime();
            this.currTime = time;
            ReachTime();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ProcessLeftEvent(long start, long end, ref <#= TKey #> key, <#= leftBatchTypeName #> batch, int batchIndex, int hash)
    {
        if (start < end)
        {
            // Row is a start edge or interval.
            bool isProcessable = this.nextRightTime > start;
            bool isInterval = end < StreamEvent.InfinitySyncTime;
            var map = isInterval ? this.leftIntervalMap : this.leftEdgeMap;
            if (isProcessable)
            {
                int matchingRight;
                if (FindOnRight(ref key, hash, out matchingRight))
                {
                    // Row joins with something on right, so not currently visible.
                    int index = map.Insert(hash);
                    map.Values[index].Populate(start, NotActive, end, ref key, batch, batchIndex);
                    if (isInterval)
                    {
                        this.leftEndPointHeap.Insert(end, index);
                    }
                }
                else
                {
                    // Row does not join (and it is processable).
                    bool isFullyOutputtable = isInterval && this.nextRightTime >= end;
                    if (isFullyOutputtable)
                    {
                        // Will never join because right has advanced beyond endtime, so output interval.
                        AddToBatch(start, end, ref key, batch, batchIndex, hash);
                    }
                    else
                    {
                        // Output start edge.
                        int index = map.Insert(hash);
                        map.Values[index].Populate(start, start, end, ref key, batch, batchIndex);
                        AddToBatch(start, StreamEvent.InfinitySyncTime, ref key, batch, batchIndex, hash);
                        if (isInterval)
                        {
                            this.leftEndPointHeap.Insert(end, index);
                        }
                    }
                }
            }
            else
            {
                // Row is not yet processable, so insert as invisible.
                int index = map.InsertInvisible(hash);
                map.Values[index].Populate(start, NotActive, end, ref key, batch, batchIndex);
            }
        }
        else if (end == StreamEvent.PunctuationOtherTime)
        {
            AddPunctuationToBatch(start);
        }
        else
        {
            // Row is an end edge.

            // Remove from this.leftEdgeMap.
            var leftEvents = this.leftEdgeMap.Find(hash);
            int index;
            while (leftEvents.Next(out index))
            {
                var leftEdge = this.leftEdgeMap.Values[index];
                if (AreSame(end, StreamEvent.InfinitySyncTime, ref key, batch, batchIndex, ref leftEdge))
                {
                    long currentStart = leftEdge.CurrentStart;
                    if (currentStart != NotActive)
                    {
                        // Matching left start edge is currently visible, so output end edge.
                        AddToBatch(start, currentStart, ref key, batch, batchIndex, hash);
                    }

                    leftEvents.Remove();
                    break;
                }
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ProcessRightEvent(long start, long end, ref <#= TKey #> key, int hash)
    {
        if (start < end)
        {
            // Row is a start edge or interval.
            int index;
            if (FindOnRight(ref key, hash, out index))
            {
                // Corresponding key already exists in map, so any joining on left and already not active.
                this.rightMap.Values[index].Count++;
            }
            else
            {
                // First instance of this key, so insert and make any joining left entries not active.
                index = this.rightMap.Insert(hash);
                this.rightMap.Values[index].Initialize(ref key);
                MakeMatchingLeftInvisible(start, ref key, hash);
            }

            if (end != StreamEvent.InfinitySyncTime)
            {
                // Row is an interval, so schedule removal of interval.
                this.rightEndPointHeap.Insert(end, index);
            }
        }
        else if (end == StreamEvent.PunctuationOtherTime)
        {
            AddPunctuationToBatch(start);
        }
        else
        {
            // Row is an end edge.

            // Queue for removal when time advances.
            int index = this.rightEndEdges.Push();
            this.rightEndEdges.Values[index].Populate(ref key, hash);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void LeaveTime()
    {
        // Carry-out all queued end edges for right events.
        int index;
        int hash;
        for (int i = 0; i < this.rightEndEdges.Count; i++)
        {
            hash = this.rightEndEdges.Values[i].Hash;
            if (FindOnRight(ref this.rightEndEdges.Values[i].Key, hash, out index))
            {
                int count = this.rightMap.Values[index].Count - 1;
                if (count > 0)
                {
                    this.rightMap.Values[index].Count = count;
                }
                else
                {
                    MakeMatchingLeftVisible(this.currTime, ref this.rightMap.Values[index].Key, hash);
                    this.rightMap.Remove(index);
                }
            }
        }

        this.rightEndEdges.Clear();

        // Actually insert all pending left start intervals.
        var leftEvents = this.leftIntervalMap.TraverseInvisible();
        while (leftEvents.Next(out index, out hash))
        {
            var leftInterval = this.leftIntervalMap.Values[index];
            long end = leftInterval.End;
            int matchingRight;
            if (FindOnRight(ref leftInterval.Key, hash, out matchingRight))
            {
                leftEvents.MakeVisible();
                this.leftEndPointHeap.Insert(end, index);
            }
            else
            {
                // Row does not join.
                bool isFullyOutputtable = this.nextRightTime >= end;
                if (isFullyOutputtable)
                {
                    AddToBatch(
                        this.currTime,
                        end,
                        ref leftInterval.Key,
                        ref leftInterval,
                        hash);
                    leftEvents.Remove();
                }
                else
                {
                    leftEvents.MakeVisible();
                    this.leftIntervalMap.Values[index].CurrentStart = this.currTime;
                    AddToBatch(
                        this.currTime,
                        StreamEvent.InfinitySyncTime,
                        ref this.leftIntervalMap.Values[index].Key,
                        ref this.leftIntervalMap.Values[index],
                        hash);

                    this.leftEndPointHeap.Insert(end, index);
                }
            }
        }

        // Actually insert all pending left start edges.
        leftEvents = this.leftEdgeMap.TraverseInvisible();
        while (leftEvents.Next(out index, out hash))
        {
            int matchingRight;
            if (!FindOnRight(ref this.leftEdgeMap.Values[index].Key, hash, out matchingRight))
            {
                // Row does not join, so output start edge.
                this.leftEdgeMap.Values[index].CurrentStart = this.currTime;
                AddToBatch(
                    this.currTime,
                    StreamEvent.InfinitySyncTime,
                    ref this.leftEdgeMap.Values[index].Key,
                    ref this.leftEdgeMap.Values[index],
                    hash);
            }

            leftEvents.MakeVisible();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ReachTime()
    {
        // Carry-out all interval endpoints for left intervals that end prior to (or at) new current time.
        long leftTime;
        int leftIndex;
        if (!this.leftEndPointHeap.TryPeekNext(out leftTime, out leftIndex))
        {
            leftTime = long.MaxValue;
        }

        long rightTime;
        int rightIndex;
        if (!this.rightEndPointHeap.TryPeekNext(out rightTime, out rightIndex))
        {
            rightTime = long.MaxValue;
        }

        while (leftTime <= this.currTime || rightTime < this.currTime)
        {
            if (leftTime <= rightTime)
            {
                // Always process left end-points first as they may end intervals that right end-points may
                // try to make visible.
                var leftInterval = this.leftIntervalMap.Values[leftIndex];
                long currentStart = leftInterval.CurrentStart;
                if (currentStart != NotActive)
                {
                    // Matching left start edge is currently visible, so output end edge.
                    AddToBatch(
                        leftTime,
                        currentStart,
                        ref leftInterval.Key,
                        ref leftInterval,
                        this.leftIntervalMap.GetHash(leftIndex));
                }

                this.leftIntervalMap.Remove(leftIndex);

                this.leftEndPointHeap.RemoveTop();
                if (!this.leftEndPointHeap.TryPeekNext(out leftTime, out leftIndex))
                {
                    leftTime = long.MaxValue;
                }
            }
            else
            {
                // Process right end-point up to but not including the current time.
                int count = this.rightMap.Values[rightIndex].Count - 1;
                if (count > 0)
                {
                    this.rightMap.Values[rightIndex].Count = count;
                }
                else
                {
                    MakeMatchingLeftVisible(rightTime, ref this.rightMap.Values[rightIndex].Key, this.rightMap.GetHash(rightIndex));
                    this.rightMap.Remove(rightIndex);
                }

                this.rightEndPointHeap.RemoveTop();
                if (!this.rightEndPointHeap.TryPeekNext(out rightTime, out rightIndex))
                {
                    rightTime = long.MaxValue;
                }
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool FindOnRight(ref <#= TKey #> key, int hash, out int index)
    {
        int rightIndex;
        var rightEvents = this.rightMap.Find(hash);
        while (rightEvents.Next(out rightIndex))
        {
            if (<#= keyComparer("key", "this.rightMap.Values[rightIndex].Key") #>)
            {
                index = rightIndex;
                return true;
            }
        }

        index = 0;
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void MakeMatchingLeftInvisible(long time, ref <#= TKey #> key, int hash)
    {
        // Make matching left intervals invisible.
        int index;
        var leftEvents = this.leftIntervalMap.Find(hash);
        while (leftEvents.Next(out index))
        {
            if (<#= keyComparer("key", "this.leftIntervalMap.Values[index].Key") #>)
            {
                // Output end edge.
                AddToBatch(
                    time,
                    this.leftIntervalMap.Values[index].CurrentStart,
                    ref this.leftIntervalMap.Values[index].Key,
                    ref this.leftIntervalMap.Values[index],
                    hash);

                // Mark left event as not visible.
                this.leftIntervalMap.Values[index].CurrentStart = NotActive;
            }
        }

        // Make matching left edges invisible.
        leftEvents = this.leftEdgeMap.Find(hash);
        while (leftEvents.Next(out index))
        {
            if (<#= keyComparer("key", "this.leftEdgeMap.Values[index].Key") #>)
            {
                // Output end edge.
                AddToBatch(
                    time,
                    this.leftEdgeMap.Values[index].CurrentStart,
                    ref this.leftEdgeMap.Values[index].Key,
                    ref this.leftEdgeMap.Values[index],
                    hash);

                // Mark left event as not visible.
                this.leftEdgeMap.Values[index].CurrentStart = NotActive;
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void MakeMatchingLeftVisible(long time, ref <#= TKey #> key, int hash)
    {
        // Make matching left intervals visible.
        int index;
        var leftEvents = this.leftIntervalMap.Find(hash);
        while (leftEvents.Next(out index))
        {
            if (<#= keyComparer("key", "this.leftIntervalMap.Values[index].Key") #>)
            {
                long end = this.leftIntervalMap.Values[index].End;
                bool isFullyOutputtable = this.nextRightTime >= end;
                if (isFullyOutputtable)
                {
                    // Output interval.
                    AddToBatch(
                        time,
                        end,
                        ref this.leftIntervalMap.Values[index].Key,
                        ref this.leftIntervalMap.Values[index],
                        hash);

                    // Mark left event as not visible so that an end-edge is not outputted when the interval actually endss.
                    this.leftIntervalMap.Values[index].CurrentStart = NotActive;
                }
                else
                {
                    // Output start edge.
                    AddToBatch(
                        time,
                        StreamEvent.InfinitySyncTime,
                        ref this.leftIntervalMap.Values[index].Key,
                        ref this.leftIntervalMap.Values[index],
                        hash);

                    // Mark left event as visible.
                    this.leftIntervalMap.Values[index].CurrentStart = time;
                }
            }
        }

        // Make matching left edges visible.
        leftEvents = this.leftEdgeMap.Find(hash);
        while (leftEvents.Next(out index))
        {
            if (<#= keyComparer("key", "this.leftEdgeMap.Values[index].Key") #>)
            {
                // Output start edge.
                AddToBatch(
                    time,
                    StreamEvent.InfinitySyncTime,
                    ref this.leftEdgeMap.Values[index].Key,
                    ref this.leftEdgeMap.Values[index],
                    hash);

                // Mark left event as visible.
                this.leftEdgeMap.Values[index].CurrentStart = time;
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddPunctuationToBatch(long start)
    {
        if (start > lastCTI)
        {
            lastCTI = start;

            int index = this.output.Count++;
            this.output.vsync.col[index] = start;
            this.output.vother.col[index] = StreamEvent.PunctuationOtherTime;
            this.output.key.col[index] = default;
<#     foreach (var f in this.leftFields) { #>
<#       if (f.OptimizeString()) { #>
            this.output.<#= f.Name #>.AddString(string.Empty);
<#       } else { #>
            this.output.<#= f.Name #>.col[index] = default;
<#       } #>
<#     } #>
            this.output.hash.col[index] = 0;
            this.output.bitvector.col[index >> 6] |= (1L << (index & 0x3f));

            if (this.output.Count == Config.DataBatchSize) FlushContents();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref <#= TKey #> key, <#= leftBatchTypeName #> batch, int batchIndex, int hash)
    {
        int index = this.output.Count++;
        this.output.vsync.col[index] = start;
        this.output.vother.col[index] = end;
        this.output.key.col[index] = key;
<#     foreach (var f in this.leftFields) { #>
<#       if (f.OptimizeString()) { #>
        this.output.<#= f.Name #>.AddString(batch.<#= f.Name #>[batchIndex]);
<#       } else { #>
        this.output.<#= f.Name #>.col[index] = batch.<#= f.Name #>.col[batchIndex];
<#       } #>
<#     } #>
        this.output.hash.col[index] = hash;

        if (this.output.Count == Config.DataBatchSize)
        {
            this.output.Seal();
            this.Observer.OnNext(this.output);
            GetOutputBatch();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref <#= TKey #> key, ref LeftEvent leftEvent, int hash)
    {
        int index = this.output.Count++;
        this.output.vsync.col[index] = start;
        this.output.vother.col[index] = end;
        this.output.key.col[index] = key;
<#     foreach (var f in this.leftFields) {
         string source;
         if (noLeftFields)
           source = "leftEvent.Payload";
         else
           source = "leftEvent.Payload." + f.OriginalName;
#>
<#       if (f.OptimizeString()) { #>
        this.output.<#= f.Name #>.AddString(<#= source #>);
<#       } else { #>
        this.output.<#= f.Name #>.col[index] = <#= source #>;
<#       } #>
<#     } #>
        this.output.hash.col[index] = hash;

        if (this.output.Count == Config.DataBatchSize) FlushContents();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool AreSame(long start, long end, ref <#= TKey #> key, <#= leftBatchTypeName #> batch, int index, ref LeftEvent active)
    {
        return start == active.Start &&
            end == active.End &&
            <#= keyComparer("key", "active.Key") #> &&
            <#= leftComparer("batch", "active.Payload") #>;
    }

    protected override void FlushContents()
    {
        if (this.output.Count == 0) return;
        this.output.Seal();
        this.Observer.OnNext(this.output);
        GetOutputBatch();
    }

    private void GetOutputBatch()
    {
        this.pool.Get(out this.genericOutputBatch);
        this.genericOutputBatch.Allocate();
        this.output = (<#= leftBatchTypeName #>)this.genericOutputBatch;
<# foreach (var f in this.leftFields.Where(fld => fld.OptimizeString())) {  #>
        this.output.<#= f.Name #>.Initialize();
<# } #>
    }

<# if (!noLeftFields && !this.leftType.GetTypeInfo().IsValueType) { #>
    [DataContract]
    private struct <#= ActiveEventType #>
    {
        <# foreach (var f in this.leftFields) { #>
        [DataMember]
        public <#= f.Type.GetCSharpSourceSyntax() #> <#= f.OriginalName #>;
        <# } #>
    }
<# } #>

    [DataContract]
    private struct LeftEvent
    {
        [DataMember]
        public long Start;
        [DataMember]
        public long CurrentStart;
        [DataMember]
        public long End;
        [DataMember]
        public <#= TKey #> Key;
        [DataMember]
        public <#= ActiveEventType #> Payload;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Populate(long start, long currentStart, long end, ref <#= TKey #> key, <#= leftBatchTypeName #> batch, int index)
        {
            Start = start;
            CurrentStart = currentStart;
            End = end;
            Key = key;
<# if (noLeftFields) { #>
            this.Payload = batch.payload.col[index];
<# } else { #>
<#     foreach (var f in leftFields) { #>
            this.Payload.<#= f.OriginalName #> = <#= f.AccessExpressionForRowValue("batch", "index") #>;
<#     } #>
<# } #>
        }

        public override string ToString()
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            sb.AppendFormat("[Start={0}", Start);
            sb.AppendFormat(", Key='{0}'", Key);
<# if (noLeftFields) { #>
            sb.AppendFormat(", payload={0}, ", this.Payload);
<# } else { #>
<#     foreach (var f in leftFields) { #>
            sb.AppendFormat(", <#= f.OriginalName #>={0}, ", this.Payload.<#= f.OriginalName #>);
<#     } #>
<# } #>
            sb.Append("]");
            return sb.ToString();
        }
    }

    [DataContract]
    private struct RightEvent
    {
        [DataMember]
        public <#= TKey #> Key;
        [DataMember]
        public int Count;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Initialize(ref <#= TKey #> key)
        {
            Key = key;
            Count = 1;
        }

        public override string ToString()
        {
            return "[Key='" + Key + "', Count=" + Count + "]";
        }
    }

    [DataContract]
    private struct QueuedEndEdge
    {
        [DataMember]
        public <#= TKey #> Key;
        [DataMember]
        public int Hash;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Populate(ref <#= TKey #> key, int hash)
        {
            Key = key;
            Hash = hash;
        }

        public override string ToString()
        {
            return "[Key='" + Key + "', Hash=" + Hash + "]";
        }
    }
}
