// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class StartEdgeEquiJoinTemplate : CommonBinaryTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;

// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TLeft: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("\r\n// TRight: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("\r\n// TResult: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("\r\n\r\n[DataContract]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(genericParameters));
            this.Write(" : BinaryPipe<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(">\r\n{\r\n    private const int DefaultCapacity = 64;\r\n    private readonly MemoryPoo" +
                    "l<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(@"> pool;
    private readonly Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> queryPlanGenerator;

    [DataMember]
    private FastMap<ActiveEventLeft> leftEdgeMap = new FastMap<ActiveEventLeft>(DefaultCapacity);
    [DataMember]
    private FastMap<ActiveEventRight> rightEdgeMap = new FastMap<ActiveEventRight>(DefaultCapacity);

    private StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("> genericOutputBatch;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TResult));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTResultGenericParameters));
            this.Write(@" output;

    [DataMember]
    private long nextLeftTime = long.MinValue;
    [DataMember]
    private bool isLeftComplete;
    [DataMember]
    private long nextRightTime = long.MinValue;
    [DataMember]
    private bool isRightComplete;

    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("> observer,\r\n        Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> qu" +
                    "eryPlanGenerator)\r\n        : base(stream, observer)\r\n    {\r\n        pool = Memor" +
                    "yManager.GetMemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(">(true /*stream.Properties.IsColumnar*/);\r\n        ");
 GetOutputBatch(); 
            this.Write("        this.queryPlanGenerator = queryPlanGenerator;\r\n    }\r\n\r\n    protected ove" +
                    "rride void FlushContents()\r\n    {\r\n        if (output.Count == 0) return;\r\n     " +
                    "   output.Seal();\r\n        this.Observer.OnNext(output);\r\n        ");
 GetOutputBatch(); 
            this.Write(@"    }

    public override int CurrentlyBufferedOutputCount => output.Count;
    public override int CurrentlyBufferedLeftInputCount => base.CurrentlyBufferedLeftInputCount + leftEdgeMap.Count;
    public override int CurrentlyBufferedRightInputCount => base.CurrentlyBufferedRightInputCount + rightEdgeMap.Count;

    protected override void ProduceBinaryQueryPlan(PlanNode left, PlanNode right)
    {
        Observer.ProduceQueryPlan(queryPlanGenerator(left, right, this));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void DisposeState() => this.output.Free();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessBothBatches(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> leftBatch, StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("> rightBatch, out bool leftBatchDone, out bool rightBatchDone, out bool leftBatch" +
                    "Free, out bool rightBatchFree)\r\n    {\r\n        var generatedLeftBatch = leftBatc" +
                    "h as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(keyType, leftType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTLeftGenericParameters));
            this.Write(";\r\n        var generatedRightBatch = rightBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(keyType, rightType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTRightGenericParameters));
            this.Write(@";

        leftBatchFree = rightBatchFree = true;
        if (!GoToVisibleRow(leftBatch))
        {
            leftBatchDone = true;
            rightBatchDone = false;
            return;
        }

        UpdateNextLeftTime(leftBatch.vsync.col[leftBatch.iter]);

        if (!GoToVisibleRow(rightBatch))
        {
            leftBatchDone = false;
            rightBatchDone = true;
            return;
        }

        UpdateNextRightTime(rightBatch.vsync.col[rightBatch.iter]);

        FastMap<ActiveEventRight>.FindTraverser rightEdges = default;
        while (true)
        {
            bool leftPunctuation = leftBatch.vother.col[leftBatch.iter] == StreamEvent.PunctuationOtherTime;
            bool rightPunctuation = rightBatch.vother.col[rightBatch.iter] == StreamEvent.PunctuationOtherTime;

            if (nextLeftTime <= nextRightTime)
            {
                if (leftPunctuation)
                {
                    AddPunctuationToBatch(nextLeftTime);
                }
                else
                {
                    // ProcessLeftStartEdge
                    if (true)
                    {
                        bool first = true;
                        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@" key = default;

                        var hash = leftBatch.hash.col[leftBatch.iter];
                        if (rightEdgeMap.Find(hash, ref rightEdges))
                        {
                            int rightIndex;

                            while (rightEdges.Next(out rightIndex))
                            {
                                if (first) { key = leftBatch.key.col[leftBatch.iter]; first = false; }
                                var activeEventRight = rightEdgeMap.Values[rightIndex];
                                var rightKey = activeEventRight.Key;
                                if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.keyComparer("key", "rightKey")));
            this.Write(")\r\n                                {\r\n                                    ");
 OutputStartEdgeWithActiveEventRight("nextLeftTime", "key", "generatedLeftBatch", "leftBatch.iter", "activeEventRight", "hash"); 
            this.Write(@"                                }
                            }
                        }
                        if (!isRightComplete)
                        {
                            int newIndex = leftEdgeMap.Insert(hash);
                            if (first) key = leftBatch.key.col[leftBatch.iter];
                            leftEdgeMap.Values[newIndex].Populate(generatedLeftBatch, leftBatch.iter);
                        }
                    }
                }

                leftBatch.iter++;

                if (!GoToVisibleRow(leftBatch))
                {
                    leftBatchDone = true;
                    rightBatchDone = false;
                    return;
                }

                UpdateNextLeftTime(leftBatch.vsync.col[leftBatch.iter]);
            }
            else
            {
                if (rightPunctuation)
                {
                    AddPunctuationToBatch(nextRightTime);
                }
                else
                {
                    // ProcessRightStartEdge
                    ");
 ProcessRightStartEdge2(
                        "nextRightTime",
                        "generatedRightBatch",
                        "rightBatch.iter",
                        "rightBatch.hash.col[rightBatch.iter]");
                    
            this.Write(@"                }

                rightBatch.iter++;

                if (!GoToVisibleRow(rightBatch))
                {
                    leftBatchDone = false;
                    rightBatchDone = true;
                    return;
                }

                UpdateNextRightTime(rightBatch.vsync.col[rightBatch.iter]);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessLeftBatch(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> batch, out bool isBatchDone, out bool isBatchFree)\r\n    {\r\n        var generate" +
                    "dLeftBatch = batch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(keyType, leftType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTLeftGenericParameters));
            this.Write(@";

        isBatchFree = true;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                return;
            }

            UpdateNextLeftTime(batch.vsync.col[batch.iter]);

            if (nextLeftTime > nextRightTime)
            {
                isBatchDone = false;
                return;
            }

            if (batch.vother.col[batch.iter] == StreamEvent.PunctuationOtherTime)
            {
                AddPunctuationToBatch(batch.vsync.col[batch.iter]);
                batch.iter++;
                continue;
            }

            // ProcessLeftStartEdge
            FastMap<ActiveEventRight>.FindTraverser rightEdges = default;
            if (true)
            {
                bool first = true;
                ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@" key = default;

                var hash = batch.hash.col[batch.iter];
                if (rightEdgeMap.Find(hash, ref rightEdges))
                {
                    int rightIndex;

                    while (rightEdges.Next(out rightIndex))
                    {
                        if (first) { key = batch.key.col[batch.iter]; first = false; }
                        var activeEventRight = rightEdgeMap.Values[rightIndex];
                        var rightKey = activeEventRight.Key;
                        if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.keyComparer("key", "rightKey")));
            this.Write(")\r\n                        {\r\n                            ");
 OutputStartEdgeWithActiveEventRight("nextLeftTime", "key", "generatedLeftBatch", "batch.iter", "activeEventRight", "hash"); 
            this.Write(@"                        }
                    }
                }
                if (!isRightComplete)
                {
                    int newIndex = leftEdgeMap.Insert(hash);
                    if (first) key = batch.key.col[batch.iter];
                    leftEdgeMap.Values[newIndex].Populate(generatedLeftBatch, batch.iter);
                }
            }

            batch.iter++;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessRightBatch(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("> batch, out bool isBatchDone, out bool isBatchFree)\r\n    {\r\n        var generate" +
                    "dBatch = batch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(keyType, rightType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTRightGenericParameters));
            this.Write(@";

        isBatchFree = true;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                return;
            }

            UpdateNextRightTime(batch.vsync.col[batch.iter]);

            if (nextRightTime > nextLeftTime)
            {
                isBatchDone = false;
                return;
            }

            if (batch.vother.col[batch.iter] == StreamEvent.PunctuationOtherTime)
            {
                AddPunctuationToBatch(batch.vsync.col[batch.iter]);
                batch.iter++;
                continue;
            }

            // ProcessRightStartEdge
            ");
 ProcessRightStartEdge2(
                "nextRightTime",
                "generatedBatch",
                "batch.iter",
                "batch.hash.col[batch.iter]");
            
            this.Write("\r\n            batch.iter++;\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOption" +
                    "s.AggressiveInlining)]\r\n    private bool GoToVisibleRow<TPayload>(StreamMessage<" +
                    "");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", TPayload> batch)\r\n    {\r\n        while (batch.iter < batch.Count && (batch.bitv" +
                    "ector.col[batch.iter >> 6] & (1L << (batch.iter & 0x3f))) != 0 && batch.vother.c" +
                    "ol[batch.iter] >= 0)\r\n        {\r\n            batch.iter++;\r\n        }\r\n\r\n       " +
                    " return (batch.iter != batch.Count);\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions" +
                    ".AggressiveInlining)]\r\n    private void UpdateNextLeftTime(long time)\r\n    {\r\n  " +
                    "      nextLeftTime = time;\r\n        if (nextLeftTime == StreamEvent.InfinitySync" +
                    "Time)\r\n        {\r\n            isLeftComplete = true;\r\n        }\r\n    }\r\n\r\n    [M" +
                    "ethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    private void UpdateNextRig" +
                    "htTime(long time)\r\n    {\r\n        nextRightTime = time;\r\n        if (nextRightTi" +
                    "me == StreamEvent.InfinitySyncTime)\r\n        {\r\n            isRightComplete = tr" +
                    "ue;\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r" +
                    "\n    private void AddPunctuationToBatch(long start)\r\n    {\r\n        if (start > " +
                    "lastCTI)\r\n        {\r\n            lastCTI = start;\r\n\r\n            int index = out" +
                    "put.Count++;\r\n            output.vsync.col[index] = start;\r\n            output.v" +
                    "other.col[index] = StreamEvent.PunctuationOtherTime;\r\n            output.key.col" +
                    "[index] = default;\r\n            output[index] = default;\r\n            output.has" +
                    "h.col[index] = 0;\r\n            output.bitvector.col[index >> 6] |= (1L << (index" +
                    " & 0x3f));\r\n\r\n            if (output.Count == Config.DataBatchSize) FlushContent" +
                    "s();\r\n        }\r\n    }\r\n\r\n    [DataContract]\r\n    private struct ActiveEventLeft" +
                    "\r\n    {\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        ");
 foreach (var f in this.leftFields) { 
            this.Write("\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n        ");
 } 
            this.Write("\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public void" +
                    " Populate(");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TLeft));
            this.Write(" batch, int index)\r\n        {\r\n            Key = batch.key.col[index];\r\n         " +
                    "   ");
 foreach (var f in this.leftFields) { 
            this.Write("\r\n            this.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n            ");
 } 
            this.Write("\r\n        }\r\n\r\n        public override string ToString()\r\n        {\r\n            " +
                    "return \"[Payload=\'\" + \"\']\";\r\n        }\r\n    }\r\n\r\n    [DataContract]\r\n    private" +
                    " struct ActiveEventRight\r\n    {\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        ");
 foreach (var f in this.rightFields) { 
            this.Write("\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n        ");
 } 
            this.Write("\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public void" +
                    " Populate(");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TRight));
            this.Write(" batch, int index)\r\n        {\r\n            Key = batch.key.col[index];\r\n         " +
                    "   ");
 foreach (var f in this.rightFields) { 
            this.Write("\r\n            this.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n            ");
 } 
            this.Write("\r\n        }\r\n\r\n        public override string ToString()\r\n        {\r\n            " +
                    "return \"[Payload=\'\" + \"\']\";\r\n        }\r\n    }\r\n}\r\n\r\n");
            return this.GenerationEnvironment.ToString();
        }

private void ProcessRightStartEdge2(string start, string rightBatch, string rightBatchIndex, string hash)
{

this.Write("  { // begin ProcessRigthStartEdge\r\n    var start_ProcessRightStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(start));

this.Write(";\r\n    var rightBatch_ProcessRightStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(rightBatch));

this.Write(";\r\n    var rightBatchIndex_ProcessRightStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchIndex));

this.Write(";\r\n    var key_ProcessRightStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(rightBatch));

this.Write(".key.col[");

this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchIndex));

this.Write("];\r\n    var hash_ProcessRightStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(hash));

this.Write(@";
    if (leftEdgeMap.Count > 0)
    {
        var leftEdges = leftEdgeMap.Find(hash_ProcessRightStartEdge);
        int leftIndex;
        while (leftEdges.Next(out leftIndex))
        {
            //if (keyComparer(key, leftEdgeMap.Values[leftIndex].Key))
            var activeEventLeft = leftEdgeMap.Values[leftIndex];
            var leftKey = activeEventLeft.Key;
            if (");

this.Write(this.ToStringHelper.ToStringWithCulture(this.keyComparer("key_ProcessRightStartEdge", "leftKey")));

this.Write(")\r\n            {\r\n                //OutputStartEdge(start, ref key, ref leftEdgeM" +
        "ap.Values[leftIndex].Payload, ref payload, hash);\r\n");


                OutputStartEdgeWithActiveEventLeft("start_ProcessRightStartEdge", "key_ProcessRightStartEdge", "activeEventLeft", "rightBatch_ProcessRightStartEdge", "rightBatchIndex_ProcessRightStartEdge", "hash_ProcessRightStartEdge");

this.Write("            }\r\n        }\r\n    }\r\n    if (!isLeftComplete)\r\n    {\r\n        int new" +
        "Index = rightEdgeMap.Insert(");

this.Write(this.ToStringHelper.ToStringWithCulture(hash));

this.Write(");\r\n        rightEdgeMap.Values[newIndex].Populate(");

this.Write(this.ToStringHelper.ToStringWithCulture(rightBatch));

this.Write(", ");

this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchIndex));

this.Write(");\r\n    }\r\n  } // end ProcessRightStartEdge\r\n");


}

// inline: private void OutputStartEdge(long start, ref TKey key, ref TLeft leftPayload, ref TRight rightPayload, int hash)
private void OutputStartEdgeWithActiveEventLeft(string start, string key, string activeEventLeft, string rightBatch, string rightBatchIndex, string hash)
{

this.Write("   { // begin OutputStartEdgeWithActiveEventLeft\r\n        var start_OutputStartEd" +
        "ge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(start));

this.Write(";\r\n        var key_OutputStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write(";\r\n        var rightBatch_OutputStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(rightBatch));

this.Write(";\r\n        var rightBatchIndex_OutputStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchIndex));

this.Write(";\r\n        var hash_OutputStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(hash));

this.Write(";\r\n\r\n        int index = output.Count++;\r\n        output.vsync.col[index] = start" +
        "_OutputStartEdge;\r\n        output.vother.col[index] = StreamEvent.InfinitySyncTi" +
        "me;\r\n        output.key.col[index] = key_OutputStartEdge;\r\n");

 if (this.leftMessageRepresentation.noFields) { 
this.Write("        ");

this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchSelector(activeEventLeft + ".payload", "rightBatch_OutputStartEdge", "rightBatchIndex_OutputStartEdge")));

this.Write("\r\n");

 } else { 
this.Write("        ");

this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchSelector(activeEventLeft, "rightBatch_OutputStartEdge", "rightBatchIndex_OutputStartEdge")));

this.Write("\r\n");

 } 
this.Write("        output.hash.col[index] = hash_OutputStartEdge;\r\n\r\n        if (output.Coun" +
        "t == Config.DataBatchSize) FlushContents();\r\n    } // end OutputStartEdgeWithAct" +
        "iveEventLeft\r\n");


}

// inline: private void OutputStartEdge(long start, ref TKey key, ref TLeft leftPayload, ref TRight rightPayload, int hash)
private void OutputStartEdgeWithActiveEventRight(string start, string key, string leftBatch, string leftBatchIndex, string rightActiveEvent, string hash)
{

this.Write("   { // begin OutputStartEdgeWithActiveEventRight\r\n        var start_OutputStartE" +
        "dge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(start));

this.Write(";\r\n        var key_OutputStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write(";\r\n        var leftBatch_OutputStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(leftBatch));

this.Write(";\r\n        var leftBatchIndex = ");

this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchIndex));

this.Write(";\r\n        var hash_OutputStartEdge = ");

this.Write(this.ToStringHelper.ToStringWithCulture(hash));

this.Write(";\r\n\r\n        int index = output.Count++;\r\n        output.vsync.col[index] = start" +
        "_OutputStartEdge;\r\n        output.vother.col[index] = StreamEvent.InfinitySyncTi" +
        "me;\r\n        output.key.col[index] = key_OutputStartEdge;\r\n");

 if (this.rightMessageRepresentation.noFields) { 
this.Write("        ");

this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchSelector("leftBatch_OutputStartEdge", "leftBatchIndex", rightActiveEvent + ".payload")));

this.Write("\r\n");

 } else { 
this.Write("        ");

this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchSelector("leftBatch_OutputStartEdge", "leftBatchIndex", rightActiveEvent)));

this.Write("\r\n");

 } 
this.Write("        output.hash.col[index] = hash_OutputStartEdge;\r\n\r\n        if (output.Coun" +
        "t == Config.DataBatchSize) FlushContents();\r\n    } // end OutputStartEdgeWithAct" +
        "iveEventRight\r\n");


}

    private void GetOutputBatch() { 
this.Write("  pool.Get(out genericOutputBatch);\r\n  genericOutputBatch.Allocate();\r\n  output =" +
        " (");

this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(this.keyType, this.resultType)));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(this.TKeyTResultGenericParameters));

this.Write(")genericOutputBatch;\r\n");

 foreach (var f in this.outputFields.Where(fld => fld.OptimizeString())) {  
this.Write("  output.");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(".Initialize();\r\n");

 }

    } 
    }
}
