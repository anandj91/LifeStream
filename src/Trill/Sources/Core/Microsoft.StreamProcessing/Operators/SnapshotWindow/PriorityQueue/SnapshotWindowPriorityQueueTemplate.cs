// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    internal partial class SnapshotWindowPriorityQueueTemplate : AggregateTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write("\r\n");
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;

using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;
using Microsoft.StreamProcessing.Aggregates;

");


  List<string> genericParamList = new List<string>();
  int oldCount = 0;
  var TKey = keyType.GetCSharpSourceSyntax(ref genericParamList);
  var keyGenericParameters = new List<string>(genericParamList.Skip(oldCount));

  oldCount = genericParamList.Count;
  var TInput = inputType.GetCSharpSourceSyntax(ref genericParamList);
  var inputGenericParameters = new List<string>(genericParamList.Skip(oldCount));

  oldCount = genericParamList.Count;
  var TState = stateType.GetCSharpSourceSyntax(ref genericParamList);
  var stateGenericParameters = new List<string>(genericParamList.Skip(oldCount));

  oldCount = genericParamList.Count;
  var TOutput = outputType.GetCSharpSourceSyntax(ref genericParamList);
  var outputGenericParameters = new List<string>(genericParamList.Skip(oldCount));

  var genericParameters = genericParamList.BracketedCommaSeparatedString();
  var TKeyTInputGenericParameters = keyGenericParameters.Concat(inputGenericParameters).BracketedCommaSeparatedString();
  var TKeyTOutputGenericParameters = keyGenericParameters.Concat(outputGenericParameters).BracketedCommaSeparatedString();

  var BatchGeneratedFrom_TKey_TInput = Transformer.GetBatchClassName(keyType, inputType);

  var genericParameters2 = string.Format("<{0}, {1}>", TKey, TOutput);
  if (!keyType.KeyTypeNeedsGeneratedMemoryPool() && outputType.MemoryPoolHasGetMethodFor())
      genericParameters2 = string.Empty;
  else if (!outputType.CanRepresentAsColumnar())
      genericParameters2 = string.Empty;

  Func<string, string> assignToOutput = rhs =>
    this.outputType.IsAnonymousType()
    ?
    rhs
    :
    (
    this.outputFields.Count() == 1
    ?
    string.Format("this.batch.{0}.col[c] = {1};", this.outputFields.First().Name, rhs)
    :
    "temporaryOutput = " + rhs + ";\r\n" + String.Join("\r\n", this.outputFields.Select(f => "dest_" + f.Name + "[c] = temporaryOutput." + f.OriginalName + ";")))
    ;

  var getOutputBatch = string.Format("this.pool.Get(out genericOutputbatch); this.batch = ({0}{1})genericOutputbatch;",
          Transformer.GetBatchClassName(keyType, outputType),
          TKeyTOutputGenericParameters);


            this.Write("[assembly: IgnoresAccessChecksTo(\"Microsoft.StreamProcessing\")]\r\n\r\n// genericPara" +
                    "ms2 = \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(genericParameters2));
            this.Write("\"\r\n\r\n[DataContract]\r\nstruct StateAndActive\r\n{\r\n    [DataMember]\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write(" state;\r\n    [DataMember]\r\n    public ulong active;\r\n}\r\n\r\n[DataContract]\r\nstruct " +
                    "HeldStateStruct\r\n{\r\n    [DataMember]\r\n    public long timestamp;\r\n    [DataMembe" +
                    "r]\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write(" state;\r\n}\r\n\r\n[DataContract]\r\nsealed class HeldState\r\n{\r\n    [DataMember]\r\n    pu" +
                    "blic long timestamp;\r\n    [DataMember]\r\n    public StateAndActive state;\r\n}\r\n\r\n/" +
                    "/ TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TInput: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TInput));
            this.Write("\r\n// TState: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write("\r\n// TOutput: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TOutput));
            this.Write("\r\n/// <summary>\r\n/// Operator that uses a full-fledged priority queue as ECQ\r\n///" +
                    " </summary>\r\n[DataContract]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(genericParameters));
            this.Write(" : UnaryPipe<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TInput));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TOutput));
            this.Write(">\r\n{\r\n    private readonly Func<PlanNode, IQueryObject, PlanNode> queryPlanGenera" +
                    "tor;\r\n    private readonly IAggregate<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TInput));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TOutput));
            this.Write("> aggregate;\r\n\r\n    [DataContract]\r\n    class EcqState\r\n    {\r\n        [DataMembe" +
                    "r]\r\n        public long timestamp;\r\n        [DataMember]\r\n        public FastDic" +
                    "tionary<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", StateAndActive> states;\r\n    }\r\n\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetMemoryPoolClassName(this.keyType, this.outputType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(genericParameters2));
            this.Write(" pool;\r\n\r\n    private StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TOutput));
            this.Write("> genericOutputbatch;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(keyType, outputType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTOutputGenericParameters));
            this.Write(" batch;\r\n\r\n");
 if (this.useCompiledInitialState) { 
            this.Write("    private readonly Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write("> initialState;\r\n");
 } 
 if (this.useCompiledAccumulate) { 
            this.Write("    private readonly Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write(", long, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TInput));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write("> accumulate;\r\n");
 } 
 if (this.useCompiledDeaccumulate) { 
            this.Write("    private readonly Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write(", long, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TInput));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write("> deaccumulate;\r\n");
 } 
 if (this.useCompiledDifference) { 
            this.Write("    private readonly Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write("> difference;\r\n");
 } 
 if (this.useCompiledComputeResult) { 
            this.Write("    private readonly Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TOutput));
            this.Write("> computeResult;\r\n");
 } 
            this.Write("\r\n    private readonly IEqualityComparerExpression<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("> keyComparer;\r\n    private readonly Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", bool> keyComparerEquals;\r\n    private readonly Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", int> keyComparerGetHashCode;\r\n\r\n    [DataMember]\r\n    private FastDictionary2<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", HeldState> aggregateByKey;\r\n    [DataMember]\r\n    private FastDictionary<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", HeldState> heldAggregates;\r\n    [DataMember]\r\n    private SortedDictionary<long" +
                    ", EcqState> ecq;\r\n    [DataMember]\r\n    private long lastSyncTime = long.MinValu" +
                    "e;\r\n\r\n    private HeldState currentState;\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" currentKey;\r\n    private int currentHash;\r\n\r\n    private Func<FastDictionary<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", StateAndActive>> stateDictGenerator;\r\n\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        Streamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TOutput));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TOutput));
            this.Write("> observer,\r\n        Func<PlanNode, IQueryObject, PlanNode> queryPlanGenerator,\r\n" +
                    "        IAggregate<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TInput));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TOutput));
            this.Write("> aggregate)\r\n        : base(stream, observer)\r\n    {\r\n        this.aggregate = a" +
                    "ggregate;\r\n        this.queryPlanGenerator = queryPlanGenerator;\r\n");
 if (this.useCompiledInitialState) { 
            this.Write("        initialState = aggregate.InitialState().Compile();\r\n");
 } 
 if (this.useCompiledAccumulate) { 
            this.Write("        accumulate = aggregate.Accumulate().Compile();\r\n");
 } 
 if (this.useCompiledDeaccumulate) { 
            this.Write("        deaccumulate = aggregate.Deaccumulate().Compile();\r\n");
 } 
 if (this.useCompiledDifference) { 
            this.Write("        difference = aggregate.Difference().Compile();\r\n");
 } 
 if (this.useCompiledComputeResult) { 
            this.Write("        computeResult = aggregate.ComputeResult().Compile();\r\n");
 } 
            this.Write(@"
        this.keyComparer = stream.Properties.KeyEqualityComparer;
        this.keyComparerEquals = this.keyComparer.GetEqualsExpr().Compile();
        this.keyComparerGetHashCode = this.keyComparer.GetGetHashCodeExpr().Compile();

        this.stateDictGenerator = this.keyComparer.CreateFastDictionaryGenerator<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", StateAndActive>(1, this.keyComparerEquals, this.keyComparerGetHashCode, stream." +
                    "Properties.QueryContainer);\r\n\r\n        this.pool = MemoryManager.GetMemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TOutput));
            this.Write(">() as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetMemoryPoolClassName(this.keyType, this.outputType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(genericParameters2));
            this.Write(";\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(getOutputBatch));
            this.Write("\r\n        this.batch.Allocate();\r\n\r\n        this.aggregateByKey = this.keyCompare" +
                    "r.CreateFastDictionary2Generator<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", HeldState>(1, this.keyComparerEquals, this.keyComparerGetHashCode, stream.Prope" +
                    "rties.QueryContainer).Invoke();\r\n        this.heldAggregates = this.keyComparer." +
                    "CreateFastDictionaryGenerator<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@", HeldState>(1, this.keyComparerEquals, this.keyComparerGetHashCode, stream.Properties.QueryContainer).Invoke();

        this.ecq = new SortedDictionary<long, EcqState>();
    }

    public override void ProduceQueryPlan(PlanNode previous)
        => Observer.ProduceQueryPlan(queryPlanGenerator(previous, this));

    protected override void FlushContents()
    {
        if (this.batch == null || this.batch.Count == 0) return;
        this.batch.Seal();
        this.Observer.OnNext(this.batch);
        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(getOutputBatch));
            this.Write(@"
        this.batch.Allocate();
    }

    protected override void DisposeState() => this.batch.Free();

    public override int CurrentlyBufferedOutputCount => this.batch.Count;

    public override int CurrentlyBufferedInputCount => this.aggregateByKey.Count + this.ecq.Values.Select(o => o.states.Count).Sum();

    public override unsafe void OnNext(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TInput));
            this.Write("> inputBatch)\r\n    {\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TInput));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTInputGenericParameters));
            this.Write(" generatedBatch = inputBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TInput));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTInputGenericParameters));
            this.Write(";\r\n\r\n        this.batch.iter = generatedBatch.iter;\r\n\r\n        var count = genera" +
                    "tedBatch.Count;\r\n\r\n");
 if (this.outputFields.Count() > 1) { 
            this.Write("        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TOutput));
            this.Write(" temporaryOutput;\r\n");
 } 
            this.Write("\r\n        // Create locals that point directly to the arrays within the columns i" +
                    "n the input batch.\r\n");
 foreach (var f in this.inputFields) { 
 if (f.canBeFixed) { 
            this.Write("        fixed (");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.TypeName));
            this.Write("* ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write("_col = generatedBatch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col)\r\n        {\r\n");
 } else { 
            this.Write("        var ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write("_col = generatedBatch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col;\r\n");
 } 
 } 
            this.Write("\r\n        // Create locals that point directly to the arrays within the columns i" +
                    "n the output batch.\r\n");
 foreach (var f in this.outputFields) { 
 if (f.canBeFixed) { 
            this.Write("        fixed (");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.TypeName));
            this.Write("* dest_");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(" = this.batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col)\r\n        {\r\n");
 } else { 
            this.Write("        var dest_");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(" = this.batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col;\r\n");
 } 
 } 
            this.Write("\r\n        fixed (long* col_vsync = generatedBatch.vsync.col)\r\n        fixed (long" +
                    "* col_vother = generatedBatch.vother.col)\r\n        fixed (int* col_hash = genera" +
                    "tedBatch.hash.col)\r\n        fixed (long* col_bv = generatedBatch.bitvector.col)\r" +
                    "\n        for (int i = 0; i < count; i++)\r\n        {\r\n            if ((col_bv[i >" +
                    "> 6] & (1L << (i & 0x3f))) != 0)\r\n            {\r\n                if (col_vother[" +
                    "i] == long.MinValue)\r\n                {\r\n                    // We have found a " +
                    "row that corresponds to punctuation\r\n                    OnPunctuation(col_vsync" +
                    "[i]);\r\n\r\n                    int c = this.batch.Count;\r\n                    this" +
                    ".batch.vsync.col[c] = col_vsync[i];\r\n                    this.batch.vother.col[c" +
                    "] = long.MinValue;\r\n                    this.batch.key.col[c] = default;\r\n      " +
                    "              this.batch[c] = default;\r\n                    this.batch.hash.col[" +
                    "c] = 0;\r\n                    this.batch.bitvector.col[c >> 6] |= 1L << (c & 0x3f" +
                    ");\r\n                    this.batch.Count++;\r\n                    if (this.batch." +
                    "Count == Config.DataBatchSize) FlushContents();\r\n                }\r\n            " +
                    "    continue;\r\n            }\r\n\r\n            var syncTime = col_vsync[i];\r\n      " +
                    "      var key_i = generatedBatch.key.col[i];\r\n\r\n            HeldState heldState;" +
                    "\r\n            bool cachedState = false;\r\n\r\n            // Handle time moving for" +
                    "ward\r\n            if (syncTime > this.lastSyncTime)\r\n            {\r\n            " +
                    "    /* Issue start edges for held aggregates */\r\n                if (currentStat" +
                    "e != null && this.heldAggregates.Count == 1)\r\n                {\r\n               " +
                    "     // there is just one held aggregate, and currentState is set\r\n             " +
                    "       // so currentState has to be the held aggregate\r\n                    cach" +
                    "edState = true;\r\n\r\n                    if (currentState.state.active > 0)\r\n     " +
                    "               {\r\n                        int c = this.batch.Count;\r\n           " +
                    "             this.batch.vsync.col[c] = currentState.timestamp;\r\n                " +
                    "        this.batch.vother.col[c] = StreamEvent.InfinitySyncTime;\r\n              " +
                    "          ");
            this.Write(this.ToStringHelper.ToStringWithCulture(assignToOutput(computeResult("currentState.state.state"))));
            this.Write("\r\n                        this.batch.key.col[c] = currentKey;\r\n                  " +
                    "      this.batch.hash.col[c] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerGetHashCode("currentKey")));
            this.Write(@";
                        this.batch.Count++;
                        if (this.batch.Count == Config.DataBatchSize)
                        {
                            this.batch.iter = generatedBatch.iter;
                            FlushContents();
                            this.batch.iter = generatedBatch.iter;
                        }
                    }
                    else
                    {
                        this.aggregateByKey.Remove(currentKey, currentHash);
                        currentState = null;
                    }
                }
                else
                {
                    int iter1 = FastDictionary<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@", HeldState>.IteratorStart;
                    while (this.heldAggregates.Iterate(ref iter1))
                    {
                        var iter1entry = this.heldAggregates.entries[iter1];

                        if (iter1entry.value.state.active > 0)
                        {
                            int c = this.batch.Count;
                            this.batch.vsync.col[c] = iter1entry.value.timestamp;
                            this.batch.vother.col[c] = StreamEvent.InfinitySyncTime;
                            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(assignToOutput(computeResult("iter1entry.value.state.state"))));
            this.Write("\r\n                            this.batch.key.col[c] = iter1entry.key;\r\n          " +
                    "                  this.batch.hash.col[c] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerGetHashCode("iter1entry.key")));
            this.Write(@";
                            this.batch.Count++;
                            if (this.batch.Count == Config.DataBatchSize) FlushContents();
                        }
                        else
                        {
                            this.aggregateByKey.Remove(iter1entry.key); // ,  (currentKey, currentHash);
                            currentState = null;
                        }
                    }

                    // Time has moved forward, clear the held aggregates
                    this.heldAggregates.Clear();
                    currentState = null;
                }

                /* Process the ECQ up until the new sync time */
                long ve;
                EcqState ecqState;
                while (this.ecq.Count > 0 && this.ecq.TryGetFirst(out ve, out ecqState) && ve <= syncTime)
                {
                    this.ecq.Remove(ve);
                    int iter = FastDictionary<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write(">.IteratorStart;\r\n\r\n                    while (ecqState.states.Iterate(ref iter))" +
                    "\r\n                    {\r\n                        if (currentState == null || !");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerEquals("currentKey", "ecqState.states.entries[iter].key")));
            this.Write(@")
                        {
                            int index;
                            this.aggregateByKey.Lookup(ecqState.states.entries[iter].key, out index);
                            heldState = this.aggregateByKey.entries[index].value;
                        }
                        else
                            heldState = currentState;

                        if (heldState.state.active > 0)
                        {
                            // Issue end edge
                            int c = this.batch.Count;
                            this.batch.vsync.col[c] = ecqState.timestamp;
                            this.batch.vother.col[c] = heldState.timestamp;
                            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(assignToOutput(computeResult("heldState.state.state"))));
            this.Write("\r\n                            this.batch.key.col[c] = ecqState.states.entries[ite" +
                    "r].key;\r\n                            this.batch.hash.col[c] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerGetHashCode("ecqState.states.entries[iter].key")));
            this.Write(@";
                            this.batch.Count++;
                            if (this.batch.Count == Config.DataBatchSize) FlushContents();
                        }

                        // Update aggregate
                        heldState.state.state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(difference("heldState.state.state", "ecqState.states.entries[iter].value.state")));
            this.Write(@";
                        heldState.state.active -= ecqState.states.entries[iter].value.active;

                        if (ecqState.timestamp < syncTime)
                        {
                            if (heldState.state.active > 0)
                            {
                                // Issue start edge
                                int c = this.batch.Count;
                                this.batch.vsync.col[c] = ecqState.timestamp;
                                this.batch.vother.col[c] = StreamEvent.InfinitySyncTime;
                                ");
            this.Write(this.ToStringHelper.ToStringWithCulture(assignToOutput(computeResult("heldState.state.state"))));
            this.Write("\r\n                                this.batch.key.col[c] = ecqState.states.entries" +
                    "[iter].key;\r\n                                this.batch.hash.col[c] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerGetHashCode("ecqState.states.entries[iter].key")));
            this.Write(";\r\n                                this.batch.Count++;\r\n                         " +
                    "       if (this.batch.Count == Config.DataBatchSize) FlushContents();\r\n         " +
                    "                   }\r\n                            else\r\n                        " +
                    "    {\r\n                                // remove from aggregateByKey\r\n          " +
                    "                      this.aggregateByKey.Remove(ecqState.states.entries[iter].k" +
                    "ey);\r\n                                currentState = null;\r\n                    " +
                    "        }\r\n                        }\r\n                        else\r\n            " +
                    "            {\r\n                            if (cachedState)\r\n                   " +
                    "         {\r\n                                cachedState = false;\r\n              " +
                    "                  if (heldState != currentState)\r\n                              " +
                    "  {\r\n                                    this.heldAggregates.Clear();\r\n         " +
                    "                           currentState = null;\r\n                               " +
                    "     int index;\r\n                                    this.heldAggregates.Lookup(" +
                    "ecqState.states.entries[iter].key, out index);\r\n                                " +
                    "    this.heldAggregates.Insert(ref index, ecqState.states.entries[iter].key, hel" +
                    "dState);\r\n                                }\r\n                            }\r\n    " +
                    "                        else\r\n                            {\r\n                   " +
                    "             int index;\r\n                                this.heldAggregates.Loo" +
                    "kup(ecqState.states.entries[iter].key, out index);\r\n                            " +
                    "    this.heldAggregates.Insert(ref index, ecqState.states.entries[iter].key, hel" +
                    "dState);\r\n                            }\r\n                        }\r\n\r\n          " +
                    "              // Update timestamp\r\n                        heldState.timestamp =" +
                    " ecqState.timestamp;\r\n                    }\r\n                }\r\n\r\n              " +
                    "  // Since sync time changed, set this.lastSyncTime\r\n                this.lastSy" +
                    "ncTime = syncTime;\r\n            }\r\n\r\n            if (currentState == null || cur" +
                    "rentHash != col_hash[i] || !");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerEquals("currentKey", "key_i")));
            this.Write(@")
            {
                if (cachedState)
                {
                    cachedState = false;
                    this.heldAggregates.Clear();
                }

                // Need to retrieve the key from the dictionary
                currentKey = key_i;
                currentHash = col_hash[i];

                int index;
                if (!this.heldAggregates.Lookup(currentKey, currentHash, out index))
                {
                    // First time group is active for this time
                    int aggindex;
                    if (!this.aggregateByKey.Lookup(currentKey, currentHash, out aggindex))
                    {
                        // New group. Create new state
                        currentState = new HeldState();
                        currentState.state.state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(initialState));
            this.Write(@";
                        currentState.timestamp = syncTime;
                        this.aggregateByKey.Insert(currentKey, currentState, currentHash);

                        // No output because initial state is empty
                    }
                    else
                    {
                        currentState = this.aggregateByKey.entries[aggindex].value;
                        if (syncTime > currentState.timestamp)
                        {
                            if (currentState.state.active > 0)
                            {
                                // Output end edge
                                int c = this.batch.Count;
                                this.batch.vsync.col[c] = syncTime;
                                this.batch.vother.col[c] = currentState.timestamp;
                                ");
            this.Write(this.ToStringHelper.ToStringWithCulture(assignToOutput(computeResult("currentState.state.state"))));
            this.Write("\r\n                                this.batch.key.col[c] = currentKey;\r\n          " +
                    "                      this.batch.hash.col[c] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerGetHashCode("currentKey")));
            this.Write(@";
                                this.batch.Count++;
                                if (this.batch.Count == Config.DataBatchSize) FlushContents();
                            }
                            currentState.timestamp = syncTime;
                        }
                    }
                    this.heldAggregates.Insert(ref index, currentKey, currentState);
                }
                else
                {
                    // read new currentState from _heldAgg index
                    currentState = this.heldAggregates.entries[index].value;
                }
            }
            else
            {
                if (syncTime > currentState.timestamp)
                {
                    if (currentState.state.active > 0)
                    {
                        // Output end edge
                        int c = this.batch.Count;
                        this.batch.vsync.col[c] = syncTime;
                        this.batch.vother.col[c] = currentState.timestamp;
                        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(assignToOutput(computeResult("currentState.state.state"))));
            this.Write("\r\n                        this.batch.key.col[c] = currentKey;\r\n                  " +
                    "      this.batch.hash.col[c] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerGetHashCode("currentKey")));
            this.Write(@";
                        this.batch.Count++;
                        if (this.batch.Count == Config.DataBatchSize) FlushContents();
                    }
                    currentState.timestamp = syncTime;
                }
            }

            if (col_vsync[i] < col_vother[i]) // insert event
            {
                currentState.state.state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(accumulate("currentState.state.state", "col_vsync[i]" /*, "col_payload[i]"*/)));
            this.Write(@";
                currentState.state.active++;

                // Update ECQ
                if (col_vother[i] < StreamEvent.InfinitySyncTime)
                {
                    EcqState eState;
                    int index;
                    if (this.ecq.Count > 0)
                    {
                        if (!this.ecq.TryGetValue(col_vother[i], out eState))
                        {
                            eState = new EcqState();
                            eState.timestamp = col_vother[i];
                            eState.states = this.stateDictGenerator.Invoke();
                            eState.states.Lookup(key_i, col_hash[i], out index);
                            eState.states.Insert(ref index, key_i, new StateAndActive { state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(initialState));
            this.Write(@" });
                            this.ecq.Add(col_vother[i], eState);
                        }
                        else
                        {
                            if (!eState.states.Lookup(key_i, col_hash[i], out index))
                            {
                                eState.states.Insert(ref index, key_i, new StateAndActive { state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(initialState));
            this.Write(@" });
                            }
                        }
                    }
                    else
                    {
                        eState = new EcqState();
                        eState.timestamp = col_vother[i];
                        eState.states = this.stateDictGenerator.Invoke();
                        eState.states.Lookup(key_i, col_hash[i], out index);
                        eState.states.Insert(ref index, key_i, new StateAndActive { state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(initialState));
            this.Write(" });\r\n                        this.ecq.Add(col_vother[i], eState);\r\n             " +
                    "       }\r\n\r\n                    eState.states.entries[index].value.state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(accumulate("eState.states.entries[index].value.state", "col_vsync[i]")));
            this.Write(";\r\n                    eState.states.entries[index].value.active++;\r\n            " +
                    "    }\r\n            }\r\n            else // is a retraction\r\n            {\r\n      " +
                    "          currentState.state.state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(deaccumulate("currentState.state.state", "col_vsync[i]"/*, "col_payload[i]"*/)));
            this.Write(";\r\n                currentState.state.active--;\r\n            }\r\n        }\r\n\r\n");
 foreach (var f in this.inputFields.Where(fld => fld.canBeFixed)) { 
            this.Write("        }\r\n");
 } 
 foreach (var f in this.outputFields.Where(fld => fld.canBeFixed)) { 
            this.Write("        }\r\n");
 } 
            this.Write("\r\n        generatedBatch.Release();\r\n        generatedBatch.Return();\r\n    }\r\n\r\n\r" +
                    "\n    public void OnPunctuation(long syncTime)\r\n    {\r\n        HeldState heldStat" +
                    "e;\r\n\r\n");
 if (this.outputFields.Count() > 1) { 
            this.Write("        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TOutput));
            this.Write(" temporaryOutput;\r\n");
 foreach (var f in this.outputFields) { 
            this.Write("        var dest_");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(" = this.batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col;\r\n");
 } 
 } 
            this.Write(@"
        // Handle time moving forward
        if (syncTime > this.lastSyncTime)
        {
            /* Issue start edges for held aggregates */
            if (currentState != null && this.heldAggregates.Count == 1)
            {
                // there is just one held aggregate, and currentState is set
                // so currentState has to be the held aggregate
                if (currentState.state.active > 0)
                {
                    int c = this.batch.Count;
                    this.batch.vsync.col[c] = currentState.timestamp;
                    this.batch.vother.col[c] = StreamEvent.InfinitySyncTime;
                    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(assignToOutput(computeResult("currentState.state.state"))));
            this.Write("\r\n                    this.batch.key.col[c] = currentKey;\r\n                    th" +
                    "is.batch.hash.col[c] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerGetHashCode("currentKey")));
            this.Write(@";
                    this.batch.Count++;
                    if (this.batch.Count == Config.DataBatchSize) FlushContents();
                }
                else
                {
                    this.aggregateByKey.Remove(currentKey, currentHash);
                    currentState = null;
                }
            }
            else
            {
                int iter1 = FastDictionary<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@", HeldState>.IteratorStart;
                while (this.heldAggregates.Iterate(ref iter1))
                {
                    var iter1entry = this.heldAggregates.entries[iter1];

                    if (iter1entry.value.state.active > 0)
                    {
                        int c = this.batch.Count;
                        this.batch.vsync.col[c] = iter1entry.value.timestamp;
                        this.batch.vother.col[c] = StreamEvent.InfinitySyncTime;
                        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(assignToOutput(computeResult("iter1entry.value.state.state"))));
            this.Write("\r\n                        this.batch.key.col[c] = iter1entry.key;\r\n              " +
                    "          this.batch.hash.col[c] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerGetHashCode("iter1entry.key")));
            this.Write(@";
                        this.batch.Count++;
                        if (this.batch.Count == Config.DataBatchSize) FlushContents();
                    }
                    else
                    {
                        this.aggregateByKey.Remove(iter1entry.key);
                        currentState = null;
                    }
                }
            }

            // Time has moved forward, clear the held aggregates
            this.heldAggregates.Clear();
            currentState = null;

            /* Process the ECQ up until the new sync time */
            long ve;
            EcqState ecqState;
            while (this.ecq.Count > 0 && this.ecq.TryGetFirst(out ve, out ecqState) && ve <= syncTime)
            {
                this.ecq.Remove(ve);
                int iter = FastDictionary<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TState));
            this.Write(">.IteratorStart;\r\n\r\n                while (ecqState.states.Iterate(ref iter))\r\n  " +
                    "              {\r\n                    if (currentState == null || !");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerEquals("currentKey", "ecqState.states.entries[iter].key")));
            this.Write(@")
                    {
                        int index;
                        this.aggregateByKey.Lookup(ecqState.states.entries[iter].key, out index);
                        heldState = this.aggregateByKey.entries[index].value;
                    }
                    else
                        heldState = currentState;

                    if (heldState.state.active > 0)
                    {
                        // Issue end edge
                        int c = this.batch.Count;
                        this.batch.vsync.col[c] = ecqState.timestamp;
                        this.batch.vother.col[c] = heldState.timestamp;
                        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(assignToOutput(computeResult("heldState.state.state"))));
            this.Write("\r\n                        this.batch.key.col[c] = ecqState.states.entries[iter].k" +
                    "ey;\r\n                        this.batch.hash.col[c] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerGetHashCode("ecqState.states.entries[iter].key")));
            this.Write(";\r\n                        this.batch.Count++;\r\n                        if (this." +
                    "batch.Count == Config.DataBatchSize) FlushContents();\r\n                    }\r\n\r\n" +
                    "                    // Update aggregate\r\n                    heldState.state.sta" +
                    "te = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(difference("heldState.state.state", "ecqState.states.entries[iter].value.state")));
            this.Write(@";
                    heldState.state.active -= ecqState.states.entries[iter].value.active;

                    if (ecqState.timestamp < syncTime)
                    {
                        if (heldState.state.active > 0)
                        {
                            // Issue start edge
                            int c = this.batch.Count;
                            this.batch.vsync.col[c] = ecqState.timestamp;
                            this.batch.vother.col[c] = StreamEvent.InfinitySyncTime;
                            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(assignToOutput(computeResult("heldState.state.state"))));
            this.Write("\r\n                            this.batch.key.col[c] = ecqState.states.entries[ite" +
                    "r].key;\r\n                            this.batch.hash.col[c] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(inlinedKeyComparerGetHashCode("ecqState.states.entries[iter].key")));
            this.Write(@";
                            this.batch.Count++;
                            if (this.batch.Count == Config.DataBatchSize) FlushContents();
                        }
                        else
                        {
                            // remove from aggregateByKey
                            this.aggregateByKey.Remove(ecqState.states.entries[iter].key);
                            currentState = null;
                        }
                    }
                    else
                    {
                        int index;
                        this.heldAggregates.Lookup(ecqState.states.entries[iter].key, out index);
                        this.heldAggregates.Insert(ref index, ecqState.states.entries[iter].key, heldState);
                    }

                    // Update timestamp
                    heldState.timestamp = ecqState.timestamp;
                }
            }

            // Since sync time changed, set this.lastSyncTime
            this.lastSyncTime = syncTime;
        }
    }

    protected override void UpdatePointers()
    {
        int iter1 = FastDictionary<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", HeldState>.IteratorStart;\r\n        while (this.heldAggregates.Iterate(ref iter1" +
                    "))\r\n        {\r\n            int iter2;\r\n            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@" key = this.heldAggregates.entries[iter1].key;
            bool found = this.aggregateByKey.Lookup(key, out iter2);
            if (!found) throw new InvalidOperationException();
            this.heldAggregates.entries[iter1].value = this.aggregateByKey.entries[iter2].value;
        }
    }
}
");
            return this.GenerationEnvironment.ToString();
        }
    }
}
