// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class AfaMultiEventListTemplate : AfaTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;

// CompiledGroupedAfaPipe_MultiEventList
// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TPayload: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("\r\n// TRegister: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write("\r\n// TAccumulator: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TAccumulator));
            this.Write("\r\n\r\n");
  var grouped = !this.keyType.Equals(typeof(Microsoft.StreamProcessing.Empty));
    Func<EdgeInfo,string> arcTypeName = (EdgeInfo edge) => {
      if (edge is MultiEdgeInfo) return "MultiElement";
      return edge.Type == EdgeInfo.EdgeType.Single ? "SingleElement" : "ListElement";
    };
    var CurrentListName = grouped ? "currentList" : "currentTimestampEventList";
    var CurrentList = CurrentListName + (grouped ? ".payloads" : ".Items");
    var CurrentListCount = string.Format("{0}{1}.Count", CurrentListName, (grouped ? ".payloads" : string.Empty));
    Func<EdgeInfo,string> secondArgToFenceAndTransfer = (EdgeInfo edge) =>
          {
            if (edge.Type == EdgeInfo.EdgeType.Multi)
              return "acc";
            else if (edge.Type == EdgeInfo.EdgeType.Single)
              return  (this.payloadHasNoFields ? "listElement.payload" : "listElement");
            else // list
              return "payloadList";
          };
    Func<string, string> EventRefWrapper = (string s) => this.payloadHasNoFields ? s + ".payload" : s; 
            this.Write("\r\n");
 if (grouped) { 
            this.Write("[DataContract]\r\ninternal struct GeneratedSavedEventRef\r\n{\r\n    [DataMember]\r\n    " +
                    "public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key;\r\n    [DataMember]\r\n    public AList<GeneratedEventRef> payloads;\r\n}\r\n");
 } 
            this.Write("\r\n[DataContract]\r\ninternal struct GeneratedEventRef\r\n{\r\n");
 foreach (var f in this.sourceFields) { 
            this.Write("    [DataMember]\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(";\r\n");
 } 
            this.Write("\r\n    public void Populate(");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceBatchTypeName));
            this.Write(" batch, int index)\r\n    {\r\n");
 foreach (var f in this.sourceFields) { 
            this.Write("        this.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
            this.Write("    }\r\n}\r\n\r\n[DataContract]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(" : CompiledAfaPipeBase<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TAccumulator));
            this.Write(">\r\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    [DataMember]\r\n");
 if (grouped) { 
            this.Write("\r\n    private FastMap<GroupedActiveState<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">> activeStates;\r\n");
 } else { 
            this.Write("\r\n    private FastLinkedList<GroupedActiveState<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">> activeStates;\r\n");
 }
   if (grouped) { 
            this.Write("\r\n    private FastMap<GroupedActiveState<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">>.FindTraverser activeFindTraverser;\r\n");
 } 
            this.Write("\r\n    [DataMember]\r\n");
 if (grouped) { 
            this.Write("\r\n    private FastMap<GeneratedSavedEventRef> currentTimestampEventList;\r\n");
 } else { 
            this.Write("\r\n    private AList<GeneratedEventRef> currentTimestampEventList;\r\n");
 } 
            this.Write("\r\n");
 if (grouped) { 
            this.Write("\r\n    private FastMap<GeneratedSavedEventRef>.FindTraverser eventListTraverser;\r\n" +
                    "    private FastMap<GeneratedSavedEventRef>.VisibleTraverser allEventListTravers" +
                    "er;\r\n");
 } else { 
            this.Write("\r\n    private FastLinkedList<GroupedActiveState<Microsoft.StreamProcessing.Empty," +
                    " ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">>.ListTraverser activeStatesTraverser;\r\n");
 } 
            this.Write("\r\n    [DataMember]\r\n    private long lastSyncTime;\r\n\r\n    private long[] dest_vsy" +
                    "nc;\r\n    private long[] dest_vother;\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("[] destkey;\r\n    private int[] dest_hash;\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(resultBatchTypeName));
            this.Write(" resultBatch;\r\n\r\n    ");
 foreach (var f in this.sourceFields) { 
            this.Write("\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ColumnPointerFieldDeclaration(f, "sourceBatch")));
            this.Write("\r\n    ");
 } 
            this.Write("\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write("> observer,\r\n        object afa,\r\n        long MaxDuration)\r\n        : base(strea" +
                    "m, observer, afa, MaxDuration)\r\n    {\r\n");
 if (grouped) { 
            this.Write("\r\n        activeStates = new FastMap<GroupedActiveState<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">>();\r\n");
 } else { 
            this.Write("\r\n        activeStates = new FastLinkedList<GroupedActiveState<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">>();\r\n");
 } 
            this.Write("\r\n");
 if (grouped) { 
            this.Write("\r\n        activeFindTraverser = new FastMap<GroupedActiveState<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">>.FindTraverser(activeStates);\r\n");
 } 
            this.Write("\r\n");
 if (grouped) { 
            this.Write("\r\n        currentTimestampEventList = new FastMap<GeneratedSavedEventRef>();\r\n");
 } else { 
            this.Write("\r\n        currentTimestampEventList = new AList<GeneratedEventRef>();\r\n");
 } 
            this.Write("\r\n");
 if (grouped) { 
            this.Write("\r\n        eventListTraverser = new FastMap<GeneratedSavedEventRef>.FindTraverser(" +
                    "currentTimestampEventList);\r\n        allEventListTraverser = new FastMap<Generat" +
                    "edSavedEventRef>.VisibleTraverser(currentTimestampEventList);\r\n");
 } else { 
            this.Write("\r\n        currentTimestampEventList = new AList<GeneratedEventRef>();\r\n        ac" +
                    "tiveStatesTraverser = new FastLinkedList<GroupedActiveState<Microsoft.StreamProc" +
                    "essing.Empty, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">>.ListTraverser(activeStates);\r\n");
 } 
            this.Write(@"        lastSyncTime = -1;
    }

    public override int CurrentlyBufferedInputCount => activeStates.Count;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ProcessCurrentTimestamp()
    {
        if (currentTimestampEventList.Count == 0) return;
        List<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> payloadList = null;\r\n");
 if (grouped) { 
            this.Write("\r\n        int el_index, el_hash;\r\n");
 } 
            this.Write("\r\n        long synctime = lastSyncTime;\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TAccumulator));
            this.Write(" acc;\r\n\r\n");
 if (grouped) { 
            this.Write("\r\n        allEventListTraverser.currIndex = 0;\r\n\r\n        while (allEventListTrav" +
                    "erser.Next(out el_index, out el_hash)) {\r\n            var currentList = currentT" +
                    "imestampEventList.Values[el_index];\r\n");
 } 
            this.Write("\r\n            /* (1) Process currently active states */\r\n            bool ended =" +
                    " true;\r\n");
 if (grouped) { 
            this.Write("            if (activeFindTraverser.Find(el_hash))\r\n");
 } 
            this.Write("            {\r\n                int index, orig_index;\r\n\r\n");
 if (grouped) { 
            this.Write("\r\n                while (activeFindTraverser.Next(out index))\r\n");
 } else { 
            this.Write("            if (activeStatesTraverser.Find())\r\n            {\r\n                whi" +
                    "le (activeStatesTraverser.Next(out index))\r\n");
 } 
            this.Write("                {\r\n                    orig_index = index;\r\n\r\n                   " +
                    " var state = activeStates.Values[index];\r\n");
 if (grouped) { 
            this.Write("\r\n                    if (!(");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyEqualityComparer("state.key", "currentList.key")));
            this.Write(")) continue;\r\n");
 } 
            this.Write("\r\n                    if (state.PatternStartTimestamp + MaxDuration > synctime)\r\n" +
                    "                    {\r\n                        switch (state.state) {\r\n         " +
                    "                   ");
 foreach (var sourceNodeInfo in this.edgeInfos) { 
            this.Write("\r\n                            case ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceNodeInfo.Item1));
            this.Write(" :\r\n                            {\r\n                                ");
 foreach (var arcInfo in sourceNodeInfo.Item2) {
                                       var multiArcInfo = arcInfo as MultiEdgeInfo;
                                 
            this.Write("\r\n                                // type of arc: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcTypeName(arcInfo)));
            this.Write("\r\n                                ");
 if (multiArcInfo != null) { 
            this.Write("\r\n                                acc = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(multiArcInfo.Initialize("synctime", "state.register")));
            this.Write(";\r\n                                for (int i = 0; i < ");
            this.Write(this.ToStringHelper.ToStringWithCulture((grouped ? "currentList.payloads.Count" : "currentTimestampEventList.Count")));
            this.Write("; i++)\r\n                                {\r\n                                    va" +
                    "r listElement = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(CurrentList));
            this.Write("[i];\r\n                                    acc = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(multiArcInfo.Accumulate("synctime", EventRefWrapper("listElement"), "state.register", "acc")));
            this.Write(";\r\n                                    ");
 if (multiArcInfo.SkipToEnd != null) { 
            this.Write("\r\n                                    if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(multiArcInfo.SkipToEnd("synctime", "payload", "acc")));
            this.Write(") break;\r\n                                    ");
 } 
            this.Write("\r\n                                }\r\n                                ");
 } 
            this.Write("\r\n                                ");
 if (multiArcInfo == null) { 
            this.Write("\r\n                                ");
 if (arcInfo.Type == EdgeInfo.EdgeType.List) { 
            this.Write("\r\n                                if (payloadList == null)\r\n                     " +
                    "           {\r\n                                    payloadList = new List<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(CurrentListName));
            this.Write(".Count);\r\n                                    for (int i = 0; i < ");
            this.Write(this.ToStringHelper.ToStringWithCulture(CurrentListName));
            this.Write(".Count; i++)\r\n                                    {\r\n                            " +
                    "            var listElement = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(CurrentList));
            this.Write("[i];\r\n");
                                      CreateNewInstance("listElement"); 
            this.Write("                                        payloadList.Add(payload);\r\n              " +
                    "                      }\r\n                                }\r\n                    " +
                    "            ");
 } 
            this.Write("\r\n                                ");
 if (arcInfo.Type == EdgeInfo.EdgeType.Single) { 
            this.Write("\r\n                                var listElement = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(CurrentList));
            this.Write("[0];\r\n                                ");
 } 
            this.Write("                                ");
 } 
            this.Write("\r\n                                if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcInfo.Fence("synctime", secondArgToFenceAndTransfer(arcInfo), "state.register")));
            this.Write(")\r\n                                {\r\n                                    // assi" +
                    "gn new register value\r\n                                    ");
 UpdateRegisterValue(arcInfo, "state.register", "synctime", secondArgToFenceAndTransfer(arcInfo), "state.register"); 
            this.Write("\r\n                                    // target nodes\r\n                          " +
                    "          ");
 foreach (var ns in arcInfo.EpsilonReachableNodes) { 
            this.Write("\r\n                                    // target state: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ns));
            this.Write(" (");
            this.Write(this.ToStringHelper.ToStringWithCulture(isFinal[ns] ? "final" : "not final"));
            this.Write(")\r\n                                    ");
 var keyArg = (grouped ? "currentList.key" : "Microsoft.StreamProcessing.Empty.Default"); 
            this.Write("                                    ");
 var hashArg = (grouped ? "el_hash" : "0"); 
            this.Write("\r\n                                    ");
 IfFinalStateProduceOutput(36, ns, string.Empty, "synctime", "state.PatternStartTimestamp", keyArg, hashArg); 
            this.Write("                                    ");
 if (hasOutgoingArcs[ns]) { 
            this.Write("\r\n                                    {\r\n                                        " +
                    "// target node has outgoing edges\r\n                                        if (i" +
                    "ndex == -1) index = activeStates.Insert(");
            this.Write(this.ToStringHelper.ToStringWithCulture(grouped ? "el_hash" : string.Empty));
            this.Write(");\r\n");
 if (grouped) { 
            this.Write("\r\n                                        activeStates.Values[index].key = curren" +
                    "tList.key;\r\n");
 } 
            this.Write("                                        activeStates.Values[index].state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ns));
            this.Write(@";
                                        activeStates.Values[index].register = newReg;
                                        activeStates.Values[index].PatternStartTimestamp = state.PatternStartTimestamp;

                                        index = -1;

                                        ended = false;
                                    }

                                    ");
 } else { 
            this.Write("\r\n                                    // target node does not have any outgoing e" +
                    "dges\r\n                                    ");
 } 
            this.Write("\r\n                                    //if (IsDeterministic) break; // We are gua" +
                    "ranteed to have only one successful transition\r\n                                " +
                    "    ");
 } 
            this.Write("\r\n                                }\r\n                                ");
 if (multiArcInfo != null) { 
            this.Write("\r\n                                ");
            this.Write(this.ToStringHelper.ToStringWithCulture(multiArcInfo.Dispose("acc")));
            this.Write(";\r\n                                ");
 } 
            this.Write("                            ");
 } 
            this.Write("\r\n                                break;\r\n                            }\r\n        " +
                    "                ");
 } 
            this.Write("\r\n                        } // end switch\r\n                    } // end if the cu" +
                    "rrent state\'s timestamp plus MaxDuration is greater than the current synctime\r\n " +
                    "                   if (index == orig_index)\r\n");
 if (grouped) { 
            this.Write("\r\n                        activeFindTraverser.Remove();\r\n");
 } else { 
            this.Write("\r\n                        activeStatesTraverser.Remove();\r\n");
 } 
            this.Write("                    if (IsDeterministic) break; // We are guaranteed to have only" +
                    " one active state\r\n                }\r\n");
 if (!grouped) { 
            this.Write("             }\r\n");
 } 
            this.Write("            }\r\n\r\n            /* (2) Start new activations from the start state(s)" +
                    " */\r\n            ");
 if (!this.AllowOverlappingInstances) { 
            this.Write("\r\n            ");
 if (grouped) { 
            this.Write("\r\n            if (!ended) continue;\r\n            ");
 } else { 
            this.Write("\r\n            if (ended) {\r\n            ");
 } 
            this.Write("            ");
 } 
            this.Write("\r\n            ");
 foreach (var sourceNodeInfo in this.startEdgeInfos) { 
            this.Write("\r\n                // start node: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceNodeInfo.Item1));
            this.Write("\r\n                ");
 foreach (var arcInfo in sourceNodeInfo.Item2) {
                       var multiArcInfo = arcInfo as MultiEdgeInfo;
                
            this.Write("\r\n                // type of arc: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcTypeName(arcInfo)));
            this.Write("\r\n                ");
 if (multiArcInfo != null) { 
            this.Write("\r\n                    acc = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(multiArcInfo.Initialize("synctime", "defaultRegister")));
            this.Write(";\r\n                    for (int i = 0; i < ");
            this.Write(this.ToStringHelper.ToStringWithCulture((grouped ? "currentList.payloads.Count" : "currentTimestampEventList.Count")));
            this.Write("; i++)\r\n                    {\r\n                        var listElement = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(CurrentList));
            this.Write("[i];\r\n                        acc = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(multiArcInfo.Accumulate("synctime", EventRefWrapper("listElement"), "defaltRegister", "acc")));
            this.Write(";\r\n                        ");
 if (multiArcInfo.SkipToEnd != null) { 
            this.Write("\r\n                        if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(multiArcInfo.SkipToEnd("synctime", "payload", "acc")));
            this.Write(") break;\r\n                        ");
 } 
            this.Write("\r\n                    }\r\n                    ");
 } 
            this.Write("\r\n                    ");
 if (multiArcInfo == null) { 
            this.Write("\r\n                    ");
 if (arcInfo.Type == EdgeInfo.EdgeType.List) { 
            this.Write("\r\n                    if (payloadList == null)\r\n                    {\r\n          " +
                    "              payloadList = new List<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">(");
            this.Write(this.ToStringHelper.ToStringWithCulture(CurrentListName));
            this.Write(".Count);\r\n                        for (int i = 0; i < ");
            this.Write(this.ToStringHelper.ToStringWithCulture(CurrentListName));
            this.Write(".Count; i++)\r\n                        {\r\n                            var listElem" +
                    "ent = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(CurrentList));
            this.Write("[i];\r\n");
                          CreateNewInstance("listElement"); 
            this.Write("                            payloadList.Add(payload);\r\n                        }\r" +
                    "\n                    }\r\n                    ");
 } 
            this.Write("\r\n                    ");
 if (arcInfo.Type == EdgeInfo.EdgeType.Single) { 
            this.Write("\r\n                    if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(CurrentListCount));
            this.Write(" == 1) {\r\n                    var listElement = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(CurrentList));
            this.Write("[0];\r\n                    ");
 } 
            this.Write("                    ");
 } 
            this.Write("\r\n                    if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcInfo.Fence("synctime", EventRefWrapper("listElement"), "defaultRegister")));
            this.Write(")\r\n                    {\r\n                        // assign new register value\r\n " +
                    "                       ");
 UpdateRegisterValue(arcInfo, "defaultRegister", "synctime", "#dummy#", "defaultRegister"); 
            this.Write("\r\n                        // target nodes\r\n                        ");
 foreach (var ns in arcInfo.EpsilonReachableNodes) { 
            this.Write("\r\n                        // target state: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ns));
            this.Write(" (");
            this.Write(this.ToStringHelper.ToStringWithCulture(isFinal[ns] ? "final" : "not final"));
            this.Write(")\r\n                        ");
 IfFinalStateProduceOutput(24, ns, string.Empty, "synctime", "synctime", "currentList.key", (grouped ? "el_hash" : "0")); 
            this.Write("                        ");
 if (hasOutgoingArcs[ns]) { 
            this.Write("\r\n                    {\r\n                        int index = activeStates.Insert(" +
                    "");
            this.Write(this.ToStringHelper.ToStringWithCulture(grouped ? "el_hash" : string.Empty));
            this.Write(");\r\n");
 if (grouped) { 
            this.Write("\r\n                        activeStates.Values[index].key = currentList.key;\r\n");
 } 
            this.Write("\r\n                        activeStates.Values[index].state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ns));
            this.Write(";\r\n                        activeStates.Values[index].register = newReg;\r\n       " +
                    "                 activeStates.Values[index].PatternStartTimestamp = synctime;\r\n " +
                    "                   }\r\n                        ");
 } 
            this.Write("\r\n                        //if (IsDeterministic) break; // We are guaranteed to h" +
                    "ave only one successful transition\r\n                        ");
 } 
            this.Write("\r\n                    }\r\n                    ");
 if (multiArcInfo != null) { 
            this.Write("\r\n                    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(multiArcInfo.Dispose("acc")));
            this.Write(";\r\n                    ");
 } else { 
            this.Write("\r\n                    ");
 if (arcInfo.Type == EdgeInfo.EdgeType.Single) { 
            this.Write("\r\n                    } // end if currentList.payloads.Count == 1\r\n              " +
                    "      ");
 } 
            this.Write("                    ");
 } 
            this.Write("                 ");
 } 
            this.Write("            ");
 } 
            this.Write("\r\n            ");
 if (!this.AllowOverlappingInstances && !grouped) { 
            this.Write("\r\n            }\r\n            ");
 } 
            this.Write("\r\n");
 if (!grouped) { 
            this.Write("\r\n                //if (IsDeterministic) break; // We are guaranteed to have only" +
                    " one start state\r\n");
 } 
            this.Write("\r\n");
 if (grouped) { 
            this.Write("\r\n            currentList.payloads = null; // Let GC handle this\r\n");
 } 
            this.Write("\r\n");
 if (grouped) { 
            this.Write("\r\n        }\r\n");
 } 
            this.Write("\r\n");
 if (grouped) { 
            this.Write("\r\n        currentTimestampEventList.Clear();\r\n");
 } else { 
            this.Write("\r\n        currentTimestampEventList.Count = 0;\r\n");
 } 
            this.Write("    }\r\n\r\n    public override unsafe void OnNext(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(@"> batch)
    {
        var count = batch.Count;

        this.dest_vsync = this.batch.vsync.col;
        this.dest_vother = this.batch.vother.col;
        this.destkey = this.batch.key.col;
        this.dest_hash = this.batch.hash.col;

        var srckey = batch.key.col;

        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceBatchTypeName));
            this.Write(" sourceBatch = batch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceBatchTypeName));
            this.Write(";\r\n\r\n        ");
 foreach (var f in this.sourceFields) { 
            this.Write("\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ColumnPointerFieldAssignment(f, "sourceBatch")));
            this.Write("\r\n        ");
 } 
            this.Write("\r\n        GeneratedEventRef evref = default;\r\n");
 if (grouped) { 
            this.Write("\r\n        GeneratedSavedEventRef sevref = default;\r\n");
 } 
            this.Write(@"
        fixed (long* src_bv = batch.bitvector.col, src_vsync = batch.vsync.col, src_vother = batch.vother.col)
        {
            fixed (int* src_hash = batch.hash.col)
            {
                for (int i = 0; i < count; i++)
                {
                    if ((src_bv[i >> 6] & (1L << (i & 0x3f))) == 0 || src_vother[i] < 0)
                    {
                        long synctime = src_vsync[i];

                        int index, hash;

                        if (synctime > lastSyncTime) // move time forward
                        {
                            ProcessCurrentTimestamp();
                            lastSyncTime = synctime;
                        }

                        if (src_vother[i] < 0)
                        {
                            OnPunctuation(synctime);
                            continue;
                        }
");
 if (grouped) { 
            this.Write("\r\n                        bool done = false;\r\n\r\n                        if (event" +
                    "ListTraverser.Find(src_hash[i]))\r\n                        {\r\n                   " +
                    "         while (eventListTraverser.Next(out index))\r\n                           " +
                    " {\r\n                                var state = currentTimestampEventList.Values" +
                    "[index];\r\n\r\n                                if (keyEqualityComparer(state.key, s" +
                    "rckey[i]))\r\n                                {\r\n                                 " +
                    "   if (state.payloads.Count == state.payloads.Items.Length)\r\n                   " +
                    "                 {\r\n                                        state.payloads.Ensur" +
                    "eCapacity(state.payloads.Count + 1);\r\n                                    }\r\n   " +
                    "                                 state.payloads.Items[state.payloads.Count].Popu" +
                    "late(batch, i);\r\n                                    state.payloads.Count++;\r\n\r\n" +
                    "                                    done = true;\r\n                              " +
                    "      break;\r\n                                }\r\n                            }\r\n" +
                    "                        }\r\n\r\n                        if (!done)\r\n               " +
                    "         {\r\n                            index = currentTimestampEventList.Insert" +
                    "(src_hash[i]);\r\n                            sevref.payloads = new Microsoft.Stre" +
                    "amProcessing.Internal.Collections.AList<GeneratedEventRef>(10);\r\n\r\n             " +
                    "               sevref.payloads.Items[0].Populate(sourceBatch, i);\r\n             " +
                    "               sevref.payloads.Count++;\r\n\r\n                            sevref.ke" +
                    "y = srckey[i];\r\n                            currentTimestampEventList.Values[ind" +
                    "ex] = sevref;\r\n                        }\r\n");
 } else { 
            this.Write(@"
                        if (currentTimestampEventList.Count == currentTimestampEventList.Items.Length)
                        {
                            currentTimestampEventList.EnsureCapacity(currentTimestampEventList.Count + 1);
                        }

                        currentTimestampEventList.Items[currentTimestampEventList.Count].Populate(sourceBatch, i);
                        currentTimestampEventList.Count++;
");
 } 
            this.Write("\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        bat" +
                    "ch.Free();\r\n    }\r\n}\r\n\r\n[DataContract]\r\npublic class AList<T>\r\n{\r\n    private co" +
                    "nst int _defaultCapacity = 4;\r\n    private static readonly T[] _emptyArray;\r\n   " +
                    " [DataMember]\r\n    public T[] Items;\r\n    [DataMember]\r\n    public int Count;\r\n\r" +
                    "\n    static AList()\r\n    {\r\n        _emptyArray = new T[0];\r\n    }\r\n\r\n    public" +
                    " AList()\r\n    {\r\n        Items = _emptyArray;\r\n    }\r\n\r\n    public AList(int cap" +
                    "acity)\r\n    {\r\n        if (capacity < 0)\r\n        {\r\n            throw new Argum" +
                    "entOutOfRangeException(\"capacity\", \"NeedNonNegNum\");\r\n        }\r\n        if (cap" +
                    "acity == 0)\r\n        {\r\n            Items = _emptyArray;\r\n        }\r\n        els" +
                    "e\r\n        {\r\n            Items = new T[capacity];\r\n        }\r\n    }\r\n\r\n    [Met" +
                    "hodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public void Add(T item)\r\n   " +
                    " {\r\n        if (Count == Items.Length)\r\n        {\r\n            EnsureCapacity(Co" +
                    "unt + 1);\r\n        }\r\n        Items[Count++] = item;\r\n    }\r\n\r\n    [MethodImpl(M" +
                    "ethodImplOptions.AggressiveInlining)]\r\n    public void Clear()\r\n    {\r\n        i" +
                    "f (Count > 0)\r\n        {\r\n            Array.Clear(Items, 0, Count);\r\n           " +
                    " Count = 0;\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInl" +
                    "ining)]\r\n    public void Reset()\r\n    {\r\n        Count = 0;\r\n    }\r\n\r\n    [Metho" +
                    "dImpl(MethodImplOptions.AggressiveInlining)]\r\n    public void EnsureCapacity(int" +
                    " min)\r\n    {\r\n        if (Items.Length < min)\r\n        {\r\n            int num = " +
                    "(Items.Length == 0) ? 4 : (Items.Length * 2);\r\n            if (num > 0x7fefffff)" +
                    "\r\n            {\r\n                num = 0x7fefffff;\r\n            }\r\n            i" +
                    "f (num < min)\r\n            {\r\n                num = min;\r\n            }\r\n       " +
                    "     Capacity = num;\r\n        }\r\n    }\r\n\r\n    public void Insert(int index, T it" +
                    "em)\r\n    {\r\n        if (index > Count)\r\n        {\r\n            throw new Argumen" +
                    "tOutOfRangeException(\"index\");\r\n        }\r\n        if (Count == Items.Length)\r\n " +
                    "       {\r\n            EnsureCapacity(Count + 1);\r\n        }\r\n        if (index <" +
                    " Count)\r\n        {\r\n            Array.Copy(Items, index, Items, index + 1, Count" +
                    " - index);\r\n        }\r\n        Items[index] = item;\r\n        Count++;\r\n    }\r\n\r\n" +
                    "    public int Capacity\r\n    {\r\n        get\r\n        {\r\n            return Items" +
                    ".Length;\r\n        }\r\n        set\r\n        {\r\n            if (value < Count)\r\n   " +
                    "         {\r\n            }\r\n            if (value != Items.Length)\r\n            {" +
                    "\r\n                if (value > 0)\r\n                {\r\n                    T[] des" +
                    "tinationArray = new T[value];\r\n                    if (Count > 0)\r\n             " +
                    "       {\r\n                        Array.Copy(Items, 0, destinationArray, 0, Coun" +
                    "t);\r\n                    }\r\n                    Items = destinationArray;\r\n     " +
                    "           }\r\n                else\r\n                {\r\n                    Items" +
                    " = _emptyArray;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    publi" +
                    "c T this[int index]\r\n    {\r\n        get\r\n        {\r\n            if (index >= Cou" +
                    "nt)\r\n            {\r\n                throw new ArgumentOutOfRangeException();\r\n  " +
                    "          }\r\n            return Items[index];\r\n        }\r\n        set\r\n        {" +
                    "\r\n            if (index >= Count)\r\n            {\r\n                throw new Argu" +
                    "mentOutOfRangeException();\r\n            }\r\n            Items[index] = value;\r\n  " +
                    "      }\r\n    }\r\n}\r\n\r\n");
            return this.GenerationEnvironment.ToString();
        }

private void CreateNewInstance(string s) {

 if (payloadIsAnon) {
  var fieldArgs = String.Join(",", this.sourceFields.Select(f => $"{s}.{f.Name}"));

this.Write("                                        var payload = (");

this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));

this.Write(")Activator.CreateInstance(typeof(");

this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));

this.Write(") ");

this.Write(this.ToStringHelper.ToStringWithCulture(fieldArgs));

this.Write(" );\r\n");

 } else if (this.payloadHasNoFields) { 
this.Write("                                        var payload = ");

this.Write(this.ToStringHelper.ToStringWithCulture(s));

this.Write(".payload;\r\n");

 } else { 
this.Write("                                        var payload = new ");

this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));

this.Write("();\r\n");

 foreach (var f in this.sourceFields) { 
this.Write("                                        payload.");

this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));

this.Write(" = ");

this.Write(this.ToStringHelper.ToStringWithCulture(s));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(";\r\n");

 } 
 } 
 } 
    }
}
