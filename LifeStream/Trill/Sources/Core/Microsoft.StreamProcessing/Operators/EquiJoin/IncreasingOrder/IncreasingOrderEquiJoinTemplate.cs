// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class IncreasingOrderEquiJoinTemplate : CommonBinaryTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write("// *********************************************************************\r\n// Copy" +
                    "right (c) Microsoft Corporation.  All rights reserved.\r\n// Licensed under the MI" +
                    "T License\r\n// ******************************************************************" +
                    "***\r\n");

  var leftBatchTypeName = string.Format("{0}{1}",
    Transformer.GetBatchClassName(keyType, leftType),
    !String.IsNullOrWhiteSpace(TKeyTLeftGenericParameters) ? "<" + TKeyTLeftGenericParameters + ">" : string.Empty);
  var rightBatchTypeName = string.Format("{0}{1}",
    Transformer.GetBatchClassName(keyType, rightType),
    !String.IsNullOrWhiteSpace(TKeyTRightGenericParameters) ? "<" + TKeyTRightGenericParameters + ">" : string.Empty);

            this.Write(@"
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;

// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TLeft: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("\r\n// TRight: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("\r\n// TResult: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("\r\n\r\n[DataContract]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(genericParameters));
            this.Write(" : BinaryPipe<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(">\r\n{\r\n    private const int DefaultCapacity = 64;\r\n    private readonly MemoryPoo" +
                    "l<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("> pool;\r\n    private readonly Func<PlanNode, PlanNode, IBinaryObserver, BinaryPla" +
                    "nNode> queryPlanGenerator;\r\n\r\n    /* Comparer for ordering of join key - should " +
                    "eventually be a stream property */\r\n\r\n    private StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("> genericOutputBatch;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(keyType, resultType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTResultGenericParameters));
            this.Write(" output;\r\n\r\n    [DataMember]\r\n    private long nextLeftTime = long.MinValue;\r\n   " +
                    " [DataMember]\r\n    private long nextRightTime = long.MinValue;\r\n    [DataMember]" +
                    "\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" nextLeftKey;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" nextRightKey;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" currentRightKey;\r\n    [DataMember]\r\n    private List<ActiveEventRight> currentRi" +
                    "ghtList;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" currentLeftKey;\r\n    [DataMember]\r\n    private List<ActiveEventLeft> currentLeft" +
                    "List;\r\n\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(@"> observer,
        Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> queryPlanGenerator)
        : base(stream, observer)
    {
        currentLeftList = new List<ActiveEventLeft>();
        currentRightList = new List<ActiveEventRight>();

        pool = MemoryManager.GetMemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(">(true /*stream.Properties.IsColumnar*/);\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(getOutputBatch));
            this.Write(@"
        output.Allocate();
        this.queryPlanGenerator = queryPlanGenerator;
    }

    protected override void FlushContents()
    {
        if (output.Count == 0) return;
        output.Seal();
        this.Observer.OnNext(output);
        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(getOutputBatch));
            this.Write(@"
        output.Allocate();
    }

    public override int CurrentlyBufferedOutputCount => output.Count;
    public override int CurrentlyBufferedLeftInputCount => base.CurrentlyBufferedLeftInputCount + currentLeftList.Count;
    public override int CurrentlyBufferedRightInputCount => base.CurrentlyBufferedRightInputCount + currentRightList.Count;

    protected override void ProduceBinaryQueryPlan(PlanNode left, PlanNode right)
    {
        Observer.ProduceQueryPlan(queryPlanGenerator(left, right, this));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void DisposeState() => output.Free();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessBothBatches(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> leftBatch, StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("> rightBatch, out bool leftBatchDone, out bool rightBatchDone, out bool leftBatch" +
                    "Free, out bool rightBatchFree)\r\n    {\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(" generatedLeftBatch = null;\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchTypeName));
            this.Write(" generatedRightBatch = null;\r\n\r\n        leftBatchFree = rightBatchFree = true;\r\n " +
                    "       generatedLeftBatch = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(@") leftBatch;
        if (!GoToVisibleRow(leftBatch))
        {
            leftBatchDone = true;
            rightBatchDone = false;
            return;
        }

        UpdateNextLeftTime(leftBatch.vsync.col[leftBatch.iter]);
        nextLeftKey = leftBatch.key.col[leftBatch.iter];

        generatedRightBatch = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchTypeName));
            this.Write(@") rightBatch;
        if (!GoToVisibleRow(rightBatch))
        {
            leftBatchDone = false;
            rightBatchDone = true;
            return;
        }

        UpdateNextRightTime(rightBatch.vsync.col[rightBatch.iter]);
        nextRightKey = rightBatch.key.col[rightBatch.iter];

        while (true)
        {
            bool leftPunctuation = leftBatch.vother.col[leftBatch.iter] == StreamEvent.PunctuationOtherTime;
            bool rightPunctuation = rightBatch.vother.col[rightBatch.iter] == StreamEvent.PunctuationOtherTime;

            int compare = (leftPunctuation || rightPunctuation) ? 0 : ");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("nextLeftKey", "nextRightKey")));
            this.Write(@";

            if (compare == 0)
            {
                if (nextLeftTime <= nextRightTime)
                {
                    // process left
                    if (leftPunctuation)
                    {
                        AddPunctuationToBatch(nextLeftTime);
                    }
                    else
                    {
                        #region ProcessLeftStartEdge
                        /*
                        ProcessLeftStartEdge(
                            nextLeftTime,
                            ref leftBatch.key.col[leftBatch.iter],
                            leftBatch[leftBatch.iter],
                            leftBatch.hash.col[leftBatch.iter], compare);
                        */
                        {

                            if (currentRightList.Count > 0)
                            {
                                int compare2 = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("nextLeftKey", "currentRightKey")));
            this.Write(@";

                                Contract.Assert(compare2 >= 0, ""Unexpected comparison in sort-ordered join"");

                                if (compare2 == 0)
                                {
                                    // perform the join
                                    for (int i = 0; i < currentRightList.Count; i++)
                                    {
                                        var t = currentRightList[i];
                                        OutputStartEdge(nextLeftTime > t.Timestamp ? nextLeftTime : t.Timestamp, ref nextLeftKey, generatedLeftBatch, leftBatch.iter, t, leftBatch.hash.col[leftBatch.iter]);
                                    }
                                }
                                else
                                {
                                    // clear the right array
                                    currentRightList.Clear();
                                }
                            }

                            if (compare >= 0)
                            {
                                // update the left array
                                if ((currentLeftList.Count != 0) && (");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("nextLeftKey", "currentLeftKey")));
            this.Write(" != 0))\r\n                                {\r\n                                    C" +
                    "ontract.Assert(");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("nextLeftKey", "currentLeftKey")));
            this.Write(" > 0);\r\n                                    currentLeftList.Clear();\r\n           " +
                    "                     }\r\n                                currentLeftKey = nextLef" +
                    "tKey;\r\n                                var leftAE = new ActiveEventLeft();\r\n    " +
                    "                            leftAE.Populate(ref nextLeftTime, generatedLeftBatch" +
                    ", leftBatch.iter);\r\n                                currentLeftList.Add(leftAE);" +
                    "\r\n                            }\r\n                        }\r\n                    " +
                    "    #endregion\r\n                    }\r\n\r\n                    leftBatch.iter++;\r\n" +
                    "\r\n                    if (!GoToVisibleRow(leftBatch))\r\n                    {\r\n  " +
                    "                      leftBatchDone = true;\r\n                        rightBatchD" +
                    "one = false;\r\n                        return;\r\n                    }\r\n\r\n        " +
                    "            nextLeftTime = leftBatch.vsync.col[leftBatch.iter];\r\n               " +
                    "     nextLeftKey = leftBatch.key.col[leftBatch.iter];\r\n                }\r\n      " +
                    "          else\r\n                {\r\n                    // process right\r\n       " +
                    "             if (rightPunctuation)\r\n                    {\r\n                     " +
                    "   AddPunctuationToBatch(nextRightTime);\r\n                    }\r\n               " +
                    "     else\r\n                    {\r\n                        #region ProcessRightSt" +
                    "artEdge\r\n                            /* Inlined version of:\r\n                   " +
                    "     ProcessRightStartEdge(\r\n                            nextRightTime,\r\n       " +
                    "                     ref rightBatch.key.col[rightBatch.iter],\r\n                 " +
                    "           rightBatch[rightBatch.iter],\r\n                            rightBatch." +
                    "hash.col[rightBatch.iter], compare);\r\n                        */\r\n\r\n            " +
                    "            if (currentLeftList.Count > 0)\r\n                        {\r\n         " +
                    "                   int compare2 = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("nextRightKey", "currentLeftKey")));
            this.Write(@";

                            Contract.Assert(compare2 >= 0, ""Unexpected comparison in sort-ordered join"");

                            if (compare2 == 0)
                            {
                                // perform the join
                                for (int i = 0; i < currentLeftList.Count; i++)
                                {
                                    var t = currentLeftList[i];
                                    #region OutputStartEdge
                                    /* OutputStartEdge(nextRightTime > t.Timestamp ? nextRightTime : t.Timestamp,
                                        ref nextRightKey, ref t.Payload, ref rightP, rightBatch.hash.col[rightBatch.iter]); */
                                    int index = output.Count++;
                                    output.vsync.col[index] = nextRightTime > t.Timestamp ? nextRightTime : t.Timestamp;
                                    output.vother.col[index] = StreamEvent.InfinitySyncTime;
                                    output.key.col[index] = nextRightKey;
                                ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.leftMessageRepresentation.noFields
                                        ? this.rightBatchSelector("t.payload", "generatedRightBatch", "rightBatch.iter")
                                        : this.rightBatchSelector("t", "generatedRightBatch", "rightBatch.iter")));
            this.Write(@"
                                    output.hash.col[index] = rightBatch.hash.col[rightBatch.iter];

                                    if (output.Count == Config.DataBatchSize)
                                    {
                                        output.Seal();
                                        this.Observer.OnNext(output);
                                        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(getOutputBatch));
            this.Write(@"
                                        output.Allocate();
                                    }

                                    #endregion
                                }
                            }
                            else
                            {
                                // clear the left array
                                currentLeftList.Clear();
                            }
                        }


                        if (compare <= 0)
                        {
                            // update the right array
                            if ((currentRightList.Count != 0) && (");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("rightBatch.key.col[rightBatch.iter]", "currentRightKey")));
            this.Write(" != 0))\r\n                            {\r\n                                Contract." +
                    "Assert(");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("rightBatch.key.col[rightBatch.iter]", "currentRightKey")));
            this.Write(" > 0);\r\n                                currentRightList.Clear();\r\n              " +
                    "              }\r\n                            currentRightKey = rightBatch.key.co" +
                    "l[rightBatch.iter];\r\n                            var rightAE = new ActiveEventRi" +
                    "ght();\r\n                            rightAE.Populate(ref nextRightTime, generate" +
                    "dRightBatch, rightBatch.iter);\r\n                            currentRightList.Add" +
                    "(rightAE);\r\n                        }\r\n                        #endregion\r\n     " +
                    "               }\r\n\r\n                    rightBatch.iter++;\r\n\r\n                  " +
                    "  #region GoToVisibleRow\r\n                    /* Inlined version of:\r\n          " +
                    "              if (!GoToVisibleRow(rightBatch))\r\n                        {\r\n     " +
                    "                       leftBatchDone = false;\r\n                            right" +
                    "BatchDone = true;\r\n                            return;\r\n                        " +
                    "}\r\n                    */\r\n                    while (rightBatch.iter < rightBat" +
                    "ch.Count &&\r\n                        (rightBatch.bitvector.col[rightBatch.iter >" +
                    "> 6] & (1L << (rightBatch.iter & 0x3f))) != 0 &&\r\n                        rightB" +
                    "atch.vother.col[rightBatch.iter] >= 0)\r\n                    {\r\n                 " +
                    "       rightBatch.iter++;\r\n                    }\r\n                    if (rightB" +
                    "atch.iter == rightBatch.Count)\r\n                    {\r\n                        l" +
                    "eftBatchDone = false;\r\n                        rightBatchDone = true;\r\n         " +
                    "               return;\r\n                    }\r\n                    #endregion\r\n\r" +
                    "\n                    nextRightTime = rightBatch.vsync.col[rightBatch.iter];\r\n   " +
                    "                 nextRightKey = rightBatch.key.col[rightBatch.iter];\r\n          " +
                    "      }\r\n            }\r\n            else if (compare < 0)\r\n            {\r\n      " +
                    "          // process left\r\n                #region ProcessLeftStartEdge\r\n       " +
                    "         /* Inlined version of:\r\n                    ProcessLeftStartEdge(\r\n    " +
                    "                    nextLeftTime,\r\n                        ref leftBatch.key.col" +
                    "[leftBatch.iter],\r\n                        leftBatch[leftBatch.iter],\r\n         " +
                    "               leftBatch.hash.col[leftBatch.iter], compare);\r\n                */" +
                    "\r\n                {\r\n\r\n\r\n                    if (currentRightList.Count > 0)\r\n  " +
                    "                  {\r\n                        int compare2 = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("nextLeftKey", "currentRightKey")));
            this.Write(";\r\n\r\n                        Contract.Assert(compare2 >= 0, \"Unexpected compariso" +
                    "n in sort-ordered join\");\r\n\r\n                        if (compare2 == 0)\r\n       " +
                    "                 {\r\n                            // perform the join\r\n           " +
                    "                 for (int i = 0; i < currentRightList.Count; i++)\r\n             " +
                    "               {\r\n                                var t = currentRightList[i];\r\n" +
                    "                                OutputStartEdge(nextLeftTime > t.Timestamp ? nex" +
                    "tLeftTime : t.Timestamp, ref nextLeftKey, generatedLeftBatch, leftBatch.iter, t," +
                    " leftBatch.hash.col[leftBatch.iter]);\r\n                            }\r\n          " +
                    "              }\r\n                        else\r\n                        {\r\n      " +
                    "                      // clear the right array\r\n                            curr" +
                    "entRightList.Clear();\r\n                        }\r\n                    }\r\n       " +
                    "         }\r\n                #endregion\r\n\r\n                leftBatch.iter++;\r\n\r\n " +
                    "               #region GoToVisibleRow\r\n                /* Inlined version of:\r\n " +
                    "                   if (!GoToVisibleRow(leftBatch))\r\n                    {\r\n     " +
                    "                   leftBatchDone = true;\r\n                        rightBatchDone" +
                    " = false;\r\n                        return;\r\n                    }\r\n             " +
                    "   */\r\n                while (leftBatch.iter < leftBatch.Count &&\r\n             " +
                    "       (leftBatch.bitvector.col[leftBatch.iter >> 6] & (1L << (leftBatch.iter & " +
                    "0x3f))) != 0 &&\r\n                    leftBatch.vother.col[leftBatch.iter] >= 0)\r" +
                    "\n                {\r\n                    leftBatch.iter++;\r\n                }\r\n  " +
                    "              if (leftBatch.iter == leftBatch.Count)\r\n                {\r\n       " +
                    "             leftBatchDone = true;\r\n                    rightBatchDone = false;\r" +
                    "\n                    return;\r\n                }\r\n                #endregion\r\n\r\n\r" +
                    "\n                #region UpdateNextLeftTime\r\n                nextLeftTime = left" +
                    "Batch.vsync.col[leftBatch.iter];\r\n                #endregion\r\n\r\n                " +
                    "nextLeftKey = leftBatch.key.col[leftBatch.iter];\r\n\r\n            }\r\n            e" +
                    "lse // hot path if larger right side of join matches very few things on the left" +
                    " side\r\n            {\r\n                // process right\r\n                #region " +
                    "ProcessRightStartEdge\r\n                /* Inlined version of:\r\n                P" +
                    "rocessRightStartEdge(\r\n                    nextRightTime,\r\n                    r" +
                    "ef rightBatch.key.col[rightBatch.iter],\r\n                    rightBatch.payload." +
                    "col[rightBatch.iter],\r\n                    rightBatch.hash.col[rightBatch.iter]," +
                    " compare);\r\n                */\r\n                if (currentLeftList.Count > 0)\r\n" +
                    "                {\r\n                    int compare2 = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("nextRightKey", "currentLeftKey")));
            this.Write(@";

                    Contract.Assert(compare2 >= 0, ""Unexpected comparison in sort-ordered join"");

                    if (compare2 == 0)
                    {
                        // perform the join
                        for (int i = 0; i < currentLeftList.Count; i++)
                        {
                            var t = currentLeftList[i];
                            #region OutputStartEdge
                            /* OutputStartEdge(nextRightTime > t.Timestamp ? nextRightTime : t.Timestamp,
                                    ref nextRightKey, ref t.Payload, ref rightP, rightBatch.hash.col[rightBatch.iter]); */
                            int index = output.Count++;
                            output.vsync.col[index] = nextRightTime > t.Timestamp ? nextRightTime : t.Timestamp;
                            output.vother.col[index] = StreamEvent.InfinitySyncTime;
                            output.key.col[index] = nextRightKey;
                            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.leftMessageRepresentation.noFields
                                    ? this.rightBatchSelector("t.payload", "generatedRightBatch", "rightBatch.iter")
                                    : this.rightBatchSelector("t", "generatedRightBatch", "rightBatch.iter")));
            this.Write(@"
                            output.hash.col[index] = rightBatch.hash.col[rightBatch.iter];

                            if (output.Count == Config.DataBatchSize)
                            {
                                output.Seal();
                                this.Observer.OnNext(output);
                                ");
            this.Write(this.ToStringHelper.ToStringWithCulture(getOutputBatch));
            this.Write(@"
                                output.Allocate();
                            }

                            #endregion
                        }
                    }
                    else
                    {
                        // clear the left array
                        currentLeftList.Clear();
                    }
                }

                /*
                    if (compare <= 0)
                    {
                        // update the right array
                        if ((currentRightList.Count != 0) && (");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("rightBatch.key.col[rightBatch.iter]", "currentRightKey")));
            this.Write(" != 0))\r\n                        {\r\n                            Contract.Assert(");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("rightBatch.key.col[rightBatch.iter]", "currentRightKey")));
            this.Write(" > 0);\r\n                            currentRightList.Clear();\r\n                  " +
                    "      }\r\n                        currentRightKey = rightBatch.key.col[rightBatch" +
                    ".iter];\r\n                        ActiveEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("> rightAE = new ActiveEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write(">();\r\n                        rightAE.Populate(ref nextRightTime, ref rightBatch." +
                    "payload.col[rightBatch.iter]);\r\n                        currentRightList.Add(rig" +
                    "htAE);\r\n                    }\r\n                */\r\n                #endregion\r\n\r" +
                    "\n                rightBatch.iter++;\r\n\r\n                #region GoToVisibleRow\r\n " +
                    "               /* Inlined version of:\r\n                    if (!GoToVisibleRow(r" +
                    "ightBatch))\r\n                    {\r\n                        leftBatchDone = fals" +
                    "e;\r\n                        rightBatchDone = true;\r\n                        retu" +
                    "rn;\r\n                    }\r\n                */\r\n                while (rightBatc" +
                    "h.iter < rightBatch.Count &&\r\n                    (rightBatch.bitvector.col[righ" +
                    "tBatch.iter >> 6] & (1L << (rightBatch.iter & 0x3f))) != 0 &&\r\n                 " +
                    "   rightBatch.vother.col[rightBatch.iter] >= 0)\r\n                {\r\n            " +
                    "        rightBatch.iter++;\r\n                }\r\n                if (rightBatch.it" +
                    "er == rightBatch.Count)\r\n                {\r\n                    leftBatchDone = " +
                    "false;\r\n                    rightBatchDone = true;\r\n                    return;\r" +
                    "\n                }\r\n                #endregion\r\n\r\n                #region Update" +
                    "NextRightTime\r\n                /* Inlined version of: UpdateNextRightTime(rightB" +
                    "atch.vsync.col[rightBatch.iter]); */\r\n                nextRightTime = rightBatch" +
                    ".vsync.col[rightBatch.iter];\r\n                #endregion\r\n\r\n                next" +
                    "RightKey = rightBatch.key.col[rightBatch.iter];\r\n            }\r\n        }\r\n    }" +
                    "\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    protected overri" +
                    "de void ProcessLeftBatch(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(@"> batch, out bool isBatchDone, out bool isBatchFree)
    {
        isBatchFree = true;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                return;
            }

            UpdateNextLeftTime(batch.vsync.col[batch.iter]);

            if (batch.vother.col[batch.iter] == StreamEvent.PunctuationOtherTime)
            {
                if (nextLeftTime > nextRightTime)
                {
                    isBatchDone = false;
                    return;
                }

                AddPunctuationToBatch(batch.vsync.col[batch.iter]);

                batch.iter++;
                continue;
            }

            nextLeftKey = batch.key.col[batch.iter];


            int compare = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("nextLeftKey", "nextRightKey")));
            this.Write(";\r\n            if ((compare == 0) && (nextLeftTime <= nextRightTime))\r\n          " +
                    "  {\r\n                ProcessLeftStartEdge(\r\n                    nextLeftTime,\r\n " +
                    "                   ref batch.key.col[batch.iter],\r\n                    (");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(@")batch, batch.iter,
                    batch.hash.col[batch.iter], compare);

                batch.iter++;
            }
            else
            {
                isBatchDone = false;
                return;
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessRightBatch(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write(@"> batch, out bool isBatchDone, out bool isBatchFree)
    {
        isBatchFree = true;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                return;
            }

            UpdateNextRightTime(batch.vsync.col[batch.iter]);

            if (batch.vother.col[batch.iter] == StreamEvent.PunctuationOtherTime)
            {
                if (nextRightTime > nextLeftTime)
                {
                    isBatchDone = false;
                    return;
                }

                AddPunctuationToBatch(batch.vsync.col[batch.iter]);

                batch.iter++;
                continue;
            }

            nextRightKey = batch.key.col[batch.iter];

            int compare = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("nextLeftKey", "nextRightKey")));
            this.Write(";\r\n            if ((compare == 0) && (nextRightTime <= nextLeftTime))\r\n          " +
                    "  {\r\n                ProcessRightStartEdge(\r\n                    nextRightTime,\r" +
                    "\n                    ref batch.key.col[batch.iter],\r\n                    (");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchTypeName));
            this.Write(@")batch,batch.iter,
                    batch.hash.col[batch.iter], compare);

                batch.iter++;
            }
            else
            {
                isBatchDone = false;
                return;
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool GoToVisibleRow<TPayload>(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@", TPayload> batch)
    {
        while (batch.iter < batch.Count && (batch.bitvector.col[batch.iter >> 6] & (1L << (batch.iter & 0x3f))) != 0 && batch.vother.col[batch.iter] >= 0)
        {
            batch.iter++;
        }

        if (batch.iter == batch.Count)
        {
            return false;
        }

        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdateNextLeftTime(long time)
    {
        nextLeftTime = time;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdateNextRightTime(long time)
    {
        nextRightTime = time;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ProcessLeftStartEdge(long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(" leftBatch, int leftIndex, int hash, int nextLeftRightCompareResult)\r\n    {\r\n    " +
                    "    if (currentRightList.Count > 0)\r\n        {\r\n            int compare = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("key", "currentRightKey")));
            this.Write(@";

            Contract.Assert(compare >= 0, ""Unexpected comparison in sort-ordered join"");

            if (compare == 0)
            {
                // perform the join
                for (int i = 0; i < currentRightList.Count; i++)
                {
                    var t = currentRightList[i];
                    OutputStartEdge(start > t.Timestamp ? start : t.Timestamp, ref key, leftBatch, leftIndex, t, hash);
                }
            }
            else
            {
                // clear the right array
                currentRightList.Clear();
            }
        }

        if (nextLeftRightCompareResult >= 0)
        {
            // update the left array
            if ((currentLeftList.Count != 0) && (");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("key", "currentLeftKey")));
            this.Write(" != 0))\r\n            {\r\n                Contract.Assert(");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("key", "currentLeftKey")));
            this.Write(@" > 0);
                currentLeftList.Clear();
            }
            currentLeftKey = key;
            var leftAE = new ActiveEventLeft();
            leftAE.Populate(ref start, leftBatch, leftIndex);
            currentLeftList.Add(leftAE);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ProcessRightStartEdge(long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchTypeName));
            this.Write(" rightBatch, int rightIndex, int hash, int nextLeftRightCompareResult)\r\n    {\r\n  " +
                    "      if (currentLeftList.Count > 0)\r\n        {\r\n            int compare = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("key", "currentLeftKey")));
            this.Write(@";

            Contract.Assert(compare >= 0, ""Unexpected comparison in sort-ordered join"");

            if (compare == 0)
            {
                // perform the join
                for (int i = 0; i < currentLeftList.Count; i++)
                {
                    var t = currentLeftList[i];
                    OutputStartEdge(start > t.Timestamp ? start : t.Timestamp, ref key, t, rightBatch, rightIndex, hash);
                }
            }
            else
            {
                // clear the left array
                currentLeftList.Clear();
            }
        }

        if (nextLeftRightCompareResult <= 0)
        {
            // update the right array
            if ((currentRightList.Count != 0) && (");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("key", "currentRightKey")));
            this.Write(" != 0))\r\n            {\r\n                Contract.Assert(");
            this.Write(this.ToStringHelper.ToStringWithCulture(joinKeyOrderComparer("key", "currentRightKey")));
            this.Write(@" > 0);
                currentRightList.Clear();
            }
            currentRightKey = key;
            var rightAE = new ActiveEventRight();
            rightAE.Populate(ref start, rightBatch, rightIndex);
            currentRightList.Add(rightAE);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddPunctuationToBatch(long start)
    {
        if (start > lastCTI)
        {
            lastCTI = start;

            int index = output.Count++;
            output.vsync.col[index] = start;
            output.vother.col[index] = StreamEvent.PunctuationOtherTime;
            output.key.col[index] = default;
            output[index] = default;
            output.hash.col[index] = 0;
            output.bitvector.col[index >> 6] |= (1L << (index & 0x3f));

            if (output.Count == Config.DataBatchSize) FlushContents();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void OutputStartEdge(long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ActiveEventLeft leftEvent, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchTypeName));
            this.Write(" rightBatch, int rightIndex, int hash)\r\n    {\r\n        int index = output.Count++" +
                    ";\r\n        output.vsync.col[index] = start;\r\n        output.vother.col[index] = " +
                    "StreamEvent.InfinitySyncTime;\r\n        output.key.col[index] = key;\r\n");
 if (this.leftMessageRepresentation.noFields) { 
            this.Write("        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchSelector("leftEvent.payload", "rightBatch", "rightIndex")));
            this.Write("\r\n");
 } else { 
            this.Write("        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchSelector("leftEvent", "rightBatch", "rightIndex")));
            this.Write("\r\n");
 } 
            this.Write("        output.hash.col[index] = hash;\r\n\r\n        if (output.Count == Config.Data" +
                    "BatchSize) FlushContents();\r\n    }\r\n    [MethodImpl(MethodImplOptions.Aggressive" +
                    "Inlining)]\r\n    private void OutputStartEdge(long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(@" leftBatch, int leftIndex, ActiveEventRight rightEvent, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = StreamEvent.InfinitySyncTime;
        output.key.col[index] = key;
");
 if (this.rightMessageRepresentation.noFields) { 
            this.Write("        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchSelector("leftBatch", "leftIndex", "rightEvent.payload")));
            this.Write("\r\n");
 } else { 
            this.Write("        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchSelector("leftBatch", "leftIndex", "rightEvent")));
            this.Write("\r\n");
 } 
            this.Write("        output.hash.col[index] = hash;\r\n\r\n        if (output.Count == Config.Data" +
                    "BatchSize) FlushContents();\r\n    }\r\n\r\n    [DataContract]\r\n    private struct Act" +
                    "iveEventLeft\r\n    {\r\n        [DataMember]\r\n        public long Timestamp;\r\n\r\n   " +
                    "     ");
 foreach (var f in this.leftFields) { 
            this.Write("\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n        ");
 } 
            this.Write("\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public void" +
                    " Populate(ref long timestamp, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchTypeName));
            this.Write(" batch, int index)\r\n        {\r\n            Timestamp = timestamp;\r\n            ");
 foreach (var f in this.leftFields) { 
            this.Write("\r\n            this.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n            ");
 } 
            this.Write(@"
        }

        public override string ToString()
        {
            return ""[Timestamp='"" + Timestamp + ""', Payload='"" + ""']"";
        }
    }

    [DataContract]
    private struct ActiveEventRight
    {
        [DataMember]
        public long Timestamp;

        ");
 foreach (var f in this.rightFields) { 
            this.Write("\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n        ");
 } 
            this.Write("\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public void" +
                    " Populate(ref long timestamp, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchTypeName));
            this.Write(" batch, int index)\r\n        {\r\n            Timestamp = timestamp;\r\n            ");
 foreach (var f in this.rightFields) { 
            this.Write("\r\n            this.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n            ");
 } 
            this.Write("\r\n        }\r\n\r\n        public override string ToString()\r\n        {\r\n            " +
                    "return \"[Timestamp=\'\" + Timestamp + \"\', Payload=\'\" + \"\']\";\r\n        }\r\n    }\r\n}");
            return this.GenerationEnvironment.ToString();
        }
    }
}
