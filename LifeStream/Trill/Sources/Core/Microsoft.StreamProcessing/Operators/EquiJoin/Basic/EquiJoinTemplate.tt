<#@ template language="C#" inherits="CommonBinaryTemplate" visibility="internal" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;
[assembly: IgnoresAccessChecksTo("Microsoft.StreamProcessing")]

// TKey: <#= TKey #>
// TLeft: <#= TLeft #>
// TRight: <#= TRight #>
// TResult: <#= TResult #>

[DataContract]
[KnownType(typeof(EndPointHeap))]
[KnownType(typeof(EndPointQueue))]
internal sealed class <#= className #><#= genericParameters #> : BinaryPipe<<#= TKey #>, <#= TLeft #>, <#= TRight #>, <#= TResult #>>
{
    //private readonly Func<<#= TLeft #>, <#= TRight #>, <#= TResult #>> selector;
    private readonly MemoryPool<<#= TKey #>, <#= TResult #>> pool;
    private readonly Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> queryPlanGenerator;

    [SchemaSerialization]
    private readonly Expression<Func<<#= TKey #>, <#= TKey #>, bool>> keyComparer;
    private readonly Func<<#= TKey #>, <#= TKey #>, bool> keyComparerEquals;

    private StreamMessage<<#= TKey #>, <#= TResult #>> genericOutputBatch;
    [DataMember]
    private <#= BatchGeneratedFrom_TKey_TResult #><#= TKeyTResultGenericParameters #> output;
    [DataMember]
    private FastMap<ActiveIntervalLeft> leftIntervalMap = new FastMap<ActiveIntervalLeft>();
    [DataMember]
    private FastMap<ActiveEdgeLeft> leftEdgeMap = new FastMap<ActiveEdgeLeft>();
    [DataMember]
    private IEndPointOrderer endPointHeap;
    [DataMember]
    private FastMap<ActiveIntervalRight> rightIntervalMap = new FastMap<ActiveIntervalRight>();
    [DataMember]
    private FastMap<ActiveEdgeRight> rightEdgeMap = new FastMap<ActiveEdgeRight>();
    [DataMember]
    private long nextLeftTime = long.MinValue;
    [DataMember]
    private bool isLeftComplete;
    [DataMember]
    private long nextRightTime = long.MinValue;
    [DataMember]
    private bool isRightComplete;
    [DataMember]
    private long currTime = long.MinValue;

    <#= staticCtor #>

    [Obsolete("Used only by serialization. Do not call directly.")]
    public <#= className #>() { }

    public <#= className #>(
        IStreamable<<#= TKey #>, <#= TResult #>> stream,
        IStreamObserver<<#= TKey #>, <#= TResult #>> observer,
        Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> queryPlanGenerator)
        : base(stream, observer)
    {
        this.queryPlanGenerator = queryPlanGenerator;

        this.keyComparer = stream.Properties.KeyEqualityComparer.GetEqualsExpr();
        this.keyComparerEquals = this.keyComparer.Compile();

        this.endPointHeap = new <#= this.endPointHeap #>();

        this.pool = MemoryManager.GetMemoryPool<<#= TKey #>, <#= TResult #>>(true /*stream.Properties.IsColumnar*/);
        GetOutputBatch();
    }

    public override int CurrentlyBufferedOutputCount => output.Count;
    public override int CurrentlyBufferedLeftInputCount => base.CurrentlyBufferedLeftInputCount + leftEdgeMap.Count + leftIntervalMap.Count;
    public override int CurrentlyBufferedRightInputCount => base.CurrentlyBufferedRightInputCount + rightEdgeMap.Count + rightIntervalMap.Count;

    protected override void ProduceBinaryQueryPlan(PlanNode left, PlanNode right)
    {
        Observer.ProduceQueryPlan(queryPlanGenerator(left, right, this));
    }

    protected override void DisposeState() => this.output.Free();

    private void GetOutputBatch()
    {
        pool.Get(out genericOutputBatch);
        genericOutputBatch.Allocate();
        output = (<#= BatchGeneratedFrom_TKey_TResult #><#= TKeyTResultGenericParameters #>)genericOutputBatch;
<# foreach (var f in this.resultFields.Where(fld => fld.OptimizeString())) {  #>

        output.<#= f.Name #>.Initialize();
<# } #>
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessBothBatches(StreamMessage<<#= TKey #>, <#= TLeft #>> genericLeftBatch, StreamMessage<<#= TKey #>, <#= TRight #>> genericRightBatch, out bool leftBatchDone, out bool rightBatchDone, out bool leftBatchFree, out bool rightBatchFree)
    {
        <#= LeftBatchType #> leftBatch = genericLeftBatch as <#= LeftBatchType #>;
        <#= RightBatchType #> rightBatch = genericRightBatch as <#= RightBatchType #>;
        leftBatchFree = rightBatchFree = true;

        if (!GoToVisibleRow(genericLeftBatch))
        {
            leftBatchDone = true;
            rightBatchDone = false;
            return;
        }

        UpdateNextLeftTime(genericLeftBatch.vsync.col[genericLeftBatch.iter]);

        if (!GoToVisibleRow(genericRightBatch))
        {
            leftBatchDone = false;
            rightBatchDone = true;
            return;
        }

        UpdateNextRightTime(genericRightBatch.vsync.col[genericRightBatch.iter]);

        while (true)
        {
            if (nextLeftTime <= nextRightTime)
            {
                UpdateTime(nextLeftTime);
                ProcessLeftEvent(
                    nextLeftTime,
                    leftBatch.vother.col[leftBatch.iter],
                    ref leftBatch.key.col[leftBatch.iter],
                    leftBatch,
                    leftBatch.iter,
                    leftBatch.hash.col[leftBatch.iter]);

                leftBatch.iter++;

                if (!GoToVisibleRow(leftBatch))
                {
                    leftBatchDone = true;
                    rightBatchDone = false;
                    break;
                }

                UpdateNextLeftTime(leftBatch.vsync.col[leftBatch.iter]);
            }
            else
            {
                UpdateTime(nextRightTime);
                ProcessRightEvent(
                    nextRightTime,
                    rightBatch.vother.col[rightBatch.iter],
                    ref rightBatch.key.col[rightBatch.iter],
                    rightBatch,
                    rightBatch.iter,
                    rightBatch.hash.col[rightBatch.iter]);

                rightBatch.iter++;

                if (!GoToVisibleRow(rightBatch))
                {
                    leftBatchDone = false;
                    rightBatchDone = true;
                    break;
                }

                UpdateNextRightTime(rightBatch.vsync.col[rightBatch.iter]);
            }
        }

        return;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessLeftBatch(StreamMessage<<#= TKey #>, <#= TLeft #>> genericLeftBatch, out bool isBatchDone, out bool isBatchFree)
    {
        isBatchFree = true;
        var batch = (<#= LeftBatchType #>) genericLeftBatch;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                break;
            }

            UpdateNextLeftTime(batch.vsync.col[batch.iter]);

            if (nextLeftTime > nextRightTime)
            {
                isBatchDone = false;
                break;
            }

            UpdateTime(nextLeftTime);

            ProcessLeftEvent(
                nextLeftTime,
                batch.vother.col[batch.iter],
                ref batch.key.col[batch.iter],
                batch,
                batch.iter,
                batch.hash.col[batch.iter]);

            batch.iter++;
        }

        return;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessRightBatch(StreamMessage<<#= TKey #>, <#= TRight #>> genericRightBatch, out bool isBatchDone, out bool isBatchFree)
    {
        isBatchFree = true;
        var batch = (<#= RightBatchType #>) genericRightBatch;

        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                break;
            }

            UpdateNextRightTime(batch.vsync.col[batch.iter]);

            if (nextRightTime > nextLeftTime)
            {
                isBatchDone = false;
                break;
            }

            UpdateTime(nextRightTime);

            ProcessRightEvent(
                nextRightTime,
                batch.vother.col[batch.iter],
                ref batch.key.col[batch.iter],
                batch,
                batch.iter,
                batch.hash.col[batch.iter]);

            batch.iter++;
        }

        return;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool GoToVisibleRow<TPayload>(StreamMessage<<#= TKey #>, TPayload> batch)
    {
        while (batch.iter < batch.Count && (batch.bitvector.col[batch.iter >> 6] & (1L << (batch.iter & 0x3f))) != 0 && batch.vother.col[batch.iter] >= 0)
        {
            batch.iter++;
        }

        if (batch.iter == batch.Count)
        {
            return false;
        }

        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdateTime(long time)
    {
        if (time != currTime)
        {
            LeaveTime();
            currTime = time;
            ReachTime();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdateNextLeftTime(long time)
    {
        nextLeftTime = time;
        if (nextLeftTime == StreamEvent.InfinitySyncTime && leftEdgeMap.IsInvisibleEmpty && leftIntervalMap.IsInvisibleEmpty && leftIntervalMap.IsEmpty)
        {
            isLeftComplete = true;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdateNextRightTime(long time)
    {
        nextRightTime = time;
        if (nextRightTime == StreamEvent.InfinitySyncTime && rightEdgeMap.IsInvisibleEmpty && rightIntervalMap.IsInvisibleEmpty && rightIntervalMap.IsEmpty)
        {
            isRightComplete = true;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ProcessLeftEvent(long start, long end, ref <#= TKey #> key, <#= LeftBatchType #> leftBatch, int leftIndex, int hash)
    {
        if (start < end)
        {
            // Row is a start edge or interval.
            bool processable = nextRightTime > start || rightEdgeMap.IsEmpty;
            if (end == StreamEvent.InfinitySyncTime)
            {
                // Row is a start edge.
                if (processable)
                {
                    if (!isRightComplete)
                    {
                        int index = leftEdgeMap.Insert(hash);
                        leftEdgeMap.Values[index].Populate(start, ref key, leftBatch, leftIndex);
                    }

                    CreateOutputForLeftStartEdge(start, ref key, leftBatch, leftIndex, hash);
                }
                else
                {
                    int index = leftEdgeMap.InsertInvisible(hash);
                    leftEdgeMap.Values[index].Populate(start, ref key, leftBatch, leftIndex);
                }
            }
            else
            {
                // Row is an interval.
                if (processable)
                {
                    int index = leftIntervalMap.Insert(hash);
                    leftIntervalMap.Values[index].Populate(start, end, ref key, leftBatch, leftIndex);
                    CreateOutputForLeftStartInterval(start, end, ref key, leftBatch, leftIndex, hash);
                    endPointHeap.Insert(end, index);
                }
                else
                {
                    int index = leftIntervalMap.InsertInvisible(hash);
                    leftIntervalMap.Values[index].Populate(start, end, ref key, leftBatch, leftIndex);
                }
            }
        }
        else if (end == StreamEvent.PunctuationOtherTime)
        {
            AddPunctuationToBatch(start);
        }
        else
        {
            // Row is an end edge.

            // Remove from leftEdgeMap.
            if (!isRightComplete)
            {
                var edges = leftEdgeMap.Find(hash);
                int index;
                while (edges.Next(out index))
                {
                    var leftEdge = leftEdgeMap.Values[index];
                    if (AreLeftSame(end, ref key, leftBatch, leftIndex, ref leftEdge))
                    {
                        edges.Remove();
                        break;
                    }
                }
            }

            // Output end edges.
            CreateOutputForLeftEndEdge(start, end, ref key, leftBatch, leftIndex, hash);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ProcessRightEvent(long start, long end, ref <#= TKey #> key, <#= RightBatchType #> rightBatch, int rightRowIndex, int hash)
    {
        if (start < end)
        {
            // Row is a start edge or interval.
            bool processable = nextLeftTime > start || leftEdgeMap.IsEmpty;
            if (end == StreamEvent.InfinitySyncTime)
            {
                // Row is a start edge.
                if (processable)
                {
                    if (!isLeftComplete)
                    {
                        int index = rightEdgeMap.Insert(hash);
                        rightEdgeMap.Values[index].Populate(start, ref key, rightBatch, rightRowIndex);
                    }

                    CreateOutputForRightStartEdge(start, ref key, rightBatch, rightRowIndex, hash);
                }
                else
                {
                    int index = rightEdgeMap.InsertInvisible(hash);
                    rightEdgeMap.Values[index].Populate(start, ref key, rightBatch, rightRowIndex);
                }
            }
            else
            {
                // Row is an interval.
                if (processable)
                {
                    int index = rightIntervalMap.Insert(hash);
                    rightIntervalMap.Values[index].Populate(start, end, ref key, rightBatch, rightRowIndex);
                    CreateOutputForRightStartInterval(start, end, ref key, rightBatch, rightRowIndex, hash);
                    endPointHeap.Insert(end, ~index);
                }
                else
                {
                    int index = rightIntervalMap.InsertInvisible(hash);
                    rightIntervalMap.Values[index].Populate(start, end, ref key, rightBatch, rightRowIndex);
                }
            }
        }
        else if (end == StreamEvent.PunctuationOtherTime)
        {
            AddPunctuationToBatch(start);
        }
        else
        {
            // Row is an end edge.

            // Remove from leftEdgeMap.
            if (!isLeftComplete)
            {
                var edges = rightEdgeMap.Find(hash);
                int index;
                while (edges.Next(out index))
                {
                    var rightEdge = rightEdgeMap.Values[index];
                    if (AreRightSame(end, ref key, rightBatch, rightRowIndex, ref rightEdge))
                    {
                        edges.Remove();
                        break;
                    }
                }
            }

            // Output end edges.
            CreateOutputForRightEndEdge(start, end, ref key, rightBatch, rightRowIndex, hash);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void LeaveTime()
    {
        int index;
        int hash;
        var leftEdges = leftEdgeMap.TraverseInvisible();
        while (leftEdges.Next(out index, out hash))
        {
            CreateOutputForLeftStartEdge(
                currTime,
                ref leftEdgeMap.Values[index].Key,
                ref leftEdgeMap.Values[index],
                hash);
            leftEdges.MakeVisible();
        }

        var leftIntervals = leftIntervalMap.TraverseInvisible();
        while (leftIntervals.Next(out index, out hash))
        {
            long end = leftIntervalMap.Values[index].End;
            CreateOutputForLeftStartInterval(
                currTime,
                end,
                ref leftIntervalMap.Values[index].Key,
                ref leftIntervalMap.Values[index],
                hash);
            leftIntervals.MakeVisible();
            endPointHeap.Insert(end, index);
        }

        var rightEdges = rightEdgeMap.TraverseInvisible();
        while (rightEdges.Next(out index, out hash))
        {
            CreateOutputForRightStartEdge(
                currTime,
                ref rightEdgeMap.Values[index].Key,
                ref rightEdgeMap.Values[index],
                hash);
            rightEdges.MakeVisible();
        }

        var rightIntervals = rightIntervalMap.TraverseInvisible();
        while (rightIntervals.Next(out index, out hash))
        {
            long end = rightIntervalMap.Values[index].End;
            CreateOutputForRightStartInterval(
                currTime,
                end,
                ref rightIntervalMap.Values[index].Key,
                ref rightIntervalMap.Values[index],
                hash);
            rightIntervals.MakeVisible();
            endPointHeap.Insert(end, ~index);
        }

        if (nextLeftTime == StreamEvent.InfinitySyncTime && leftIntervalMap.IsEmpty)
        {
            isLeftComplete = true;
        }

        if (nextRightTime == StreamEvent.InfinitySyncTime && rightIntervalMap.IsEmpty)
        {
            isRightComplete = true;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ReachTime()
    {
        long endPointTime;
        int index;
        while (endPointHeap.TryGetNextInclusive(currTime, out endPointTime, out index))
        {
            if (index >= 0)
            {
                // Endpoint is left interval ending.
                var leftInterval = leftIntervalMap.Values[index];
                CreateOutputForLeftEndInterval(
                    endPointTime,
                    leftInterval.Start,
                    ref leftInterval.Key,
                    ref leftInterval,
                    leftIntervalMap.GetHash(index));
                leftIntervalMap.Remove(index);
            }
            else
            {
                // Endpoint is right interval ending.
                index = ~index;
                var rightInterval = rightIntervalMap.Values[index];
                CreateOutputForRightEndInterval(
                    endPointTime,
                    rightInterval.Start,
                    ref rightInterval.Key,
                    ref rightInterval,
                    rightIntervalMap.GetHash(index));
                rightIntervalMap.Remove(index);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftEndEdge(long currentTime, long start, ref <#= TKey #> key, <#= LeftBatchType #> leftBatch, int leftIndex, int hash)
    {
        // Create end edges for all joined right edges.
        var edges = rightEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightEdgeMap.Values[index].Key") #>)
            {
                long rightStart = rightEdgeMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > rightStart ? start : rightStart,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }

        // Create end edges for all joined right intervals.
        var intervals = rightIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightIntervalMap.Values[index].Key") #>)
            {
                long rightStart = rightIntervalMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > rightStart ? start : rightStart,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightIntervalMap.Values[index],
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightEndEdge(long currentTime, long start, ref <#= TKey #> key, <#= RightBatchType #> rightBatch, int rightIndex, int hash)
    {
        // Create end edges for all joined left edges.
        var edges = leftEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "leftEdgeMap.Values[index].Key") #>)
            {
                long leftStart = leftEdgeMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > leftStart ? start : leftStart,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }

        // Create end edges for all joined left intervals.
        var intervals = leftIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (<#= keyComparerEquals("key", "leftIntervalMap.Values[index].Key") #>)
            {
                long leftStart = leftIntervalMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > leftStart ? start : leftStart,
                    ref key,
                    ref leftIntervalMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftStartEdge(long currentTime, ref <#= TKey #> key, <#= LeftBatchType #> leftBatch, int leftIndex, int hash)
    {
        // Create end edges for all joined right edges.
        var edges = rightEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightEdgeMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }

        // Create end edges for all joined right intervals.
        var intervals = rightIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightIntervalMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightIntervalMap.Values[index],
                    hash);
            }
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftStartEdge(long currentTime, ref <#= TKey #> key, ref ActiveEdgeLeft leftEdge, int hash)
    {
        // Create end edges for all joined right edges.
        var edges = rightEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightEdgeMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdge,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }

        // Create end edges for all joined right intervals.
        var intervals = rightIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightIntervalMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdge,
                    ref rightIntervalMap.Values[index],
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightStartEdge(long currentTime, ref <#= TKey #> key, <#= RightBatchType #> rightBatch, int rightIndex, int hash)
    {
        // Create end edges for all joined left edges.
        var edges = leftEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "leftEdgeMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }

        // Create end edges for all joined left intervals.
        var intervals = leftIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (<#= keyComparerEquals("key", "leftIntervalMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftIntervalMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightStartEdge(long currentTime, ref <#= TKey #> key, ref ActiveEdgeRight rightEdge, int hash)
    {
        // Create end edges for all joined left edges.
        var edges = leftEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "leftEdgeMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    ref rightEdge,
                    hash);
            }
        }

        // Create end edges for all joined left intervals.
        var intervals = leftIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (<#= keyComparerEquals("key", "leftIntervalMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftIntervalMap.Values[index],
                    ref rightEdge,
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftStartInterval(long currentTime, long end, ref <#= TKey #> key, <#= LeftBatchType #> leftBatch, int leftIndex, int hash)
    {
        // Create end edges for all joined right edges.
        var edges = rightEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightEdgeMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }

        // Create end edges for all joined right intervals.
        var intervals = rightIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightIntervalMap.Values[index].Key") #>)
            {
                long rightEnd = rightIntervalMap.Values[index].End;
                AddToBatch(
                    currentTime,
                    end < rightEnd ? end : rightEnd,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightIntervalMap.Values[index],
                    hash);
            }
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftStartInterval(long currentTime, long end, ref <#= TKey #> key, ref ActiveIntervalLeft leftInterval, int hash)
    {
        // Create end edges for all joined right edges.
        var edges = rightEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightEdgeMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftInterval,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }

        // Create end edges for all joined right intervals.
        var intervals = rightIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightIntervalMap.Values[index].Key") #>)
            {
                long rightEnd = rightIntervalMap.Values[index].End;
                AddToBatch(
                    currentTime,
                    end < rightEnd ? end : rightEnd,
                    ref key,
                    ref leftInterval,
                    ref rightIntervalMap.Values[index],
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightStartInterval(long currentTime, long end, ref <#= TKey #> key, <#= RightBatchType #> rightBatch, int rightIndex, int hash)
    {
        // Create end edges for all joined left edges.
        var edges = leftEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "leftEdgeMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }

        // Create end edges for all joined left intervals.
        var intervals = leftIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (<#= keyComparerEquals("key", "leftIntervalMap.Values[index].Key") #>)
            {
                long leftEnd = leftIntervalMap.Values[index].End;
                AddToBatch(
                    currentTime,
                    end < leftEnd ? end : leftEnd,
                    ref key,
                    ref leftIntervalMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightStartInterval(long currentTime, long end, ref <#= TKey #> key, ref ActiveIntervalRight rightInterval, int hash)
    {
        // Create end edges for all joined left edges.
        var edges = leftEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "leftEdgeMap.Values[index].Key") #>)
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    ref rightInterval,
                    hash);
            }
        }

        // Create end edges for all joined left intervals.
        var intervals = leftIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (<#= keyComparerEquals("key", "leftIntervalMap.Values[index].Key") #>)
            {
                long leftEnd = leftIntervalMap.Values[index].End;
                AddToBatch(
                    currentTime,
                    end < leftEnd ? end : leftEnd,
                    ref key,
                    ref leftIntervalMap.Values[index],
                    ref rightInterval,
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftEndInterval(long currentTime, long start,  ref <#= TKey #> key, <#= LeftBatchType #> leftBatch, int leftIndex, int hash)
    {
        // Create end edges for all joined right edges.
        var edges = rightEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightEdgeMap.Values[index].Key") #>)
            {
                long rightStart = rightEdgeMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > rightStart ? start : rightStart,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftEndInterval(long currentTime, long start,  ref <#= TKey #> key, ref ActiveIntervalLeft leftInterval, int hash)
    {
        // Create end edges for all joined right edges.
        var edges = rightEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "rightEdgeMap.Values[index].Key") #>)
            {
                long rightStart = rightEdgeMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > rightStart ? start : rightStart,
                    ref key,
                    ref leftInterval,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightEndInterval(long currentTime, long start, ref <#= TKey #> key, ref ActiveIntervalRight rightInterval, int hash)
    {
        // Create end edges for all joined left edges.
        var edges = leftEdgeMap.Find(hash);
        int index;
        while (edges.Next(out index))
        {
            if (<#= keyComparerEquals("key", "leftEdgeMap.Values[index].Key") #>)
            {
                long leftStart = leftEdgeMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > leftStart ? start : leftStart,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    ref rightInterval,
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddPunctuationToBatch(long start)
    {
        if (start > lastCTI)
        {
            lastCTI = start;

            int index = output.Count++;
            output.vsync.col[index] = start;
            output.vother.col[index] = StreamEvent.PunctuationOtherTime;
            output.key.col[index] = default;
            output[index] = default;
            output.hash.col[index] = 0;
            output.bitvector.col[index >> 6] |= (1L << (index & 0x3f));

            if (output.Count == Config.DataBatchSize) FlushContents();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref <#= TKey #> key, ref ActiveIntervalLeft leftInterval, <#= RightBatchType #> rightBatch, int rightIndex, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        <#= rightBatchSelector("leftInterval.Payload", "rightBatch", "rightIndex") #>
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize) FlushContents();
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref <#= TKey #> key, ref ActiveEdgeLeft leftEdge, <#= RightBatchType #> rightBatch, int rightIndex, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        <#= rightBatchSelector("leftEdge.Payload", "rightBatch", "rightIndex") #>
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize) FlushContents();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref <#= TKey #> key, <#= LeftBatchType #> leftBatch, int leftIndex, ref ActiveIntervalRight rightInterval, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        <#= leftBatchSelector("leftBatch", "leftIndex", "rightInterval.Payload") #>
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize) FlushContents();
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref <#= TKey #> key, ref ActiveIntervalLeft leftInterval, ref ActiveIntervalRight rightInterval, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        <#= activeSelector("leftInterval.Payload", "rightInterval.Payload") #>
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize) FlushContents();
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref <#= TKey #> key, ref ActiveIntervalLeft leftInterval, ref ActiveEdgeRight rightEdge, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        <#= activeSelector("leftInterval.Payload", "rightEdge.Payload") #>
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize) FlushContents();
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref <#= TKey #> key, ref ActiveEdgeLeft leftEdge, ref ActiveIntervalRight rightInterval, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        <#= activeSelector("leftEdge.Payload", "rightInterval.Payload") #>
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize) FlushContents();
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref <#= TKey #> key, ref ActiveEdgeLeft leftEdge, ref ActiveEdgeRight rightEdge, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        <#= activeSelector("leftEdge.Payload", "rightEdge.Payload") #>
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize) FlushContents();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref <#= TKey #> key, <#= LeftBatchType #> leftBatch, int leftIndex, ref ActiveEdgeRight rightEdge, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        <#= leftBatchSelector("leftBatch", "leftIndex", "rightEdge.Payload") #>
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize) FlushContents();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool AreLeftSame(long start, ref <#= TKey #> key, <#= LeftBatchType #> leftBatch, int leftIndex, ref ActiveEdgeLeft active)
    {
        return start == active.Start && <#= keyComparerEquals("key", "active.Key") #> && <#= leftComparerEquals("leftBatch", "active.Payload") #>;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool AreRightSame(long start, ref <#= TKey #> key, <#= RightBatchType #> rightBatch, int rightIndex, ref ActiveEdgeRight active)
    {
        return start == active.Start && <#= keyComparerEquals("key", "active.Key") #> && <#= rightComparerEquals("rightBatch", "active.Payload") #>;
    }

    protected override void FlushContents()
    {
        if (output.Count == 0) return;
        output.Seal();
        this.Observer.OnNext(output);
        GetOutputBatch();
    }

<# if (!this.leftType.GetTypeInfo().IsValueType) { #>
    [DataContract]
    private struct <#= ActiveEventTypeLeft #>
    {
        <# foreach (var f in this.leftFields) { #>
        [DataMember]
        public <#= f.Type.GetCSharpSourceSyntax() #> <#= f.OriginalName #>;
        <# } #>
    }
<# } #>
<# if (!this.rightType.GetTypeInfo().IsValueType) { #>
    [DataContract]
    private struct <#= ActiveEventTypeRight #>
    {
        <# foreach (var f in this.rightFields) { #>
        [DataMember]
        public <#= f.Type.GetCSharpSourceSyntax() #> <#= f.OriginalName #>;
        <# } #>
    }
<# } #>

    [DataContract]
    private struct ActiveIntervalLeft
    {
        [DataMember]
        public long Start;
        [DataMember]
        public long End;
        [DataMember]
        public <#= TKey #> Key;

        [DataMember]
        public <#= ActiveEventTypeLeft #> Payload;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Populate(long start, long end, ref <#= TKey #> key, <#= LeftBatchType #> batch, int index)
        {
            Start = start;
            End = end;
            Key = key;

<# if (this.leftMessageRepresentation.noFields) { #>
            this.Payload = batch.payload.col[index];
<# } else { #>
<#     foreach (var f in this.leftFields) { #>
            this.Payload.<#= f.OriginalName #> = <#= f.AccessExpressionForRowValue("batch", "index") #>;
<# } #>
<# } #>

        }

        public override string ToString()
        {
            return "[Start=" + Start + ", End=" + End + ", Key='" + Key + "', Payload='" + "']";
        }
    }

    [DataContract]
    private struct ActiveIntervalRight
    {
        [DataMember]
        public long Start;
        [DataMember]
        public long End;
        [DataMember]
        public <#= TKey #> Key;

        [DataMember]
        public <#= ActiveEventTypeRight #> Payload;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Populate(long start, long end, ref <#= TKey #> key, <#= RightBatchType #> batch, int index)
        {
            Start = start;
            End = end;
            Key = key;

<# if (this.rightMessageRepresentation.noFields) { #>
            this.Payload = batch.payload.col[index];
<# } else { #>
<#     foreach (var f in this.rightFields) { #>
            this.Payload.<#= f.OriginalName #> = <#= f.AccessExpressionForRowValue("batch", "index") #>;
<# } #>
<# } #>

        }

        public override string ToString()
        {
            return "[Start=" + Start + ", End=" + End + ", Key='" + Key + "', Payload='" + "']";
        }
    }

    [DataContract]
    private struct ActiveEdgeLeft
    {
        [DataMember]
        public long Start;
        [DataMember]
        public <#= TKey #> Key;

        [DataMember]
        public <#= ActiveEventTypeLeft #> Payload;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Populate(long start, ref <#= TKey #> key, <#= LeftBatchType #> batch, int index)
        {
            Start = start;
            Key = key;

<# if (this.leftMessageRepresentation.noFields) { #>
            this.Payload = batch.payload.col[index];
<# } else { #>
<#     foreach (var f in this.leftFields) { #>
            this.Payload.<#= f.OriginalName #> = <#= f.AccessExpressionForRowValue("batch", "index") #>;
<# } #>
<# } #>

        }

        public override string ToString()
        {
            return "[Start=" + Start + ", Key='" + Key + "', Payload='" + "']";
        }
    }

    [DataContract]
    private struct ActiveEdgeRight
    {
        [DataMember]
        public long Start;
        [DataMember]
        public <#= TKey #> Key;

        [DataMember]
        public <#= ActiveEventTypeRight #> Payload;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Populate(long start, ref <#= TKey #> key, <#= RightBatchType #> batch, int index)
        {
            Start = start;
            Key = key;

<# if (this.rightMessageRepresentation.noFields) { #>
            this.Payload = batch.payload.col[index];
<# } else { #>
<#     foreach (var f in this.rightFields) { #>
            this.Payload.<#= f.OriginalName #> = <#= f.AccessExpressionForRowValue("batch", "index") #>;
<# } #>
<# } #>

        }

        public override string ToString()
        {
            return "[Start=" + Start + ", Key='" + Key + "', Payload='" + "']";
        }
    }
}
