// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System.Reflection;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class EquiJoinTemplate : CommonBinaryTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;
[assembly: IgnoresAccessChecksTo(""Microsoft.StreamProcessing"")]

// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TLeft: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("\r\n// TRight: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("\r\n// TResult: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("\r\n\r\n[DataContract]\r\n[KnownType(typeof(EndPointHeap))]\r\n[KnownType(typeof(EndPoint" +
                    "Queue))]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(genericParameters));
            this.Write(" : BinaryPipe<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(">\r\n{\r\n    //private readonly Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("> selector;\r\n    private readonly MemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("> pool;\r\n    private readonly Func<PlanNode, PlanNode, IBinaryObserver, BinaryPla" +
                    "nNode> queryPlanGenerator;\r\n\r\n    [SchemaSerialization]\r\n    private readonly Ex" +
                    "pression<Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", bool>> keyComparer;\r\n    private readonly Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", bool> keyComparerEquals;\r\n\r\n    private StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("> genericOutputBatch;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TResult));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTResultGenericParameters));
            this.Write(@" output;
    [DataMember]
    private FastMap<ActiveIntervalLeft> leftIntervalMap = new FastMap<ActiveIntervalLeft>();
    [DataMember]
    private FastMap<ActiveEdgeLeft> leftEdgeMap = new FastMap<ActiveEdgeLeft>();
    [DataMember]
    private IEndPointOrderer endPointHeap;
    [DataMember]
    private FastMap<ActiveIntervalRight> rightIntervalMap = new FastMap<ActiveIntervalRight>();
    [DataMember]
    private FastMap<ActiveEdgeRight> rightEdgeMap = new FastMap<ActiveEdgeRight>();
    [DataMember]
    private long nextLeftTime = long.MinValue;
    [DataMember]
    private bool isLeftComplete;
    [DataMember]
    private long nextRightTime = long.MinValue;
    [DataMember]
    private bool isRightComplete;
    [DataMember]
    private long currTime = long.MinValue;

    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    [Obsolete(\"Used only by serialization. Do not call directly.\")]\r\n    publ" +
                    "ic ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(@"> observer,
        Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> queryPlanGenerator)
        : base(stream, observer)
    {
        this.queryPlanGenerator = queryPlanGenerator;

        this.keyComparer = stream.Properties.KeyEqualityComparer.GetEqualsExpr();
        this.keyComparerEquals = this.keyComparer.Compile();

        this.endPointHeap = new ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.endPointHeap));
            this.Write("();\r\n\r\n        this.pool = MemoryManager.GetMemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TResult));
            this.Write(@">(true /*stream.Properties.IsColumnar*/);
        GetOutputBatch();
    }

    public override int CurrentlyBufferedOutputCount => output.Count;
    public override int CurrentlyBufferedLeftInputCount => base.CurrentlyBufferedLeftInputCount + leftEdgeMap.Count + leftIntervalMap.Count;
    public override int CurrentlyBufferedRightInputCount => base.CurrentlyBufferedRightInputCount + rightEdgeMap.Count + rightIntervalMap.Count;

    protected override void ProduceBinaryQueryPlan(PlanNode left, PlanNode right)
    {
        Observer.ProduceQueryPlan(queryPlanGenerator(left, right, this));
    }

    protected override void DisposeState() => this.output.Free();

    private void GetOutputBatch()
    {
        pool.Get(out genericOutputBatch);
        genericOutputBatch.Allocate();
        output = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TResult));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTResultGenericParameters));
            this.Write(")genericOutputBatch;\r\n");
 foreach (var f in this.resultFields.Where(fld => fld.OptimizeString())) {  
            this.Write("\r\n        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Initialize();\r\n");
 } 
            this.Write("    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    protected ov" +
                    "erride void ProcessBothBatches(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> genericLeftBatch, StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("> genericRightBatch, out bool leftBatchDone, out bool rightBatchDone, out bool le" +
                    "ftBatchFree, out bool rightBatchFree)\r\n    {\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(" leftBatch = genericLeftBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(";\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(" rightBatch = genericRightBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(";\r\n        leftBatchFree = rightBatchFree = true;\r\n\r\n        if (!GoToVisibleRow(" +
                    "genericLeftBatch))\r\n        {\r\n            leftBatchDone = true;\r\n            ri" +
                    "ghtBatchDone = false;\r\n            return;\r\n        }\r\n\r\n        UpdateNextLeftT" +
                    "ime(genericLeftBatch.vsync.col[genericLeftBatch.iter]);\r\n\r\n        if (!GoToVisi" +
                    "bleRow(genericRightBatch))\r\n        {\r\n            leftBatchDone = false;\r\n     " +
                    "       rightBatchDone = true;\r\n            return;\r\n        }\r\n\r\n        UpdateN" +
                    "extRightTime(genericRightBatch.vsync.col[genericRightBatch.iter]);\r\n\r\n        wh" +
                    "ile (true)\r\n        {\r\n            if (nextLeftTime <= nextRightTime)\r\n         " +
                    "   {\r\n                UpdateTime(nextLeftTime);\r\n                ProcessLeftEven" +
                    "t(\r\n                    nextLeftTime,\r\n                    leftBatch.vother.col[" +
                    "leftBatch.iter],\r\n                    ref leftBatch.key.col[leftBatch.iter],\r\n  " +
                    "                  leftBatch,\r\n                    leftBatch.iter,\r\n             " +
                    "       leftBatch.hash.col[leftBatch.iter]);\r\n\r\n                leftBatch.iter++;" +
                    "\r\n\r\n                if (!GoToVisibleRow(leftBatch))\r\n                {\r\n        " +
                    "            leftBatchDone = true;\r\n                    rightBatchDone = false;\r\n" +
                    "                    break;\r\n                }\r\n\r\n                UpdateNextLeftT" +
                    "ime(leftBatch.vsync.col[leftBatch.iter]);\r\n            }\r\n            else\r\n    " +
                    "        {\r\n                UpdateTime(nextRightTime);\r\n                ProcessRi" +
                    "ghtEvent(\r\n                    nextRightTime,\r\n                    rightBatch.vo" +
                    "ther.col[rightBatch.iter],\r\n                    ref rightBatch.key.col[rightBatc" +
                    "h.iter],\r\n                    rightBatch,\r\n                    rightBatch.iter,\r" +
                    "\n                    rightBatch.hash.col[rightBatch.iter]);\r\n\r\n                r" +
                    "ightBatch.iter++;\r\n\r\n                if (!GoToVisibleRow(rightBatch))\r\n         " +
                    "       {\r\n                    leftBatchDone = false;\r\n                    rightB" +
                    "atchDone = true;\r\n                    break;\r\n                }\r\n\r\n             " +
                    "   UpdateNextRightTime(rightBatch.vsync.col[rightBatch.iter]);\r\n            }\r\n " +
                    "       }\r\n\r\n        return;\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.Aggressi" +
                    "veInlining)]\r\n    protected override void ProcessLeftBatch(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> genericLeftBatch, out bool isBatchDone, out bool isBatchFree)\r\n    {\r\n        i" +
                    "sBatchFree = true;\r\n        var batch = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(@") genericLeftBatch;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                break;
            }

            UpdateNextLeftTime(batch.vsync.col[batch.iter]);

            if (nextLeftTime > nextRightTime)
            {
                isBatchDone = false;
                break;
            }

            UpdateTime(nextLeftTime);

            ProcessLeftEvent(
                nextLeftTime,
                batch.vother.col[batch.iter],
                ref batch.key.col[batch.iter],
                batch,
                batch.iter,
                batch.hash.col[batch.iter]);

            batch.iter++;
        }

        return;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessRightBatch(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("> genericRightBatch, out bool isBatchDone, out bool isBatchFree)\r\n    {\r\n        " +
                    "isBatchFree = true;\r\n        var batch = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(@") genericRightBatch;

        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                break;
            }

            UpdateNextRightTime(batch.vsync.col[batch.iter]);

            if (nextRightTime > nextLeftTime)
            {
                isBatchDone = false;
                break;
            }

            UpdateTime(nextRightTime);

            ProcessRightEvent(
                nextRightTime,
                batch.vother.col[batch.iter],
                ref batch.key.col[batch.iter],
                batch,
                batch.iter,
                batch.hash.col[batch.iter]);

            batch.iter++;
        }

        return;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool GoToVisibleRow<TPayload>(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@", TPayload> batch)
    {
        while (batch.iter < batch.Count && (batch.bitvector.col[batch.iter >> 6] & (1L << (batch.iter & 0x3f))) != 0 && batch.vother.col[batch.iter] >= 0)
        {
            batch.iter++;
        }

        if (batch.iter == batch.Count)
        {
            return false;
        }

        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdateTime(long time)
    {
        if (time != currTime)
        {
            LeaveTime();
            currTime = time;
            ReachTime();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdateNextLeftTime(long time)
    {
        nextLeftTime = time;
        if (nextLeftTime == StreamEvent.InfinitySyncTime && leftEdgeMap.IsInvisibleEmpty && leftIntervalMap.IsInvisibleEmpty && leftIntervalMap.IsEmpty)
        {
            isLeftComplete = true;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdateNextRightTime(long time)
    {
        nextRightTime = time;
        if (nextRightTime == StreamEvent.InfinitySyncTime && rightEdgeMap.IsInvisibleEmpty && rightIntervalMap.IsInvisibleEmpty && rightIntervalMap.IsEmpty)
        {
            isRightComplete = true;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ProcessLeftEvent(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(" leftBatch, int leftIndex, int hash)\r\n    {\r\n        if (start < end)\r\n        {\r" +
                    "\n            // Row is a start edge or interval.\r\n            bool processable =" +
                    " nextRightTime > start || rightEdgeMap.IsEmpty;\r\n            if (end == StreamEv" +
                    "ent.InfinitySyncTime)\r\n            {\r\n                // Row is a start edge.\r\n " +
                    "               if (processable)\r\n                {\r\n                    if (!isR" +
                    "ightComplete)\r\n                    {\r\n                        int index = leftEd" +
                    "geMap.Insert(hash);\r\n                        leftEdgeMap.Values[index].Populate(" +
                    "start, ref key, leftBatch, leftIndex);\r\n                    }\r\n\r\n               " +
                    "     CreateOutputForLeftStartEdge(start, ref key, leftBatch, leftIndex, hash);\r\n" +
                    "                }\r\n                else\r\n                {\r\n                    " +
                    "int index = leftEdgeMap.InsertInvisible(hash);\r\n                    leftEdgeMap." +
                    "Values[index].Populate(start, ref key, leftBatch, leftIndex);\r\n                }" +
                    "\r\n            }\r\n            else\r\n            {\r\n                // Row is an i" +
                    "nterval.\r\n                if (processable)\r\n                {\r\n                 " +
                    "   int index = leftIntervalMap.Insert(hash);\r\n                    leftIntervalMa" +
                    "p.Values[index].Populate(start, end, ref key, leftBatch, leftIndex);\r\n          " +
                    "          CreateOutputForLeftStartInterval(start, end, ref key, leftBatch, leftI" +
                    "ndex, hash);\r\n                    endPointHeap.Insert(end, index);\r\n            " +
                    "    }\r\n                else\r\n                {\r\n                    int index = " +
                    "leftIntervalMap.InsertInvisible(hash);\r\n                    leftIntervalMap.Valu" +
                    "es[index].Populate(start, end, ref key, leftBatch, leftIndex);\r\n                " +
                    "}\r\n            }\r\n        }\r\n        else if (end == StreamEvent.PunctuationOthe" +
                    "rTime)\r\n        {\r\n            AddPunctuationToBatch(start);\r\n        }\r\n       " +
                    " else\r\n        {\r\n            // Row is an end edge.\r\n\r\n            // Remove fr" +
                    "om leftEdgeMap.\r\n            if (!isRightComplete)\r\n            {\r\n             " +
                    "   var edges = leftEdgeMap.Find(hash);\r\n                int index;\r\n            " +
                    "    while (edges.Next(out index))\r\n                {\r\n                    var le" +
                    "ftEdge = leftEdgeMap.Values[index];\r\n                    if (AreLeftSame(end, re" +
                    "f key, leftBatch, leftIndex, ref leftEdge))\r\n                    {\r\n            " +
                    "            edges.Remove();\r\n                        break;\r\n                   " +
                    " }\r\n                }\r\n            }\r\n\r\n            // Output end edges.\r\n      " +
                    "      CreateOutputForLeftEndEdge(start, end, ref key, leftBatch, leftIndex, hash" +
                    ");\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n" +
                    "    private void ProcessRightEvent(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(" rightBatch, int rightRowIndex, int hash)\r\n    {\r\n        if (start < end)\r\n     " +
                    "   {\r\n            // Row is a start edge or interval.\r\n            bool processa" +
                    "ble = nextLeftTime > start || leftEdgeMap.IsEmpty;\r\n            if (end == Strea" +
                    "mEvent.InfinitySyncTime)\r\n            {\r\n                // Row is a start edge." +
                    "\r\n                if (processable)\r\n                {\r\n                    if (!" +
                    "isLeftComplete)\r\n                    {\r\n                        int index = righ" +
                    "tEdgeMap.Insert(hash);\r\n                        rightEdgeMap.Values[index].Popul" +
                    "ate(start, ref key, rightBatch, rightRowIndex);\r\n                    }\r\n\r\n      " +
                    "              CreateOutputForRightStartEdge(start, ref key, rightBatch, rightRow" +
                    "Index, hash);\r\n                }\r\n                else\r\n                {\r\n     " +
                    "               int index = rightEdgeMap.InsertInvisible(hash);\r\n                " +
                    "    rightEdgeMap.Values[index].Populate(start, ref key, rightBatch, rightRowInde" +
                    "x);\r\n                }\r\n            }\r\n            else\r\n            {\r\n        " +
                    "        // Row is an interval.\r\n                if (processable)\r\n              " +
                    "  {\r\n                    int index = rightIntervalMap.Insert(hash);\r\n           " +
                    "         rightIntervalMap.Values[index].Populate(start, end, ref key, rightBatch" +
                    ", rightRowIndex);\r\n                    CreateOutputForRightStartInterval(start, " +
                    "end, ref key, rightBatch, rightRowIndex, hash);\r\n                    endPointHea" +
                    "p.Insert(end, ~index);\r\n                }\r\n                else\r\n               " +
                    " {\r\n                    int index = rightIntervalMap.InsertInvisible(hash);\r\n   " +
                    "                 rightIntervalMap.Values[index].Populate(start, end, ref key, ri" +
                    "ghtBatch, rightRowIndex);\r\n                }\r\n            }\r\n        }\r\n        " +
                    "else if (end == StreamEvent.PunctuationOtherTime)\r\n        {\r\n            AddPun" +
                    "ctuationToBatch(start);\r\n        }\r\n        else\r\n        {\r\n            // Row " +
                    "is an end edge.\r\n\r\n            // Remove from leftEdgeMap.\r\n            if (!isL" +
                    "eftComplete)\r\n            {\r\n                var edges = rightEdgeMap.Find(hash)" +
                    ";\r\n                int index;\r\n                while (edges.Next(out index))\r\n  " +
                    "              {\r\n                    var rightEdge = rightEdgeMap.Values[index];" +
                    "\r\n                    if (AreRightSame(end, ref key, rightBatch, rightRowIndex, " +
                    "ref rightEdge))\r\n                    {\r\n                        edges.Remove();\r" +
                    "\n                        break;\r\n                    }\r\n                }\r\n     " +
                    "       }\r\n\r\n            // Output end edges.\r\n            CreateOutputForRightEn" +
                    "dEdge(start, end, ref key, rightBatch, rightRowIndex, hash);\r\n        }\r\n    }\r\n" +
                    "\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    private void Leave" +
                    "Time()\r\n    {\r\n        int index;\r\n        int hash;\r\n        var leftEdges = le" +
                    "ftEdgeMap.TraverseInvisible();\r\n        while (leftEdges.Next(out index, out has" +
                    "h))\r\n        {\r\n            CreateOutputForLeftStartEdge(\r\n                currT" +
                    "ime,\r\n                ref leftEdgeMap.Values[index].Key,\r\n                ref le" +
                    "ftEdgeMap.Values[index],\r\n                hash);\r\n            leftEdges.MakeVisi" +
                    "ble();\r\n        }\r\n\r\n        var leftIntervals = leftIntervalMap.TraverseInvisib" +
                    "le();\r\n        while (leftIntervals.Next(out index, out hash))\r\n        {\r\n     " +
                    "       long end = leftIntervalMap.Values[index].End;\r\n            CreateOutputFo" +
                    "rLeftStartInterval(\r\n                currTime,\r\n                end,\r\n          " +
                    "      ref leftIntervalMap.Values[index].Key,\r\n                ref leftIntervalMa" +
                    "p.Values[index],\r\n                hash);\r\n            leftIntervals.MakeVisible(" +
                    ");\r\n            endPointHeap.Insert(end, index);\r\n        }\r\n\r\n        var right" +
                    "Edges = rightEdgeMap.TraverseInvisible();\r\n        while (rightEdges.Next(out in" +
                    "dex, out hash))\r\n        {\r\n            CreateOutputForRightStartEdge(\r\n        " +
                    "        currTime,\r\n                ref rightEdgeMap.Values[index].Key,\r\n        " +
                    "        ref rightEdgeMap.Values[index],\r\n                hash);\r\n            rig" +
                    "htEdges.MakeVisible();\r\n        }\r\n\r\n        var rightIntervals = rightIntervalM" +
                    "ap.TraverseInvisible();\r\n        while (rightIntervals.Next(out index, out hash)" +
                    ")\r\n        {\r\n            long end = rightIntervalMap.Values[index].End;\r\n      " +
                    "      CreateOutputForRightStartInterval(\r\n                currTime,\r\n           " +
                    "     end,\r\n                ref rightIntervalMap.Values[index].Key,\r\n            " +
                    "    ref rightIntervalMap.Values[index],\r\n                hash);\r\n            rig" +
                    "htIntervals.MakeVisible();\r\n            endPointHeap.Insert(end, ~index);\r\n     " +
                    "   }\r\n\r\n        if (nextLeftTime == StreamEvent.InfinitySyncTime && leftInterval" +
                    "Map.IsEmpty)\r\n        {\r\n            isLeftComplete = true;\r\n        }\r\n\r\n      " +
                    "  if (nextRightTime == StreamEvent.InfinitySyncTime && rightIntervalMap.IsEmpty)" +
                    "\r\n        {\r\n            isRightComplete = true;\r\n        }\r\n    }\r\n\r\n    [Metho" +
                    "dImpl(MethodImplOptions.AggressiveInlining)]\r\n    private void ReachTime()\r\n    " +
                    "{\r\n        long endPointTime;\r\n        int index;\r\n        while (endPointHeap.T" +
                    "ryGetNextInclusive(currTime, out endPointTime, out index))\r\n        {\r\n         " +
                    "   if (index >= 0)\r\n            {\r\n                // Endpoint is left interval " +
                    "ending.\r\n                var leftInterval = leftIntervalMap.Values[index];\r\n    " +
                    "            CreateOutputForLeftEndInterval(\r\n                    endPointTime,\r\n" +
                    "                    leftInterval.Start,\r\n                    ref leftInterval.Ke" +
                    "y,\r\n                    ref leftInterval,\r\n                    leftIntervalMap.G" +
                    "etHash(index));\r\n                leftIntervalMap.Remove(index);\r\n            }\r\n" +
                    "            else\r\n            {\r\n                // Endpoint is right interval e" +
                    "nding.\r\n                index = ~index;\r\n                var rightInterval = rig" +
                    "htIntervalMap.Values[index];\r\n                CreateOutputForRightEndInterval(\r\n" +
                    "                    endPointTime,\r\n                    rightInterval.Start,\r\n   " +
                    "                 ref rightInterval.Key,\r\n                    ref rightInterval,\r" +
                    "\n                    rightIntervalMap.GetHash(index));\r\n                rightInt" +
                    "ervalMap.Remove(index);\r\n            }\r\n        }\r\n    }\r\n\r\n    [MethodImpl(Meth" +
                    "odImplOptions.AggressiveInlining)]\r\n    private void CreateOutputForLeftEndEdge(" +
                    "long currentTime, long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(" leftBatch, int leftIndex, int hash)\r\n    {\r\n        // Create end edges for all " +
                    "joined right edges.\r\n        var edges = rightEdgeMap.Find(hash);\r\n        int i" +
                    "ndex;\r\n        while (edges.Next(out index))\r\n        {\r\n            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                long rightStart = rightEdgeMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > rightStart ? start : rightStart,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }

        // Create end edges for all joined right intervals.
        var intervals = rightIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                long rightStart = rightIntervalMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > rightStart ? start : rightStart,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightIntervalMap.Values[index],
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightEndEdge(long currentTime, long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(" rightBatch, int rightIndex, int hash)\r\n    {\r\n        // Create end edges for al" +
                    "l joined left edges.\r\n        var edges = leftEdgeMap.Find(hash);\r\n        int i" +
                    "ndex;\r\n        while (edges.Next(out index))\r\n        {\r\n            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "leftEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                long leftStart = leftEdgeMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > leftStart ? start : leftStart,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }

        // Create end edges for all joined left intervals.
        var intervals = leftIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "leftIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                long leftStart = leftIntervalMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > leftStart ? start : leftStart,
                    ref key,
                    ref leftIntervalMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftStartEdge(long currentTime, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(" leftBatch, int leftIndex, int hash)\r\n    {\r\n        // Create end edges for all " +
                    "joined right edges.\r\n        var edges = rightEdgeMap.Find(hash);\r\n        int i" +
                    "ndex;\r\n        while (edges.Next(out index))\r\n        {\r\n            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }

        // Create end edges for all joined right intervals.
        var intervals = rightIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightIntervalMap.Values[index],
                    hash);
            }
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftStartEdge(long currentTime, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ActiveEdgeLeft leftEdge, int hash)\r\n    {\r\n        // Create end edges " +
                    "for all joined right edges.\r\n        var edges = rightEdgeMap.Find(hash);\r\n     " +
                    "   int index;\r\n        while (edges.Next(out index))\r\n        {\r\n            if " +
                    "(");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdge,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }

        // Create end edges for all joined right intervals.
        var intervals = rightIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdge,
                    ref rightIntervalMap.Values[index],
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightStartEdge(long currentTime, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(" rightBatch, int rightIndex, int hash)\r\n    {\r\n        // Create end edges for al" +
                    "l joined left edges.\r\n        var edges = leftEdgeMap.Find(hash);\r\n        int i" +
                    "ndex;\r\n        while (edges.Next(out index))\r\n        {\r\n            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "leftEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }

        // Create end edges for all joined left intervals.
        var intervals = leftIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "leftIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftIntervalMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightStartEdge(long currentTime, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ActiveEdgeRight rightEdge, int hash)\r\n    {\r\n        // Create end edge" +
                    "s for all joined left edges.\r\n        var edges = leftEdgeMap.Find(hash);\r\n     " +
                    "   int index;\r\n        while (edges.Next(out index))\r\n        {\r\n            if " +
                    "(");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "leftEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    ref rightEdge,
                    hash);
            }
        }

        // Create end edges for all joined left intervals.
        var intervals = leftIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "leftIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftIntervalMap.Values[index],
                    ref rightEdge,
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftStartInterval(long currentTime, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(" leftBatch, int leftIndex, int hash)\r\n    {\r\n        // Create end edges for all " +
                    "joined right edges.\r\n        var edges = rightEdgeMap.Find(hash);\r\n        int i" +
                    "ndex;\r\n        while (edges.Next(out index))\r\n        {\r\n            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }

        // Create end edges for all joined right intervals.
        var intervals = rightIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                long rightEnd = rightIntervalMap.Values[index].End;
                AddToBatch(
                    currentTime,
                    end < rightEnd ? end : rightEnd,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightIntervalMap.Values[index],
                    hash);
            }
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftStartInterval(long currentTime, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ActiveIntervalLeft leftInterval, int hash)\r\n    {\r\n        // Create en" +
                    "d edges for all joined right edges.\r\n        var edges = rightEdgeMap.Find(hash)" +
                    ";\r\n        int index;\r\n        while (edges.Next(out index))\r\n        {\r\n       " +
                    "     if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftInterval,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }

        // Create end edges for all joined right intervals.
        var intervals = rightIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                long rightEnd = rightIntervalMap.Values[index].End;
                AddToBatch(
                    currentTime,
                    end < rightEnd ? end : rightEnd,
                    ref key,
                    ref leftInterval,
                    ref rightIntervalMap.Values[index],
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightStartInterval(long currentTime, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(" rightBatch, int rightIndex, int hash)\r\n    {\r\n        // Create end edges for al" +
                    "l joined left edges.\r\n        var edges = leftEdgeMap.Find(hash);\r\n        int i" +
                    "ndex;\r\n        while (edges.Next(out index))\r\n        {\r\n            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "leftEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }

        // Create end edges for all joined left intervals.
        var intervals = leftIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "leftIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                long leftEnd = leftIntervalMap.Values[index].End;
                AddToBatch(
                    currentTime,
                    end < leftEnd ? end : leftEnd,
                    ref key,
                    ref leftIntervalMap.Values[index],
                    rightBatch, rightIndex,
                    hash);
            }
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightStartInterval(long currentTime, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ActiveIntervalRight rightInterval, int hash)\r\n    {\r\n        // Create " +
                    "end edges for all joined left edges.\r\n        var edges = leftEdgeMap.Find(hash)" +
                    ";\r\n        int index;\r\n        while (edges.Next(out index))\r\n        {\r\n       " +
                    "     if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "leftEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                AddToBatch(
                    currentTime,
                    StreamEvent.InfinitySyncTime,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    ref rightInterval,
                    hash);
            }
        }

        // Create end edges for all joined left intervals.
        var intervals = leftIntervalMap.Find(hash);
        while (intervals.Next(out index))
        {
            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "leftIntervalMap.Values[index].Key")));
            this.Write(@")
            {
                long leftEnd = leftIntervalMap.Values[index].End;
                AddToBatch(
                    currentTime,
                    end < leftEnd ? end : leftEnd,
                    ref key,
                    ref leftIntervalMap.Values[index],
                    ref rightInterval,
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftEndInterval(long currentTime, long start,  ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(" leftBatch, int leftIndex, int hash)\r\n    {\r\n        // Create end edges for all " +
                    "joined right edges.\r\n        var edges = rightEdgeMap.Find(hash);\r\n        int i" +
                    "ndex;\r\n        while (edges.Next(out index))\r\n        {\r\n            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                long rightStart = rightEdgeMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > rightStart ? start : rightStart,
                    ref key,
                    leftBatch, leftIndex,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForLeftEndInterval(long currentTime, long start,  ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ActiveIntervalLeft leftInterval, int hash)\r\n    {\r\n        // Create en" +
                    "d edges for all joined right edges.\r\n        var edges = rightEdgeMap.Find(hash)" +
                    ";\r\n        int index;\r\n        while (edges.Next(out index))\r\n        {\r\n       " +
                    "     if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "rightEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                long rightStart = rightEdgeMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > rightStart ? start : rightStart,
                    ref key,
                    ref leftInterval,
                    ref rightEdgeMap.Values[index],
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void CreateOutputForRightEndInterval(long currentTime, long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ActiveIntervalRight rightInterval, int hash)\r\n    {\r\n        // Create " +
                    "end edges for all joined left edges.\r\n        var edges = leftEdgeMap.Find(hash)" +
                    ";\r\n        int index;\r\n        while (edges.Next(out index))\r\n        {\r\n       " +
                    "     if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "leftEdgeMap.Values[index].Key")));
            this.Write(@")
            {
                long leftStart = leftEdgeMap.Values[index].Start;
                AddToBatch(
                    currentTime,
                    start > leftStart ? start : leftStart,
                    ref key,
                    ref leftEdgeMap.Values[index],
                    ref rightInterval,
                    hash);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddPunctuationToBatch(long start)
    {
        if (start > lastCTI)
        {
            lastCTI = start;

            int index = output.Count++;
            output.vsync.col[index] = start;
            output.vother.col[index] = StreamEvent.PunctuationOtherTime;
            output.key.col[index] = default;
            output[index] = default;
            output.hash.col[index] = 0;
            output.bitvector.col[index >> 6] |= (1L << (index & 0x3f));

            if (output.Count == Config.DataBatchSize) FlushContents();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ActiveIntervalLeft leftInterval, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(" rightBatch, int rightIndex, int hash)\r\n    {\r\n        int index = output.Count++" +
                    ";\r\n        output.vsync.col[index] = start;\r\n        output.vother.col[index] = " +
                    "end;\r\n        output.key.col[index] = key;\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchSelector("leftInterval.Payload", "rightBatch", "rightIndex")));
            this.Write("\r\n        output.hash.col[index] = hash;\r\n\r\n        if (output.Count == Config.Da" +
                    "taBatchSize) FlushContents();\r\n    }\r\n    [MethodImpl(MethodImplOptions.Aggressi" +
                    "veInlining)]\r\n    private void AddToBatch(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ActiveEdgeLeft leftEdge, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(" rightBatch, int rightIndex, int hash)\r\n    {\r\n        int index = output.Count++" +
                    ";\r\n        output.vsync.col[index] = start;\r\n        output.vother.col[index] = " +
                    "end;\r\n        output.key.col[index] = key;\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightBatchSelector("leftEdge.Payload", "rightBatch", "rightIndex")));
            this.Write("\r\n        output.hash.col[index] = hash;\r\n\r\n        if (output.Count == Config.Da" +
                    "taBatchSize) FlushContents();\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.Aggres" +
                    "siveInlining)]\r\n    private void AddToBatch(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(" leftBatch, int leftIndex, ref ActiveIntervalRight rightInterval, int hash)\r\n    " +
                    "{\r\n        int index = output.Count++;\r\n        output.vsync.col[index] = start;" +
                    "\r\n        output.vother.col[index] = end;\r\n        output.key.col[index] = key;\r" +
                    "\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchSelector("leftBatch", "leftIndex", "rightInterval.Payload")));
            this.Write("\r\n        output.hash.col[index] = hash;\r\n\r\n        if (output.Count == Config.Da" +
                    "taBatchSize) FlushContents();\r\n    }\r\n    [MethodImpl(MethodImplOptions.Aggressi" +
                    "veInlining)]\r\n    private void AddToBatch(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@" key, ref ActiveIntervalLeft leftInterval, ref ActiveIntervalRight rightInterval, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(activeSelector("leftInterval.Payload", "rightInterval.Payload")));
            this.Write("\r\n        output.hash.col[index] = hash;\r\n\r\n        if (output.Count == Config.Da" +
                    "taBatchSize) FlushContents();\r\n    }\r\n    [MethodImpl(MethodImplOptions.Aggressi" +
                    "veInlining)]\r\n    private void AddToBatch(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@" key, ref ActiveIntervalLeft leftInterval, ref ActiveEdgeRight rightEdge, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(activeSelector("leftInterval.Payload", "rightEdge.Payload")));
            this.Write("\r\n        output.hash.col[index] = hash;\r\n\r\n        if (output.Count == Config.Da" +
                    "taBatchSize) FlushContents();\r\n    }\r\n    [MethodImpl(MethodImplOptions.Aggressi" +
                    "veInlining)]\r\n    private void AddToBatch(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@" key, ref ActiveEdgeLeft leftEdge, ref ActiveIntervalRight rightInterval, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(activeSelector("leftEdge.Payload", "rightInterval.Payload")));
            this.Write("\r\n        output.hash.col[index] = hash;\r\n\r\n        if (output.Count == Config.Da" +
                    "taBatchSize) FlushContents();\r\n    }\r\n    [MethodImpl(MethodImplOptions.Aggressi" +
                    "veInlining)]\r\n    private void AddToBatch(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ActiveEdgeLeft leftEdge, ref ActiveEdgeRight rightEdge, int hash)\r\n    " +
                    "{\r\n        int index = output.Count++;\r\n        output.vsync.col[index] = start;" +
                    "\r\n        output.vother.col[index] = end;\r\n        output.key.col[index] = key;\r" +
                    "\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(activeSelector("leftEdge.Payload", "rightEdge.Payload")));
            this.Write("\r\n        output.hash.col[index] = hash;\r\n\r\n        if (output.Count == Config.Da" +
                    "taBatchSize) FlushContents();\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.Aggres" +
                    "siveInlining)]\r\n    private void AddToBatch(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(" leftBatch, int leftIndex, ref ActiveEdgeRight rightEdge, int hash)\r\n    {\r\n     " +
                    "   int index = output.Count++;\r\n        output.vsync.col[index] = start;\r\n      " +
                    "  output.vother.col[index] = end;\r\n        output.key.col[index] = key;\r\n       " +
                    " ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftBatchSelector("leftBatch", "leftIndex", "rightEdge.Payload")));
            this.Write("\r\n        output.hash.col[index] = hash;\r\n\r\n        if (output.Count == Config.Da" +
                    "taBatchSize) FlushContents();\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.Aggres" +
                    "siveInlining)]\r\n    private bool AreLeftSame(long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(" leftBatch, int leftIndex, ref ActiveEdgeLeft active)\r\n    {\r\n        return star" +
                    "t == active.Start && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "active.Key")));
            this.Write(" && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(leftComparerEquals("leftBatch", "active.Payload")));
            this.Write(";\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    private b" +
                    "ool AreRightSame(long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(" rightBatch, int rightIndex, ref ActiveEdgeRight active)\r\n    {\r\n        return s" +
                    "tart == active.Start && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparerEquals("key", "active.Key")));
            this.Write(" && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(rightComparerEquals("rightBatch", "active.Payload")));
            this.Write(";\r\n    }\r\n\r\n    protected override void FlushContents()\r\n    {\r\n        if (outpu" +
                    "t.Count == 0) return;\r\n        output.Seal();\r\n        this.Observer.OnNext(outp" +
                    "ut);\r\n        GetOutputBatch();\r\n    }\r\n\r\n");
 if (!this.leftType.GetTypeInfo().IsValueType) { 
            this.Write("    [DataContract]\r\n    private struct ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventTypeLeft));
            this.Write("\r\n    {\r\n        ");
 foreach (var f in this.leftFields) { 
            this.Write("        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n        ");
 } 
            this.Write("    }\r\n");
 } 
 if (!this.rightType.GetTypeInfo().IsValueType) { 
            this.Write("    [DataContract]\r\n    private struct ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventTypeRight));
            this.Write("\r\n    {\r\n        ");
 foreach (var f in this.rightFields) { 
            this.Write("        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n        ");
 } 
            this.Write("    }\r\n");
 } 
            this.Write("\r\n    [DataContract]\r\n    private struct ActiveIntervalLeft\r\n    {\r\n        [Data" +
                    "Member]\r\n        public long Start;\r\n        [DataMember]\r\n        public long E" +
                    "nd;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventTypeLeft));
            this.Write(" Payload;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        " +
                    "public void Populate(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(" batch, int index)\r\n        {\r\n            Start = start;\r\n            End = end;" +
                    "\r\n            Key = key;\r\n\r\n");
 if (this.leftMessageRepresentation.noFields) { 
            this.Write("            this.Payload = batch.payload.col[index];\r\n");
 } else { 
     foreach (var f in this.leftFields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
 } 
            this.Write(@"
        }

        public override string ToString()
        {
            return ""[Start="" + Start + "", End="" + End + "", Key='"" + Key + ""', Payload='"" + ""']"";
        }
    }

    [DataContract]
    private struct ActiveIntervalRight
    {
        [DataMember]
        public long Start;
        [DataMember]
        public long End;
        [DataMember]
        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventTypeRight));
            this.Write(" Payload;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        " +
                    "public void Populate(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(" batch, int index)\r\n        {\r\n            Start = start;\r\n            End = end;" +
                    "\r\n            Key = key;\r\n\r\n");
 if (this.rightMessageRepresentation.noFields) { 
            this.Write("            this.Payload = batch.payload.col[index];\r\n");
 } else { 
     foreach (var f in this.rightFields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
 } 
            this.Write(@"
        }

        public override string ToString()
        {
            return ""[Start="" + Start + "", End="" + End + "", Key='"" + Key + ""', Payload='"" + ""']"";
        }
    }

    [DataContract]
    private struct ActiveEdgeLeft
    {
        [DataMember]
        public long Start;
        [DataMember]
        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventTypeLeft));
            this.Write(" Payload;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        " +
                    "public void Populate(long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(LeftBatchType));
            this.Write(" batch, int index)\r\n        {\r\n            Start = start;\r\n            Key = key;" +
                    "\r\n\r\n");
 if (this.leftMessageRepresentation.noFields) { 
            this.Write("            this.Payload = batch.payload.col[index];\r\n");
 } else { 
     foreach (var f in this.leftFields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
 } 
            this.Write(@"
        }

        public override string ToString()
        {
            return ""[Start="" + Start + "", Key='"" + Key + ""', Payload='"" + ""']"";
        }
    }

    [DataContract]
    private struct ActiveEdgeRight
    {
        [DataMember]
        public long Start;
        [DataMember]
        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventTypeRight));
            this.Write(" Payload;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        " +
                    "public void Populate(long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(RightBatchType));
            this.Write(" batch, int index)\r\n        {\r\n            Start = start;\r\n            Key = key;" +
                    "\r\n\r\n");
 if (this.rightMessageRepresentation.noFields) { 
            this.Write("            this.Payload = batch.payload.col[index];\r\n");
 } else { 
     foreach (var f in this.rightFields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
 } 
            this.Write("\r\n        }\r\n\r\n        public override string ToString()\r\n        {\r\n            " +
                    "return \"[Start=\" + Start + \", Key=\'\" + Key + \"\', Payload=\'\" + \"\']\";\r\n        }\r\n" +
                    "    }\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
}
