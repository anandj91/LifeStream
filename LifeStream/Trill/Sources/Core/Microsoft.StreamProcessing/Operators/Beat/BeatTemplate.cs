// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System.Reflection;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class BeatTemplate : CommonUnaryTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;

// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TPayload: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("\r\n\r\n[DataContract]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" : UnaryPipe<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">\r\n{\r\n    private readonly MemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> pool;\r\n    private readonly Func<PlanNode, IQueryObject, PlanNode> queryPlanGen" +
                    "erator;\r\n\r\n    [SchemaSerialization]\r\n    private readonly long offset;\r\n    [Sc" +
                    "hemaSerialization]\r\n    private readonly long period;\r\n\r\n    private StreamMessa" +
                    "ge<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> genericOutputBatch;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(@" output;

    [DataMember]
    private FastMap<ActiveInterval> intervals = new FastMap<ActiveInterval>();
    [DataMember]
    private FastMap<ActiveEdge> edges = new FastMap<ActiveEdge>();
    [DataMember]
    private long currBeatTime = long.MinValue;
    [DataMember]
    private long lastTime = long.MinValue;
    [DataMember]
    private int batchIter;

    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    [Obsolete(\"Used only by serialization. Do not call directly.\")]\r\n    publ" +
                    "ic ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(@"> observer,
        Func<PlanNode, IQueryObject, PlanNode> queryPlanGenerator,
        long offset,
        long period)
        : base(stream, observer)
    {
        this.offset = offset;
        this.period = period;
        this.queryPlanGenerator = queryPlanGenerator;

        this.pool = MemoryManager.GetMemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">(true /*stream.Properties.IsColumnar*/);\r\n        GetOutputBatch();\r\n    }\r\n\r\n  " +
                    "  private void GetOutputBatch()\r\n    {\r\n        pool.Get(out genericOutputBatch)" +
                    ";\r\n        genericOutputBatch.Allocate();\r\n        output = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(")genericOutputBatch;\r\n");
 foreach (var f in this.fields.Where(fld => fld.OptimizeString())) {  
            this.Write("\r\n        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Initialize();\r\n");
 } 
            this.Write("   }\r\n\r\n    public override unsafe void OnNext(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> genericBatch)\r\n    {\r\n        var batch = genericBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(";\r\n\r\n        batchIter = batch.iter;\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("[] sourceKey = batch.key.col;\r\n        fixed (int* sourceHash = batch.hash.col)\r\n" +
                    "        fixed (long* sourceBitVector = batch.bitvector.col)\r\n        fixed (long" +
                    "* sourceVSync = batch.vsync.col)\r\n        fixed (long* sourceVOther = batch.voth" +
                    "er.col)\r\n        {\r\n            int count = batch.Count;\r\n            int* sourc" +
                    "eHashPtr = sourceHash;\r\n            long* sourceVSyncPtr = sourceVSync;\r\n       " +
                    "     long* sourceVOtherPtr = sourceVOther;\r\n            for (int row = 0; row < " +
                    "count; row++)\r\n            {\r\n                if ((sourceBitVector[row >> 6] & (" +
                    "1L << (row & 0x3f))) == 0 || *sourceVOtherPtr == long.MinValue)\r\n               " +
                    " {\r\n                    long startTime = *sourceVSyncPtr;\r\n                    l" +
                    "ong endTime = *sourceVOtherPtr;\r\n                    int hash = *sourceHashPtr;\r" +
                    "\n\r\n                    AdvanceTime(startTime);\r\n\r\n                    bool isPun" +
                    "ctuation = endTime == long.MinValue;\r\n                    bool isInsert = startT" +
                    "ime < endTime;\r\n                    bool isStartEdge = isInsert && endTime == St" +
                    "reamEvent.InfinitySyncTime;\r\n                    bool isEndEdge = !isInsert;\r\n  " +
                    "                  if (isPunctuation)\r\n                    {\r\n                   " +
                    "     AddToBatch(startTime, long.MinValue, ref sourceKey[row], ref sourcePayload[" +
                    "row], hash);\r\n                    }\r\n                    else if (isStartEdge)\r\n" +
                    "                    {\r\n                        // Add starting edge { vSync = st" +
                    "artTime, vOther = StreamEvent.InfinitySyncTime }.\r\n                        AddTo" +
                    "Batch(\r\n                            startTime,\r\n                            Stre" +
                    "amEvent.InfinitySyncTime,\r\n                            ref sourceKey[row],\r\n    " +
                    "                        /* ref sourcePayload[row], */\r\n                         " +
                    "   batch, row,\r\n                            hash);\r\n\r\n                        //" +
                    " Add to active edges list to handle repeat at beats (and waiting for closing edg" +
                    "e).\r\n                        int index = edges.Insert(hash);\r\n                  " +
                    "      edges.Values[index].Populate(batch, row);\r\n                    }\r\n        " +
                    "            else if (isEndEdge)\r\n                    {\r\n                        " +
                    "bool notCurrentlyOnBeat = startTime != currBeatTime;\r\n                        lo" +
                    "ng edgeStartTime = endTime;\r\n                        long edgeEndTime = startTim" +
                    "e;\r\n                        if (notCurrentlyOnBeat)\r\n                        {\r\n" +
                    "                            // Edges are only open if not on a beat.\r\n          " +
                    "                  long lastBeatTime = currBeatTime - period;\r\n                  " +
                    "          bool edgeStartedBeforeLastBeat = edgeStartTime < lastBeatTime;\r\n\r\n    " +
                    "                        if (edgeStartedBeforeLastBeat)\r\n                        " +
                    "    {\r\n                                // Add closing edge { vSync = edgeEndTime" +
                    ", vOther = lastBeatTime }.\r\n                                AddToBatch(\r\n       " +
                    "                             edgeEndTime,\r\n                                    l" +
                    "astBeatTime,\r\n                                    ref sourceKey[row],\r\n         " +
                    "                           /* ref sourcePayload[row], */\r\n                      " +
                    "              batch, row,\r\n                                    hash);\r\n         " +
                    "                   }\r\n                            else\r\n                        " +
                    "    {\r\n                                // Add closing edge { vSync = edgeEndTime" +
                    ", vOther = edgeStartTime }.\r\n                                AddToBatch(\r\n      " +
                    "                              edgeEndTime,\r\n                                    " +
                    "edgeStartTime,\r\n                                    ref sourceKey[row],\r\n       " +
                    "                             /* ref sourcePayload[row], */\r\n                    " +
                    "                batch, row,\r\n                                    hash);\r\n       " +
                    "                     }\r\n                        }\r\n\r\n                        // " +
                    "Remove from active edges list.\r\n                        var edgesTraversal = edg" +
                    "es.Find(hash);\r\n                        int index;\r\n                        whil" +
                    "e (edgesTraversal.Next(out index))\r\n                        {\r\n                 " +
                    "           var edge = edges.Values[index];\r\n                            if (AreS" +
                    "ame(edgeStartTime, ref sourceKey[row], /*ref sourcePayload[row] */ batch, row, e" +
                    "dge))\r\n                            {\r\n                                edgesTrave" +
                    "rsal.Remove();\r\n                                break;\r\n                        " +
                    "    }\r\n                        }\r\n                    }\r\n                    els" +
                    "e\r\n                    {\r\n                        long nextBeatTime = startTime " +
                    "== currBeatTime ? currBeatTime + period : currBeatTime;\r\n                       " +
                    " bool isLastBeatForInterval = endTime <= nextBeatTime;\r\n\r\n                      " +
                    "  if (isLastBeatForInterval)\r\n                        {\r\n                       " +
                    "     // Add interval { vSync = startTime, vOther = endTime }.\r\n                 " +
                    "           AddToBatch(startTime, endTime, ref sourceKey[row], /* ref sourcePaylo" +
                    "ad[row] */ batch, row, hash);\r\n\r\n                            // No need to add t" +
                    "o active list as interval ends <= nextBeatTime.\r\n                        }\r\n    " +
                    "                    else\r\n                        {\r\n                           " +
                    " // Add interval { vSync = startTime, vOther = nextBeatTime }.\r\n                " +
                    "            AddToBatch(startTime, nextBeatTime, ref sourceKey[row], /* ref sourc" +
                    "ePayload[row] */ batch, row, hash);\r\n\r\n                            // Add to act" +
                    "ive list to handle repeat at beats.\r\n                            int index = int" +
                    "ervals.Insert(hash);\r\n                            intervals.Values[index].Popula" +
                    "te(batch, row);\r\n                        }\r\n                    }\r\n             " +
                    "   }\r\n\r\n                // Advance pointers.\r\n                sourceHashPtr++;\r\n" +
                    "                sourceVSyncPtr++;\r\n                sourceVOtherPtr++;\r\n         " +
                    "   }\r\n        }\r\n\r\n        batch.Free();\r\n    }\r\n\r\n    public override void Prod" +
                    "uceQueryPlan(PlanNode previous)\r\n    {\r\n        Observer.ProduceQueryPlan(queryP" +
                    "lanGenerator(previous, this));\r\n    }\r\n\r\n    protected override void DisposeStat" +
                    "e() => this.output.Free();\r\n\r\n    public override int CurrentlyBufferedOutputCou" +
                    "nt => output.Count;\r\n\r\n    public override int CurrentlyBufferedInputCount => ed" +
                    "ges.Count + intervals.Count;\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInli" +
                    "ning)]\r\n    private void AdvanceTime(long time)\r\n    {\r\n        if (time == last" +
                    "Time || time < currBeatTime)\r\n        {\r\n            // Time has not changed or " +
                    "has not yet reached beat.\r\n            return;\r\n        }\r\n\r\n        if (time >=" +
                    " StreamEvent.InfinitySyncTime)\r\n        {\r\n            // If advancing time to i" +
                    "nfinity, verify no open edges.\r\n            if (!edges.IsEmpty)\r\n            {\r\n" +
                    "                throw new InvalidOperationException(\"Cannot advance time to infi" +
                    "nity if unclosed open edges\");\r\n            }\r\n        }\r\n\r\n        if (edges.Is" +
                    "Empty && intervals.IsEmpty)\r\n        {\r\n            // No elements to track, so " +
                    "just advance time to next beat.\r\n            currBeatTime = FindNextBeatGreaterT" +
                    "hanOrEqualTo(time);\r\n            lastTime = time;\r\n            return;\r\n        " +
                    "}\r\n\r\n        // currTime must be >= currBeatTime AND lastTime must be <= currBea" +
                    "tTime, so we have definitely\r\n        // reached or surpassed a beat.\r\n        i" +
                    "f (lastTime < currBeatTime)\r\n        {\r\n            // This is the first time re" +
                    "aching the time currBeatTime, so handle reaching a beat.\r\n            ReachBeat(" +
                    "currBeatTime);\r\n\r\n            if (edges.IsEmpty && intervals.IsEmpty)\r\n         " +
                    "   {\r\n                // No elements to track, so just advance time to next beat" +
                    ".\r\n                currBeatTime = FindNextBeatGreaterThanOrEqualTo(time);\r\n     " +
                    "           lastTime = time;\r\n                return;\r\n            }\r\n        }\r\n" +
                    "\r\n        // By this point, we have definitely reached currBeatTime although may" +
                    " or may not have surpassed it.\r\n        while (time >= currBeatTime + period)\r\n " +
                    "       {\r\n            // We are guaranteed there are no events within (currBeatT" +
                    "ime, currBeatTime + period) because\r\n            // lastTime must be <= currBeat" +
                    "Time and time is >= currBeatTime + period. Note there could have\r\n            //" +
                    " been edges at currBeatTime or edges to still come at currBeatTime + period, how" +
                    "ever.\r\n\r\n            // Regardless, we can optimize edges to output as intervals" +
                    " for (currBeatTime, currBeatTime + period).\r\n            LeaveBeatContinuousToNe" +
                    "xt(currBeatTime);\r\n            currBeatTime += period;\r\n            ReachBeatCon" +
                    "tinuousFromLast(currBeatTime);\r\n\r\n            if (edges.IsEmpty && intervals.IsE" +
                    "mpty)\r\n            {\r\n                // No elements to track, so just advance t" +
                    "ime to next beat.\r\n                currBeatTime = FindNextBeatGreaterThanOrEqual" +
                    "To(time);\r\n                lastTime = time;\r\n                return;\r\n          " +
                    "  }\r\n        }\r\n\r\n        // By this point, the loop guarantees that: currBeatTi" +
                    "me <= time < currBeatTime + period\r\n        if (time > currBeatTime)\r\n        {\r" +
                    "\n            // time has passed the beat at currBeatTime, so handle the beat.\r\n " +
                    "           LeaveBeat(currBeatTime);\r\n            currBeatTime += period;\r\n      " +
                    "  }\r\n\r\n        // By this point, time must be <= currBeatTime.\r\n        lastTime" +
                    " = time;\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    p" +
                    "rivate void ReachBeat(long beatTime)\r\n    {\r\n        long lastBeatTime = beatTim" +
                    "e - period;\r\n        long nextBeatTime = beatTime + period;\r\n\r\n        // Close " +
                    "all active edges.\r\n        var edgeTraverser = edges.Traverse();\r\n        int in" +
                    "dex;\r\n        int hash;\r\n        while (edgeTraverser.Next(out index, out hash))" +
                    "\r\n        {\r\n            long edgeStartTime = edges.Values[index].Start;\r\n      " +
                    "      bool edgeStartedBeforeLastBeat = edgeStartTime < lastBeatTime;\r\n\r\n        " +
                    "    if (edgeStartedBeforeLastBeat)\r\n            {\r\n                // Add closin" +
                    "g edge { vSync = beatTime, vOther = lastBeatTime }.\r\n                AddToBatch(" +
                    "beatTime, lastBeatTime, edges.Values[index].Key, edges.Values[index], hash);\r\n  " +
                    "          }\r\n            else\r\n            {\r\n                // Add closing edg" +
                    "e { vSync = beatTime, vOther = edge.Start }.\r\n                AddToBatch(beatTim" +
                    "e, edgeStartTime, edges.Values[index].Key, edges.Values[index], hash);\r\n        " +
                    "    }\r\n        }\r\n\r\n        // Add all active intervals.\r\n        var intervalTr" +
                    "averser = intervals.Traverse();\r\n        while (intervalTraverser.Next(out index" +
                    ", out hash))\r\n        {\r\n            long intervalEndTime = intervals.Values[ind" +
                    "ex].End;\r\n            bool isLastBeatForInterval = intervalEndTime <= nextBeatTi" +
                    "me;\r\n\r\n            if (isLastBeatForInterval)\r\n            {\r\n                //" +
                    " Add interval { vSync = beatTime, vOther = interval.End }.\r\n                var " +
                    "interval = intervals.Values[index];\r\n                AddToBatch(beatTime, interv" +
                    "alEndTime, intervals.Values[index].Key, interval, hash);\r\n\r\n                // R" +
                    "emove from active list as no longer need to output.\r\n                intervalTra" +
                    "verser.Remove();\r\n            }\r\n            else\r\n            {\r\n              " +
                    "  // Add interval { vSync = beatTime, vOther = nextBeatTime }.\r\n                " +
                    "AddToBatch(beatTime, nextBeatTime, intervals.Values[index].Key, intervals.Values" +
                    "[index], hash);\r\n            }\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOp" +
                    "tions.AggressiveInlining)]\r\n    private void LeaveBeat(long beatTime)\r\n    {\r\n  " +
                    "      // Open all active edges (that weren\'t added during this beat).\r\n        v" +
                    "ar edgeTraverser = edges.Traverse();\r\n        int index;\r\n        int hash;\r\n   " +
                    "     while (edgeTraverser.Next(out index, out hash))\r\n        {\r\n            boo" +
                    "l edgeWasAddedPriorToBeat = edges.Values[index].Start < beatTime;\r\n\r\n           " +
                    " if (edgeWasAddedPriorToBeat)\r\n            {\r\n                // Add starting ed" +
                    "ge { vSync = beatTime, vOther = StreamEvent.InfinitySyncTime }.\r\n               " +
                    " AddToBatch(beatTime, StreamEvent.InfinitySyncTime, edges.Values[index].Key, edg" +
                    "es.Values[index], hash);\r\n            }\r\n        }\r\n    }\r\n\r\n    [MethodImpl(Met" +
                    "hodImplOptions.AggressiveInlining)]\r\n    private void LeaveBeatContinuousToNext(" +
                    "long beatTime)\r\n    {\r\n        long nextBeatTime = beatTime + period;\r\n\r\n       " +
                    " // Make intervals for all active edges (that weren\'t added during this beat).\r\n" +
                    "        var edgeTraverser = edges.Traverse();\r\n        int index;\r\n        int h" +
                    "ash;\r\n        while (edgeTraverser.Next(out index, out hash))\r\n        {\r\n      " +
                    "      bool edgeWasAddedPriorToBeat = edges.Values[index].Start < beatTime;\r\n\r\n  " +
                    "          if (edgeWasAddedPriorToBeat)\r\n            {\r\n                // Add in" +
                    "terval for edge { vSync = beatTime, vOther = nextBeatTime }.\r\n                Ad" +
                    "dToBatch(beatTime, nextBeatTime, edges.Values[index].Key, edges.Values[index], h" +
                    "ash);\r\n            }\r\n            else\r\n            {\r\n                // Denote" +
                    " edges that were added at beat because they have already outputted a start edge." +
                    "\r\n                edgeTraverser.MakeInvisible();\r\n            }\r\n        }\r\n\r\n  " +
                    "      // Output corresponding end edges for all start edges.\r\n        var invisi" +
                    "bleTraverser = edges.TraverseInvisible();\r\n        while (invisibleTraverser.Nex" +
                    "t(out index, out hash))\r\n        {\r\n            // Add closing edge { vSync = ne" +
                    "xtBeatTime, vOther = beatTime }.\r\n            AddToBatch(nextBeatTime, beatTime," +
                    " edges.Values[index].Key, edges.Values[index], hash);\r\n            invisibleTrav" +
                    "erser.MakeVisible();\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.Aggr" +
                    "essiveInlining)]\r\n    private void ReachBeatContinuousFromLast(long beatTime)\r\n " +
                    "   {\r\n        long nextBeatTime = beatTime + period;\r\n\r\n        // Add all activ" +
                    "e intervals.\r\n        var intervalTraverser = intervals.Traverse();\r\n        int" +
                    " index;\r\n        int hash;\r\n        while (intervalTraverser.Next(out index, out" +
                    " hash))\r\n        {\r\n            long intervalEndTime = intervals.Values[index].E" +
                    "nd;\r\n            bool isLastBeatForInterval = intervalEndTime <= nextBeatTime;\r\n" +
                    "\r\n            if (isLastBeatForInterval)\r\n            {\r\n                // Add " +
                    "interval { vSync = beatTime, vOther = interval.End }.\r\n                var inter" +
                    "val = intervals.Values[index];\r\n                AddToBatch(beatTime, intervalEnd" +
                    "Time, intervals.Values[index].Key, interval, hash);\r\n\r\n                // Remove" +
                    " from active list as no longer need to output.\r\n                intervalTraverse" +
                    "r.Remove();\r\n            }\r\n            else\r\n            {\r\n                // " +
                    "Add interval { vSync = beatTime, vOther = nextBeatTime }.\r\n                AddTo" +
                    "Batch(beatTime, nextBeatTime, intervals.Values[index].Key, intervals.Values[inde" +
                    "x], hash);\r\n            }\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions" +
                    ".AggressiveInlining)]\r\n    private long FindNextBeatGreaterThanOrEqualTo(long ti" +
                    "me)\r\n    {\r\n        long multiple = (time - offset + period - 1) / period;\r\n    " +
                    "    return (multiple * period) + offset;\r\n    }\r\n\r\n    [MethodImpl(MethodImplOpt" +
                    "ions.AggressiveInlining)]\r\n    private void AddToBatch(long start, long end, ref" +
                    " ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, /* ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(" payload */ ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(" batch, int batchIndex, int hash)\r\n    {\r\n        int index = output.Count++;\r\n  " +
                    "      output.vsync.col[index] = start;\r\n        output.vother.col[index] = end;\r" +
                    "\n        output.key.col[index] = key;\r\n        /* output.payload.col[index] = pa" +
                    "yload; */\r\n");
     foreach (var f in this.fields) { 
       if (f.OptimizeString()) { 
            this.Write("\r\n        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write("[batchIndex]);\r\n");
       } else { 
            this.Write("        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[index] = batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[batchIndex];\r\n");
       } 
     } 
            this.Write(@"
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize)
        {
            output.iter = batchIter;
            this.Observer.OnNext(output);
            GetOutputBatch();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ActiveEdge edge, int hash)\r\n    {\r\n        int index = output.Count++;\r\n   " +
                    "     output.vsync.col[index] = start;\r\n        output.vother.col[index] = end;\r\n" +
                    "        output.key.col[index] = key;\r\n        /* output.payload.col[index] = pay" +
                    "load; */\r\n");
     foreach (var f in this.fields) {
         var sourceName = "edge.Payload";
         if (!noFields) sourceName += "." + f.OriginalName;

       if (f.OptimizeString()) { 
            this.Write("\r\n        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceName));
            this.Write(");\r\n");
       } else { 
            this.Write("        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[index] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceName));
            this.Write(";\r\n");
       } 
     } 
            this.Write(@"
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize)
        {
            output.iter = batchIter;
            this.Observer.OnNext(output);
            GetOutputBatch();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@" key, ActiveInterval interval, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        /* output.payload.col[index] = payload; */
");
     foreach (var f in this.fields) {
         var sourceName = "interval.Payload";
         if (!noFields) sourceName += "." + f.OriginalName;

       if (f.OptimizeString()) { 
            this.Write("\r\n        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceName));
            this.Write(");\r\n");
       } else { 
            this.Write("        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[index] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceName));
            this.Write(";\r\n");
       } 
     } 
            this.Write(@"
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize)
        {
            output.iter = batchIter;
            this.Observer.OnNext(output);
            GetOutputBatch();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool AreSame(long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(" batch, int index, ActiveEdge active)\r\n    {\r\n        return start == active.Star" +
                    "t && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparer("key", "active.Key")));
            this.Write(" && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(payloadComparer("batch", "active.Payload")));
            this.Write(";\r\n    }\r\n\r\n    protected override void FlushContents()\r\n    {\r\n        if (outpu" +
                    "t.Count == 0) return;\r\n        this.Observer.OnNext(output);\r\n        GetOutputB" +
                    "atch();\r\n    }\r\n\r\n");
 if (!noFields && !this.payloadType.GetTypeInfo().IsValueType) { 
            this.Write("    [DataContract]\r\n    private struct ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write("\r\n    {\r\n        ");
 foreach (var f in this.fields) { 
            this.Write("        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n        ");
 } 
            this.Write("    }\r\n");
 } 
            this.Write("\r\n    [DataContract]\r\n    private struct ActiveInterval\r\n    {\r\n        [DataMemb" +
                    "er]\r\n        public long End;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write(" Payload;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        " +
                    "public void Populate(");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(" batch, int index)\r\n        {\r\n            End = batch.vother.col[index];\r\n      " +
                    "      Key = batch.key.col[index];\r\n");
 if (this.noFields) { 
            this.Write("            this.Payload = batch.payload.col[index];\r\n");
 } else { 
     foreach (var f in this.fields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
 } 
            this.Write(@"        }

        public override string ToString()
        {
            return ""[End="" + End + "", Key='"" + Key + ""', Payload='"" +  ""']"";
        }
    }

    [DataContract]
    private struct ActiveEdge
    {
        [DataMember]
        public long Start;
        [DataMember]
        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write(" Payload;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        " +
                    "public void Populate(");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(" batch, int index)\r\n        {\r\n            Start = batch.vsync.col[index];\r\n     " +
                    "       Key = batch.key.col[index];\r\n");
 if (this.noFields) { 
            this.Write("            this.Payload = batch.payload.col[index];\r\n");
 } else { 
     foreach (var f in this.fields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
 } 
            this.Write("        }\r\n\r\n        public override string ToString()\r\n        {\r\n            re" +
                    "turn \"[Start=\" + Start + \", Key=\'\" + Key + \"\', Payload=\'\" + \"\']\";\r\n        }\r\n  " +
                    "  }\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
}
