// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class ClipByConstantTemplate : CommonUnaryTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;

// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TPayload: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("\r\n\r\n[DataContract]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" : UnaryPipe<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">\r\n{\r\n    private readonly MemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> pool;\r\n    private readonly Func<PlanNode, IQueryObject, PlanNode> queryPlanGen" +
                    "erator;\r\n\r\n    [SchemaSerialization]\r\n    private readonly long limit;\r\n\r\n    pr" +
                    "ivate StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> genericOutputBatch;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" output;\r\n\r\n    [DataMember]\r\n    private long lastSyncTime = long.MinValue;\r\n   " +
                    " [DataMember]\r\n    private SortedDictionary<long, MultiSet<ActiveEvent>> syncTim" +
                    "eMap = new SortedDictionary<long, MultiSet<ActiveEvent>>();\r\n\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    [Obsolete(\"Used only by serialization. Do not call directly.\")]\r\n    publ" +
                    "ic ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> observer,\r\n        Func<PlanNode, IQueryObject, PlanNode> queryPlanGenerator,\r\n" +
                    "        long limit)\r\n        : base(stream, observer)\r\n    {\r\n        this.limit" +
                    " = limit;\r\n        pool = MemoryManager.GetMemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(@">(true /*stream.Properties.IsColumnar*/);
        this.queryPlanGenerator = queryPlanGenerator;
        GetOutputBatch();
    }

    private void GetOutputBatch()
    {
        pool.Get(out genericOutputBatch);
        genericOutputBatch.Allocate();
        output = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(")genericOutputBatch;\r\n");
 foreach (var f in this.fields.Where(fld => fld.OptimizeString())) {  
            this.Write("\r\n        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Initialize();\r\n");
 } 
            this.Write(@"   }

    public override void ProduceQueryPlan(PlanNode previous)
    {
        Observer.ProduceQueryPlan(queryPlanGenerator(previous, this));
    }

    private void ReachTime(long timestamp)
    {
        List<long> toDelete = new List<long>();
        foreach (var kvp in syncTimeMap)
        {
            if (timestamp < kvp.Key + limit) break;

            foreach (var ae in kvp.Value.GetEnumerable())
            {
                int ind = output.Count++;
                output.vsync.col[ind] = kvp.Key + limit;
                output.vother.col[ind] = kvp.Key;
                output.key.col[ind] = ae.Key;
");
     foreach (var f in this.fields) { 
       if (f.OptimizeString()) { 
            this.Write("\r\n                output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(ae.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(");\r\n");
       } else { 
            this.Write("                output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[ind] = ae.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(";\r\n");
       } 
     } 
            this.Write(@"                output.hash.col[ind] = ae.Hash;

                if (output.Count == Config.DataBatchSize)
                {
                    output.Seal();
                    this.Observer.OnNext(output);
                    GetOutputBatch();
                }
            }

            toDelete.Add(kvp.Key);
        }

        foreach (var l in toDelete) syncTimeMap.Remove(l);
        lastSyncTime = timestamp;
    }

    public override unsafe void OnNext(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> genericBatch)\r\n    {\r\n        var batch = genericBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(@";
        var count = batch.Count;

        fixed (long* bv = batch.bitvector.col)
        {
            for (int i = 0; i < count; i++)
            {
                if ((bv[i >> 6] & (1L << (i & 0x3f))) == 0)
                {
                    ReachTime(batch.vsync.col[i]);

                    if (batch.vother.col[i] == StreamEvent.InfinitySyncTime)
                    {
                        // For start events, we copy directly to the output batch
                        // and add them to the list of events that may need to be clipped
                        int ind = output.Count++;
                        var sync = batch.vsync.col[i];
                        output.vsync.col[ind] = sync;
                        output.vother.col[ind] = StreamEvent.InfinitySyncTime;
                        output.key.col[ind] = batch.key.col[i];
");
     foreach (var f in this.fields) { 
       if (f.OptimizeString()) { 
            this.Write("                        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write("[i]);\r\n");
       } else { 
            this.Write("                        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[ind] = batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[i];\r\n");
       } 
     } 
            this.Write(@"                        output.hash.col[ind] = batch.hash.col[i];

                        if (output.Count == Config.DataBatchSize) FlushContents();

                        MultiSet<ActiveEvent> multiSet;
                        if (!syncTimeMap.TryGetValue(sync, out multiSet))
                        {
                            multiSet = new MultiSet<ActiveEvent>();
                            syncTimeMap.Add(sync, multiSet);
                        }
                        var activeEvent = new ActiveEvent();
                        activeEvent.Populate(batch.key.col[i], batch, i, batch.hash.col[i]);
                        multiSet.Add(activeEvent);
                    }
                    else if (batch.vother.col[i] > batch.vsync.col[i])
                    {
                        // For intervals, we clip the limit and copy to the output batch
                        int ind = output.Count++;
                        output.vsync.col[ind] = batch.vsync.col[i];
                        output.vother.col[ind] = Math.Min(batch.vother.col[i], batch.vsync.col[i] + limit);
                        output.key.col[ind] = batch.key.col[i];
");
     foreach (var f in this.fields) { 
       if (f.OptimizeString()) { 
            this.Write("                        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write("[i]);\r\n");
       } else { 
            this.Write("                        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[ind] = batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[i];\r\n");
       } 
     } 
            this.Write(@"                        output.hash.col[ind] = batch.hash.col[i];

                        if (output.Count == Config.DataBatchSize) FlushContents();
                    }
                    else
                    {
                        var sync = batch.vsync.col[i];
                        var other = batch.vother.col[i];

                        // For end edges, if the delta is greater than the limit, then ignore,
                        // otherwise copy directly over
                        if (other + limit <= sync) continue;

                        var payload = batch[i];
                        int ind = output.Count++;
                        output.vsync.col[ind] = sync;
                        output.vother.col[ind] = other;
                        output.key.col[ind] = batch.key.col[i];
");
     foreach (var f in this.fields) { 
       if (f.OptimizeString()) { 
            this.Write("                        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write("[i]);\r\n");
       } else { 
            this.Write("                        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[ind] = batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[i];\r\n");
       } 
     } 
            this.Write("                        output.hash.col[ind] = batch.hash.col[i];\r\n\r\n            " +
                    "            if (output.Count == Config.DataBatchSize) FlushContents();\r\n\r\n      " +
                    "                  // Remove the corresponding start edge from the waiting list\r\n" +
                    "                        var activeEvent = new ActiveEvent();\r\n                  " +
                    "      activeEvent.Populate(batch.key.col[i], batch, i, batch.hash.col[i]);\r\n    " +
                    "                    syncTimeMap[other].Remove(activeEvent);\r\n                   " +
                    "     if (syncTimeMap[other].IsEmpty) syncTimeMap.Remove(other);\r\n               " +
                    "     }\r\n                }\r\n                else if (batch.vother.col[i] == Strea" +
                    "mEvent.PunctuationOtherTime)\r\n                {\r\n                    ReachTime(b" +
                    "atch.vsync.col[i]);\r\n\r\n                    int ind = output.Count++;\r\n          " +
                    "          output.vsync.col[ind] = batch.vsync.col[i];\r\n                    outpu" +
                    "t.vother.col[ind] = StreamEvent.PunctuationOtherTime;\r\n                    outpu" +
                    "t.key.col[ind] = default;\r\n                    output[ind] = default;\r\n         " +
                    "           output.hash.col[ind] = batch.hash.col[i];\r\n                    output" +
                    ".bitvector.col[ind >> 6] |= (1L << (ind & 0x3f));\r\n\r\n                    if (out" +
                    "put.Count == Config.DataBatchSize) FlushContents();\r\n                }\r\n        " +
                    "    }\r\n        }\r\n        batch.Free();\r\n    }\r\n\r\n    protected override void Fl" +
                    "ushContents()\r\n    {\r\n        if (output.Count == 0) return;\r\n        output.Sea" +
                    "l();\r\n        this.Observer.OnNext(output);\r\n        GetOutputBatch();\r\n    }\r\n\r" +
                    "\n    protected override void DisposeState() => this.output.Free();\r\n\r\n    public" +
                    " override int CurrentlyBufferedOutputCount => output.Count;\r\n\r\n    public overri" +
                    "de int CurrentlyBufferedInputCount => syncTimeMap.Values.Select(o => (int)o.Coun" +
                    "t).Sum();\r\n\r\n    [DataContract]\r\n    private struct ActiveEvent\r\n    {\r\n");
 foreach (var f in this.fields) { 
            this.Write("        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(";\r\n");
 } 
            this.Write("        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public int Hash;\r\n\r\n        public void Popu" +
                    "late(");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" batch, int index, int hash)\r\n        {\r\n            this.Key = key;\r\n");
 foreach (var f in this.fields) { 
            this.Write("            this.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
            this.Write("            this.Hash = hash;\r\n        }\r\n\r\n        public override string ToStri" +
                    "ng()\r\n        {\r\n            return \"Key=\'\" + Key + \"\', Payload=\'\"; // + Payload" +
                    ";\r\n        }\r\n    }\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
}
