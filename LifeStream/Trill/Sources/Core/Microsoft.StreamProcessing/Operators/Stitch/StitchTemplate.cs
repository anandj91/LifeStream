// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System.Reflection;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class StitchTemplate : CommonUnaryTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;
[assembly: IgnoresAccessChecksTo(""Microsoft.StreamProcessing"")]

// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TPayload: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("\r\n\r\n[DataContract]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" : UnaryPipe<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">\r\n{\r\n    // transient; don\'t need to contract it\r\n    private readonly DataStruc" +
                    "turePool<FastDictionary2<KHP, List<ActiveEvent>>> dictPool;\r\n    private readonl" +
                    "y MemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(@"> pool;
    private readonly Func<PlanNode, IQueryObject, PlanNode> queryPlanGenerator;

    [DataMember]
    private FastDictionary2<KHP, int> CurrentTimeOpenEventBuffer;

    [DataMember]
    private long CurrentTimeOpenEventBufferTime;

    private StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> genericOutputBatch;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(@" batch;

    [DataMember]
    private int outputCount;

    [DataMember]
    private long now = StreamEvent.MinSyncTime;

    // ok, to deal with multisets:
    // SCENARIO: we see an incoming payload. It's the same as an existing payload. We should clearly be matching
    // on PAYLOAD, KEY.
    // The VALUE version in this dictionary has the ORIGINAL, EARLY Start Time
    [DataMember]
    private FastDictionary2<KHP, List<ActiveEventExt>> OpenEvents = null;

    // This is a dictionary by time: It contains only elements that will expire in the future
    // The Purge event clears any events from the 'past' out
    // The End event moves an item from the OpenEvent to the ClosedEvent set
    [DataMember]
    private SortedDictionary<long, FastDictionary2<KHP, List<ActiveEvent>>> ClosedEvents =
        new SortedDictionary<long, FastDictionary2<KHP, List<ActiveEvent>>>();

    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    [Obsolete(\"Used only by serialization. Do not call directly.\")]\r\n    publ" +
                    "ic ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> observer,\r\n        Func<PlanNode, IQueryObject, PlanNode> queryPlanGenerator)\r\n" +
                    "        : base(stream, observer)\r\n    {\r\n        pool = MemoryManager.GetMemoryP" +
                    "ool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">(true /*stream.Properties.IsColumnar*/);\r\n        this.queryPlanGenerator = quer" +
                    "yPlanGenerator;\r\n        GetOutputBatch();\r\n\r\n        var khpcomparer = new Equa" +
                    "lityComparerExpression<KHP>(\r\n                (khp1, khp2) => ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.keyEquals("khp1", "khp2")));
            this.Write(" && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.payloadEquals("khp1.Payload", "khp2.Payload")));
            this.Write(",\r\n                (khp) => ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.keyHashFunction("khp")));
            this.Write(" ^ ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.payloadHashFunction("khp.Payload")));
            this.Write(@");
        var equals = khpcomparer.GetEqualsExpr().Compile();
        var getHashCode = khpcomparer.GetGetHashCodeExpr().Compile();
        var generator1 = khpcomparer.CreateFastDictionary2Generator<KHP, List<ActiveEvent>>(1, equals, getHashCode, stream.Properties.QueryContainer);
        var generator2 = khpcomparer.CreateFastDictionary2Generator<KHP, int>(1, equals, getHashCode, stream.Properties.QueryContainer);
        var generator3 = khpcomparer.CreateFastDictionary2Generator<KHP, List<ActiveEventExt>>(1, equals, getHashCode, stream.Properties.QueryContainer);
        dictPool = new DataStructurePool<FastDictionary2<KHP, List<ActiveEvent>>>(() => generator1.Invoke());
        CurrentTimeOpenEventBuffer = generator2.Invoke();
        OpenEvents = generator3.Invoke();
    }

    private void GetOutputBatch()
    {
        this.pool.Get(out genericOutputBatch);
        genericOutputBatch.Allocate();
        this.batch = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(")genericOutputBatch;\r\n");
 foreach (var f in this.fields.Where(fld => fld.OptimizeString())) {  
            this.Write("\r\n        this.batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Initialize();\r\n");
 } 
            this.Write(@"    outputCount = 0;
    }

    protected override void DisposeState()
    {
        this.batch.Free();
        this.dictPool.Dispose();
    }

    public override void ProduceQueryPlan(PlanNode previous)
    {
        Observer.ProduceQueryPlan(queryPlanGenerator(previous, this));
    }

");
 if (!noFields && !this.payloadType.GetTypeInfo().IsValueType) { 
            this.Write("    [DataContract]\r\n    private struct ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write("\r\n    {\r\n        ");
 foreach (var f in this.fields) { 
            this.Write("        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n        ");
 } 
            this.Write("    }\r\n");
 } 
            this.Write("\r\n    private struct ActiveEvent\r\n    {\r\n        public long Start;\r\n        publ" +
                    "ic long End;\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        public int Hash;\r\n\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write(@" Payload;

        public static ActiveEvent FromExt(ActiveEventExt item)
        {
            var rv = new ActiveEvent()
            {
                Start = item.OriginalStart,
                End = item.End,
                Key = item.Key,
                Hash = item.Hash,
                Payload = item.Payload,
            };
            return rv;
        }

        public override string ToString()
        {
            return ""[Start="" + Start + "", End="" + End + "", Key='"" + Key + ""', Payload='"" + ""']"";
        }
    }

    private struct ActiveEventExt
    {
        public long OriginalStart;
        public long Start;
        public long End;
        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        public int Hash;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write(" Payload;\r\n\r\n        public ActiveEventExt(long originalStart, long eventStart, l" +
                    "ong end, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" batch, int index)\r\n        {\r\n            OriginalStart = originalStart;\r\n      " +
                    "      Start = eventStart;\r\n            End = end;\r\n            Key = batch.key.c" +
                    "ol[index];\r\n            Hash = batch.hash.col[index];\r\n");
 if (this.noFields) { 
            this.Write("            this.Payload = batch.payload.col[index];\r\n");
 } else { 
     foreach (var f in this.fields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
 } 
            this.Write(@"        }

        public ActiveEventExt(long originalStart, long eventStart, long end, KHP khp)
        {
            OriginalStart = originalStart;
            Start = eventStart;
            End = end;
            Key = khp.Key;
            Hash = khp.Hash;
            this.Payload = khp.Payload;
        }

        public override string ToString()
        {
            return ""[OriginalStart="" + OriginalStart + "", Start="" + Start + "", End="" + End + "", Key='"" + Key + ""', Payload='"" + ""']"";
        }
    }

    private struct KHP
    {
        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        public int Hash;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write(" Payload;\r\n\r\n        public KHP(");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" batch, int index)\r\n        {\r\n            Key = batch.key.col[index];\r\n         " +
                    "   Hash = batch.hash.col[index];\r\n");
 if (this.noFields) { 
            this.Write("            this.Payload = batch.payload.col[index];\r\n");
 } else { 
     foreach (var f in this.fields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
 } 
            this.Write(@"        }

        public override string ToString()
        {
            return ""[Key='"" + Key + ""', Payload='"" + ""']"";
        }
    }

    protected override void FlushContents()
    {
        if (outputCount == 0) return;
        this.batch.Count = outputCount;
        this.Observer.OnNext(this.batch);
        GetOutputBatch();
    }

    public override int CurrentlyBufferedOutputCount => outputCount;

    public override int CurrentlyBufferedInputCount => OpenEvents.Count;

    public override unsafe void OnNext(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> genericInput)\r\n    {\r\n        var input = genericInput as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(";\r\n\r\n        var count = input.Count;\r\n\r\n        fixed (long* src_bv = input.bitv" +
                    "ector.col, src_vsync = input.vsync.col, src_vother = input.vother.col)\r\n        " +
                    "fixed (int* src_hash = input.hash.col)\r\n        {\r\n            long* vsync = src" +
                    "_vsync;\r\n            long* vother = src_vother;\r\n            int* hash = src_has" +
                    "h;\r\n\r\n            for (int i = 0; i < count; i++)\r\n            {\r\n              " +
                    "  if ((src_bv[i >> 6] & (1L << (i & 0x3f))) == 0 || *vother == StreamEvent.Punct" +
                    "uationOtherTime)\r\n                {\r\n                    var sync = input.vsync." +
                    "col[i];\r\n                    if (now < sync)\r\n                    {\r\n           " +
                    "             this.now = sync;\r\n                        Purge(this.now);\r\n       " +
                    "             }\r\n\r\n                    if (*vother == StreamEvent.InfinitySyncTim" +
                    "e)\r\n                    {\r\n                        ActOnStart(input, i, *vsync);" +
                    "\r\n                    }\r\n                    else if (*vother == StreamEvent.Pun" +
                    "ctuationOtherTime)\r\n                    {\r\n                        this.batch.vs" +
                    "ync.col[outputCount] = *vsync;\r\n                        this.batch.vother.col[ou" +
                    "tputCount] = StreamEvent.PunctuationOtherTime;\r\n                        this.bat" +
                    "ch[outputCount] = default;\r\n                        this.batch.key.col[outputCou" +
                    "nt] = default;\r\n                        this.batch.hash.col[outputCount] = 0;\r\n " +
                    "                       this.batch.bitvector.col[this.outputCount >> 6] |= 1L << " +
                    "(this.outputCount & 0x3f);\r\n                        outputCount++;\r\n\r\n          " +
                    "              if (outputCount == Config.DataBatchSize) FlushContents();\r\n       " +
                    "             }\r\n                    else if (*vsync < *vother)\r\n                " +
                    "    {\r\n                        ActOnStart(input, i, *vsync);\r\n                  " +
                    "      ActOnEnd(input, i, *vsync, *vother);\r\n                    }\r\n             " +
                    "       else\r\n                    {\r\n                        ActOnEnd(input, i, *" +
                    "vother, *vsync);\r\n                    }\r\n                }\r\n\r\n                vs" +
                    "ync++; vother++; hash++;\r\n            }\r\n        }\r\n\r\n        input.Free();\r\n   " +
                    " }\r\n\r\n    // The \"SkipBuffering\" tells us that we\'re at the end of a round, call" +
                    "ed from \"purge\". Rather than buffering this, we should\r\n    // just issue it as " +
                    "a begin event.\r\n    private void ActOnStart(");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" batch, int index, long eventstart, bool skipBuffering = false)\r\n    {\r\n        v" +
                    "ar lookupStart = new KHP(batch, index); // we look up start events by Hash, Key," +
                    " Payload\r\n        ActOnStartWithKHP(lookupStart, eventstart, skipBuffering);\r\n  " +
                    "  }\r\n\r\n    // The \"SkipBuffering\" tells us that we\'re at the end of a round, cal" +
                    "led from \"purge\". Rather than buffering this, we should\r\n    // just issue it as" +
                    " a begin event.\r\n    private void ActOnStartWithKHP(KHP lookupStart, long events" +
                    "tart, bool skipBuffering = false)\r\n    {\r\n        int indx = 0;\r\n\r\n        // We" +
                    " should match ONLY on\r\n        bool foundInClosedEvents =\r\n            ClosedEve" +
                    "nts.ContainsKey(eventstart) &&\r\n            ClosedEvents[eventstart].Lookup(look" +
                    "upStart, out indx);\r\n\r\n        if (foundInClosedEvents)\r\n        {\r\n            " +
                    "// reopen it! Make sure that we squirrel away the ORIGINAL start time as VALUE, " +
                    "and the MOST RECENT as the Key\r\n            var original = RemoveOne(ClosedEvent" +
                    "s[eventstart], lookupStart); //  .entries[indx].value; // this has the original " +
                    "start time\r\n            var originalExt = new ActiveEventExt(original.Start, eve" +
                    "ntstart, StreamEvent.InfinitySyncTime, lookupStart);\r\n\r\n            InsertOrAppe" +
                    "nd(OpenEvents, lookupStart, originalExt);\r\n\r\n        }\r\n        else\r\n        {\r" +
                    "\n            // We MIGHT match an open event. We need to search through anything" +
                    " that might be in\r\n            // OpenEvents[ lookupStart ] to see if it\'s there" +
                    ".\r\n            // Matching an \"open\" event means that we\'ve already got somethin" +
                    "g like\r\n            // BEGIN( Payload = P, Start = 0 )\r\n            // BEGIN( Pa" +
                    "yload = P, Start = 1 )\r\n            // END  ( Payload = P, End = 1, Start = 0)\r\n" +
                    "            // In this case, we don\'t want to issue a new Start on the second Be" +
                    "gin--instead, we\r\n            // want to wait for the Begin and get rid of it.\r\n" +
                    "            bool candidatesInOpenEvents = OpenEvents.Lookup(lookupStart, out ind" +
                    "x);\r\n            if (candidatesInOpenEvents && !skipBuffering && OpenEvents.entr" +
                    "ies[indx].value.Count > 0)\r\n            {\r\n                // We found a matchin" +
                    "g event. What we need to do is squirrel this away until the\r\n                // " +
                    "end of the time step.\r\n                // Every time we see an END event, we\'ll " +
                    "check if it matches this squirreled-away\r\n                // event. If it does, " +
                    "well and good; we\'ll process the END , then this\r\n                // If it doesn" +
                    "\'t, we should issue a brand new Start, as below\r\n                int ctoindx = 0" +
                    ";\r\n                if (CurrentTimeOpenEventBuffer.Lookup(lookupStart, out ctoind" +
                    "x))\r\n                    CurrentTimeOpenEventBuffer.entries[ctoindx].value++;\r\n " +
                    "               else\r\n                    CurrentTimeOpenEventBuffer.Insert(looku" +
                    "pStart, 1);\r\n                CurrentTimeOpenEventBufferTime = eventstart;\r\n     " +
                    "       }\r\n            else\r\n            { // issue a brand new start\r\n\r\n        " +
                    "        var activeEventExt = new ActiveEventExt(eventstart, eventstart, StreamEv" +
                    "ent.InfinitySyncTime, lookupStart);\r\n\r\n                // brand new event! Issue" +
                    " a public version\r\n                Emit(ActiveEvent.FromExt(activeEventExt));\r\n " +
                    "               InsertOrAppend(OpenEvents, lookupStart, activeEventExt);\r\n       " +
                    "     }\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining" +
                    ")]\r\n    private static void InsertOrAppend<K, V>(FastDictionary2<K, List<V>> eve" +
                    "nts, K key, V value)\r\n    {\r\n        int indx;\r\n        List<V> lst;\r\n        if" +
                    " (events.Lookup(key, out indx))\r\n        {\r\n            lst = events.entries[ind" +
                    "x].value;\r\n            lst.Add(value);\r\n        }\r\n        else\r\n        {\r\n    " +
                    "        lst = new List<V>();\r\n            events.Insert(key, lst);\r\n            " +
                    "lst.Add(value);\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.Aggressiv" +
                    "eInlining)]\r\n    private static ActiveEvent RemoveOne(FastDictionary2<KHP, List<" +
                    "ActiveEvent>> events, KHP key)\r\n    {\r\n        int indx;\r\n        if (!events.Lo" +
                    "okup(key, out indx))\r\n            throw new InvalidOperationException(\"Can\'t rem" +
                    "ove if it\'s not already there!\");\r\n\r\n        var lst = events.entries[indx].valu" +
                    "e;\r\n        var rv = lst[0];\r\n        lst.RemoveAt(0);\r\n        return rv;\r\n    " +
                    "}\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    private static " +
                    "ActiveEventExt RemoveOne(FastDictionary2<KHP, List<ActiveEventExt>> events, KHP " +
                    "key, long startMatch)\r\n    {\r\n        int indx;\r\n        if (!events.Lookup(key," +
                    " out indx))\r\n            throw new InvalidOperationException(\"Can\'t remove if it" +
                    "\'s not already there!\");\r\n\r\n        var lst = events.entries[indx].value;\r\n     " +
                    "   var itemIndex = lst.FindIndex(s => s.Start == startMatch);\r\n        if (itemI" +
                    "ndex > -1)\r\n        {\r\n            var item = lst[itemIndex];\r\n            lst.R" +
                    "emoveAt(itemIndex);\r\n            return item;\r\n        }\r\n        throw new Inva" +
                    "lidOperationException(\"Can\'t remove if it\'s not in the item list!\");\r\n    }\r\n\r\n " +
                    "   private void ActOnEnd(");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" batch, int index, long start, long endTime)\r\n    {\r\n        var matchSmall = new" +
                    " KHP(batch, index);\r\n\r\n        var item = RemoveOne(OpenEvents, matchSmall, star" +
                    "t);\r\n\r\n        // and add it to the End list\r\n        item.End = endTime;\r\n\r\n   " +
                    "     if (!ClosedEvents.ContainsKey(endTime))\r\n        {\r\n            // For perf" +
                    "ormance, we pull this out of a pool rather than consing a new one.\r\n            " +
                    "// Make very sure to reset the object before restoring it to the pool, or it\'ll " +
                    "carry garbage\r\n            FastDictionary2<KHP, List<ActiveEvent>> entry;\r\n     " +
                    "       dictPool.Get(out entry);\r\n            ClosedEvents[endTime] = entry;\r\n   " +
                    "     }\r\n\r\n        var activeEvt = ActiveEvent.FromExt(item);\r\n\r\n        InsertOr" +
                    "Append(ClosedEvents[endTime], matchSmall, activeEvt);\r\n    }\r\n\r\n    internal voi" +
                    "d Purge(long time)\r\n    {\r\n        // anything left in the Buffer?\r\n        if (" +
                    "CurrentTimeOpenEventBuffer.Size > 0)\r\n        {\r\n            var it = FastDictio" +
                    "nary2<KHP, long>.IteratorStart;\r\n            while (CurrentTimeOpenEventBuffer.I" +
                    "terate(ref it))\r\n            {\r\n                var e = CurrentTimeOpenEventBuff" +
                    "er.entries[it].key;\r\n                for (int i = 0; i < CurrentTimeOpenEventBuf" +
                    "fer.entries[it].value; i++)\r\n                    ActOnStartWithKHP(e, CurrentTim" +
                    "eOpenEventBufferTime, true);\r\n\r\n            }\r\n            CurrentTimeOpenEventB" +
                    "uffer.Initialize();\r\n        }\r\n\r\n        foreach (var closed in ClosedEvents.Wh" +
                    "ere(k => k.Key < time).ToArray())\r\n        {\r\n            var iterator = FastDic" +
                    "tionary2<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(@", ActiveEvent>.IteratorStart;
            while (closed.Value.Iterate(ref iterator))
                foreach (var v in closed.Value.entries[iterator].value)
                    Emit(v);

            closed.Value.Initialize();
            ClosedEvents.Remove(closed.Key);

            dictPool.Return(closed.Value);
        }
    }

    // Optimally, this would be inline
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Emit(ActiveEvent evt)
    {
        var dest_vsync = this.batch.vsync.col;
        var dest_vother = this.batch.vother.col;
        var destkey = this.batch.key.col;
        var dest_hash = this.batch.hash.col;

        if (evt.End == StreamEvent.InfinitySyncTime)
        { // start event
            dest_vsync[outputCount] = evt.Start;
            dest_vother[outputCount] = evt.End;
        }
        else // issue an end event
        {
            dest_vsync[outputCount] = evt.End;
            dest_vother[outputCount] = evt.Start;
        }

");
     foreach (var f in this.fields) {
         var sourceName = "evt.Payload";
         if (!noFields) sourceName += "." + f.OriginalName;

       if (f.OptimizeString()) { 
            this.Write("\r\n        this.batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceName));
            this.Write(");\r\n");
       } else { 
            this.Write("        this.batch.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[outputCount] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceName));
            this.Write(";\r\n");
       } 
     } 
            this.Write(@"
        destkey[outputCount] = evt.Key;
        dest_hash[outputCount] = evt.Hash;
        outputCount++;

        if (outputCount == Config.DataBatchSize)
        {
            this.batch.Count = outputCount;
            this.Observer.OnNext(this.batch);
            GetOutputBatch();
        }
    }
}
");
            return this.GenerationEnvironment.ToString();
        }
    }
}
