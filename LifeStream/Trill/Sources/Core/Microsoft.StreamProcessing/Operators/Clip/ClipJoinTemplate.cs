// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System.Reflection;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class ClipJoinTemplate : CommonBinaryTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;

// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TLeft: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("\r\n// TRight: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("\r\n\r\n[DataContract]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(genericParameters));
            this.Write(" : BinaryPipe<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(">\r\n{\r\n    private readonly MemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> pool;\r\n\r\n    [SchemaSerialization]\r\n    private readonly Expression<Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", bool>> keyComparer;\r\n    [SchemaSerialization]\r\n    private readonly Expression" +
                    "<Func<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(", bool>> leftComparer;\r\n\r\n    private StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> genericOutputBatch;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TLeft));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTLeftGenericParameters));
            this.Write(@" output;

    [DataMember]
    private FastMap<LeftInterval> leftIntervalMap = new FastMap<LeftInterval>();
    [DataMember]
    private FastMap<LeftEdge> leftEdgeMap = new FastMap<LeftEdge>();
    [DataMember]
    private RemovableEndPointHeap leftEndPointHeap;
    [DataMember]
    private long nextLeftTime = long.MinValue;
    [DataMember]
    private long nextRightTime = long.MinValue;
    [DataMember]
    private long currTime = long.MinValue;

    private readonly Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> queryPlanGenerator;

    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    [Obsolete(\"Used only by serialization. Do not call directly.\")]\r\n    publ" +
                    "ic ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> observer,\r\n        IEqualityComparerExpression<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("> keyEqualityComparer,\r\n        IEqualityComparerExpression<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(@"> leftComparer,
        Func<PlanNode, PlanNode, IBinaryObserver, BinaryPlanNode> queryPlanGenerator)
        : base(stream, observer)
    {
        this.queryPlanGenerator = queryPlanGenerator;
        this.keyComparer = keyEqualityComparer.GetEqualsExpr();

        this.leftComparer = leftComparer.GetEqualsExpr();

        this.leftEndPointHeap = new RemovableEndPointHeap();
        this.pool = MemoryManager.GetMemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(">(true /*stream.Properties.IsColumnar*/);\r\n        ");
 GetOutputBatch(); 
            this.Write(@"    }

    public override int CurrentlyBufferedOutputCount => output.Count;
    public override int CurrentlyBufferedLeftInputCount => base.CurrentlyBufferedLeftInputCount + leftEdgeMap.Count + leftIntervalMap.Count;
    public override int CurrentlyBufferedRightInputCount => base.CurrentlyBufferedRightInputCount;

    protected override void ProduceBinaryQueryPlan(PlanNode left, PlanNode right)
    {
        this.Observer.ProduceQueryPlan(queryPlanGenerator(left, right, this));
    }

    protected override void DisposeState() => this.output.Free();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessBothBatches(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> genericLeftBatch, StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("> genericRightBatch, out bool leftBatchDone, out bool rightBatchDone, out bool le" +
                    "ftBatchFree, out bool rightBatchFree)\r\n    {\r\n        var leftBatch = genericLef" +
                    "tBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(keyType, leftType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTLeftGenericParameters));
            this.Write(";\r\n        var rightBatch = genericRightBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(keyType, rightType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTRightGenericParameters));
            this.Write(@";

        leftBatchFree = rightBatchFree = true;
        if (!GoToVisibleRow(leftBatch))
        {
            leftBatchDone = true;
            rightBatchDone = false;
            return;
        }

        nextLeftTime = leftBatch.vsync.col[leftBatch.iter];
        if (!GoToVisibleRow(rightBatch))
        {
            leftBatchDone = false;
            rightBatchDone = true;
            return;
        }

        nextRightTime = rightBatch.vsync.col[rightBatch.iter];

        while (true)
        {
            if (nextLeftTime <= nextRightTime)
            {
                UpdateTime(nextLeftTime);

                /*
                ProcessLeftEvent(
                    nextLeftTime,
                    leftBatch.vother.col[leftBatch.iter],
                    ref leftBatch.key.col[leftBatch.iter],
                    leftBatch[leftBatch.iter],
                    leftBatch.hash.col[leftBatch.iter]);
                */
                ");
 ProcessLeftEvent("nextLeftTime", "leftBatch.vother.col[leftBatch.iter]", "leftBatch.key.col[leftBatch.iter]", "leftBatch", "leftBatch.iter",  "leftBatch.hash.col[leftBatch.iter]"); 
            this.Write(@"
                leftBatch.iter++;

                if (!GoToVisibleRow(leftBatch))
                {
                    leftBatchDone = true;
                    rightBatchDone = false;
                    return;
                }

                nextLeftTime = leftBatch.vsync.col[leftBatch.iter];
            }
            else
            {
                UpdateTime(nextRightTime);

                ProcessRightEvent(
                    nextRightTime,
                    rightBatch.vother.col[rightBatch.iter],
                    ref rightBatch.key.col[rightBatch.iter],
                    rightBatch.hash.col[rightBatch.iter]);

                rightBatch.iter++;

                if (!GoToVisibleRow(rightBatch))
                {
                    leftBatchDone = false;
                    rightBatchDone = true;
                    return;
                }

                nextRightTime = rightBatch.vsync.col[rightBatch.iter];
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected override void ProcessLeftBatch(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write("> genericBatch, out bool isBatchDone, out bool isBatchFree)\r\n    {\r\n        var b" +
                    "atch = genericBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(keyType, leftType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTLeftGenericParameters));
            this.Write(@";

        isBatchFree = true;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                return;
            }

            nextLeftTime = batch.vsync.col[batch.iter];

            if (nextLeftTime > nextRightTime)
            {
                isBatchDone = false;
                return;
            }

            UpdateTime(nextLeftTime);

            /*
            ProcessLeftEvent(
                nextLeftTime,
                batch.vother.col[batch.iter],
                ref batch.key.col[batch.iter],
                batch[batch.iter],
                batch.hash.col[batch.iter]);
            */
            ");
 ProcessLeftEvent("nextLeftTime", "batch.vother.col[batch.iter]", "batch.key.col[batch.iter]", "batch", "batch.iter",  "batch.hash.col[batch.iter]"); 
            this.Write("\r\n            batch.iter++;\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOption" +
                    "s.AggressiveInlining)]\r\n    protected override void ProcessRightBatch(StreamMess" +
                    "age<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRight));
            this.Write("> genericBatch, out bool isBatchDone, out bool isBatchFree)\r\n    {\r\n        var b" +
                    "atch = genericBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(keyType, rightType)));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTRightGenericParameters));
            this.Write(@";

        isBatchFree = true;
        while (true)
        {
            if (!GoToVisibleRow(batch))
            {
                isBatchDone = true;
                return;
            }

            nextRightTime = batch.vsync.col[batch.iter];

            if (nextRightTime > nextLeftTime)
            {
                isBatchDone = false;
                return;
            }

            UpdateTime(nextRightTime);

            ProcessRightEvent(
                nextRightTime,
                batch.vother.col[batch.iter],
                ref batch.key.col[batch.iter],
                batch.hash.col[batch.iter]);

            batch.iter++;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool GoToVisibleRow<TPayload>(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@", TPayload> batch)
    {
        while (batch.iter < batch.Count && (batch.bitvector.col[batch.iter >> 6] & (1L << (batch.iter & 0x3f))) != 0 && batch.vother.col[batch.iter] >= 0)
        {
            batch.iter++;
        }

        return (batch.iter != batch.Count);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void UpdateTime(long time)
    {
        if (time != currTime)
        {
            currTime = time;
            ReachTime();
        }
    }

/*
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ProcessLeftEvent(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(" payload, int hash)\r\n    {\r\n        if (start < end)\r\n        {\r\n            // R" +
                    "ow is a start edge or interval.\r\n            bool isInterval = end < StreamEvent" +
                    ".InfinitySyncTime;\r\n            if (isInterval)\r\n            {\r\n                " +
                    "bool isFullyOutputtable = nextRightTime >= end;\r\n                if (isFullyOutp" +
                    "uttable)\r\n                {\r\n                    // Output full interval.\r\n     " +
                    "               AddToBatch(start, end, ref key, ref payload, hash);\r\n            " +
                    "    }\r\n                else\r\n                {\r\n                    // Insert in" +
                    "to map to remember interval.\r\n                    int mapIndex = leftIntervalMap" +
                    ".Insert(hash);\r\n\r\n                    // Insert into heap to schedule removal at" +
                    " endpoint.\r\n                    int heapIndex = leftEndPointHeap.Insert(end, map" +
                    "Index);\r\n\r\n                    // Set value in map, also remembering heap\'s inde" +
                    "x.\r\n                    leftIntervalMap.Values[mapIndex].Initialize(start, ref k" +
                    "ey, ref payload, heapIndex);\r\n\r\n                    // Output start edge.\r\n     " +
                    "               AddToBatch(start, StreamEvent.InfinitySyncTime, ref key, ref payl" +
                    "oad, hash);\r\n                }\r\n            }\r\n            else\r\n            {\r\n" +
                    "                int index = leftEdgeMap.Insert(hash);\r\n                leftEdgeM" +
                    "ap.Values[index].Populate(start, ref key, ref payload);\r\n\r\n                // Ou" +
                    "tput start edge.\r\n                AddToBatch(start, StreamEvent.InfinitySyncTime" +
                    ", ref key, ref payload, hash);\r\n            }\r\n        }\r\n        else if (end =" +
                    "= StreamEvent.PunctuationOtherTime)\r\n        {\r\n            AddPunctuationToBatc" +
                    "h(start);\r\n        }\r\n        else\r\n        {\r\n            // Row is an end edge" +
                    ".\r\n            var leftEvents = leftEdgeMap.Find(hash);\r\n            int index;\r" +
                    "\n            while (leftEvents.Next(out index))\r\n            {\r\n                " +
                    "var leftEdge = leftEdgeMap.Values[index];\r\n                var leftKey = leftEdg" +
                    "e.Batch.key.col[leftEdge.Index];\r\n                if (AreSame(end, ref key, ref " +
                    "payload, ref leftEdgeMap.Values[index]))\r\n                {\r\n                   " +
                    " // Output end edge.\r\n                    AddToBatch(start, end, ref key, ref pa" +
                    "yload, hash);\r\n\r\n                    // Remove from leftMap.\r\n                  " +
                    "  leftEvents.Remove();\r\n                    break;\r\n                }\r\n         " +
                    "   }\r\n        }\r\n    }\r\n*/\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlini" +
                    "ng)]\r\n    private void ProcessRightEvent(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@" key, int hash)
    {
        if (end == StreamEvent.PunctuationOtherTime)
        {
            AddPunctuationToBatch(start);
            return;
        }
        else if (start >= end)
        {
            // Row is an end edge, which we don't care about because the start edge would have already
            // removed all joining left events.
            return;
        }

        // Mark any matching left intervals as no longer active.
        int index;
        var leftIntervals = leftIntervalMap.Find(hash);
        while (leftIntervals.Next(out index))
        {
            long leftStart = leftIntervalMap.Values[index].Start;
            var leftInterval = leftIntervalMap.Values[index];
            var leftIntervalKey = leftInterval.Key;
            if (leftStart < start && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.keyComparer("key", "leftIntervalKey")));
            this.Write(@")
            {
                // Output end edge.
                /*
                AddToBatch(
                    start,
                    leftStart,
                    ref leftIntervalMap.Values[index].Key,
                    ref leftIntervalMap.Values[index].Payload,
                    hash);
                */
                ");
 AddToBatch("start", "leftStart",  "leftIntervalKey", "leftIntervalMap.Values[index]", "hash"); 
            this.Write(@"
                // Remove from heap and map.
                leftEndPointHeap.Remove(leftIntervalMap.Values[index].HeapIndex);
                leftIntervals.Remove();
            }
        }

        // Remove any matching left edges.
        var leftEdges = leftEdgeMap.Find(hash);
        while (leftEdges.Next(out index))
        {
            var leftEdge = leftEdgeMap.Values[index];
            long leftStart = leftEdge.Start;
            var leftEdgeKey = leftEdge.Key;
            if (leftStart < start && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.keyComparer("key", "leftEdgeKey")));
            this.Write(@")
            {
                // Output end edge.
                /*
                AddToBatch(
                    start,
                    leftStart,
                    ref leftEdgeMap.Values[index].Key,
                    ref leftEdgeMap.Values[index].Payload,
                    hash);
                */
                ");
 AddToBatch("start", "leftStart",  "leftEdgeKey", "leftEdge", "hash"); 
            this.Write(@"
                // Remove left event.
                leftEdges.Remove();
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ReachTime()
    {
        // Carry-out all interval endpoints for left intervals that end prior or at new current time.
        long endPointTime;
        int index;
        while (leftEndPointHeap.TryGetNextInclusive(currTime, out endPointTime, out index))
        {
            // Output end edge.
            /*
            AddToBatch(
                endPointTime,
                leftIntervalMap.Values[index].Start,
                ref leftIntervalMap.Values[index].Key,
                ref leftIntervalMap.Values[index].Payload,
                leftIntervalMap.GetHash(index));
            */
            var leftInterval = leftIntervalMap.Values[index];
            var leftIntervalKey = leftInterval.Key;
            var leftIntervalStart = leftInterval.Start;
            var leftIntervalHash = leftIntervalMap.GetHash(index);
            ");
 AddToBatch("endPointTime", "leftIntervalStart",  "leftIntervalKey", "leftInterval", "leftIntervalHash"); 
            this.Write(@"
            // Remove from leftMap.
            leftIntervalMap.Remove(index);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddPunctuationToBatch(long start)
    {
        if (start > lastCTI)
        {
            lastCTI = start;

            int index = output.Count++;
            output.vsync.col[index] = start;
            output.vother.col[index] = StreamEvent.PunctuationOtherTime;
            output.key.col[index] = default;
");
     foreach (var f in this.leftFields) {
          if (f.OptimizeString()) { 
            this.Write("            output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(string.Empty);\r\n");
       } else { 
            this.Write("            output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[index] = default;\r\n");
       }
        } 
            this.Write(@"            output.hash.col[index] = 0;
            output.bitvector.col[index >> 6] |= (1L << (index & 0x3f));

            if (output.Count == Config.DataBatchSize) FlushContents();
        }
    }

/*
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(long start, long end, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(@" payload, int hash)
    {
        int index = output.Count++;
        output.vsync.col[index] = start;
        output.vother.col[index] = end;
        output.key.col[index] = key;
        output[index] = payload;
        output.hash.col[index] = hash;

        if (output.Count == Config.DataBatchSize)
        {
            this.Observer.OnNext(output);
            pool.Get(out output);
            output.Allocate();
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool AreSame(long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(@" payload, ref LeftEdge active)
    {
        return start == active.Start && keyComparerEquals(key, active.Key) && leftComparerEquals(payload, active.Payload);
    }
*/
    protected override void FlushContents()
    {
        if (output.Count == 0) return;
        this.Observer.OnNext(output);
        ");
 GetOutputBatch(); 
            this.Write("    }\r\n");
 if (!noFields && !this.leftType.GetTypeInfo().IsValueType) { 
            this.Write("    [DataContract]\r\n    private struct ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write("\r\n    {\r\n");
 foreach (var f in this.leftFields) { 
            this.Write("        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n");
 } 
            this.Write("    }\r\n");
 } 
            this.Write("/*\r\n    [DataContract]\r\n    private struct LeftInterval\r\n    {\r\n        [DataMemb" +
                    "er]\r\n        public long Start;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(" Payload;\r\n        [DataMember]\r\n        public int HeapIndex;\r\n\r\n        [Method" +
                    "Impl(MethodImplOptions.AggressiveInlining)]\r\n        public void Initialize(long" +
                    " start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(@" payload, int heapIndex)
        {
            Start = start;
            Key = key;
            Payload = payload;
            HeapIndex = heapIndex;
        }

        public override string ToString()
        {
            return ""[Start="" + Start + "", Key='"" + Key + ""', Payload='"" + Payload + ""', HeapIndex="" + HeapIndex + ""]"";
        }
    }
*/
    [DataContract]
    private struct LeftInterval
    {
        [DataMember]
        public long Start;
        [DataMember]
        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public int HeapIndex;\r\n        [DataMember]\r" +
                    "\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write(" Payload;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        " +
                    "public void Initialize(long start, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TLeft));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTLeftGenericParameters));
            this.Write(" batch, int index, int heapIndex)\r\n        {\r\n            Start = start;\r\n       " +
                    "     Key = batch.key.col[index];\r\n");
 foreach (var f in this.leftFields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
            this.Write(@"            HeapIndex = heapIndex;
        }

        public override string ToString()
        {
            //return string.Format(""[Start={0}, Key='{1}', Payload='{2}', HeapIndex={3}"", Start, Key, Batch[Index], HeapIndex);
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            sb.AppendFormat(""[Start={0}"", Start);
            sb.AppendFormat("", Key='{0}'"", Key);
            ");
 foreach (var f in this.leftFields) { 
            this.Write("            sb.AppendFormat(\", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write("={0}, \", Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(");\r\n            ");
 } 
            this.Write(@"            sb.AppendFormat("", Key='{0}'"", HeapIndex);
            sb.Append(""]"");
            return sb.ToString();
        }
    }
/*
    [DataContract]
    private struct LeftEdge
    {
        [DataMember]
        public long Start;
        [DataMember]
        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(" Payload;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        " +
                    "public void Populate(long start, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ref ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TLeft));
            this.Write(@" payload)
        {
            Start = start;
            Key = key;
            Payload = payload;
        }

        public override string ToString()
        {
            return ""[Start="" + Start + "", Key='"" + Key + ""', Payload='"" + Payload + ""]"";
        }
    }
*/
    [DataContract]
    private struct LeftEdge
    {
        [DataMember]
        public long Start;
        [DataMember]
        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write(" Payload;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        " +
                    "public void Populate(long start, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TLeft));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTLeftGenericParameters));
            this.Write(" batch, int index)\r\n        {\r\n            Start = start;\r\n            Key = batc" +
                    "h.key.col[index];\r\n");
 foreach (var f in this.leftFields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
            this.Write(@"        }

        public override string ToString()
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            sb.AppendFormat(""[Start={0}"", Start);
            sb.AppendFormat("", Key='{0}'"", Key);
            ");
 foreach (var f in this.leftFields) { 
            this.Write("            sb.AppendFormat(\", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write("={0}, \", Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(");\r\n            ");
 } 
            this.Write("            sb.Append(\"]\");\r\n            return sb.ToString();\r\n        }\r\n    }\r" +
                    "\n}\r\n\r\n");
            return this.GenerationEnvironment.ToString();
        }

//    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ProcessLeftEvent(string start, string end, string key, string batch, string index, string hash)
    {

this.Write("    { // begin ProcessLeftEvent\r\n        var start_ProcessLeftEvent = ");

this.Write(this.ToStringHelper.ToStringWithCulture(start));

this.Write(";\r\n        var end_ProcessLeftEvent = ");

this.Write(this.ToStringHelper.ToStringWithCulture(end));

this.Write(";\r\n        var key_ProcessLeftEvent = ");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write(";\r\n        var batch_ProcessLeftEvent = ");

this.Write(this.ToStringHelper.ToStringWithCulture(batch));

this.Write(";\r\n        var index_ProcessLeftEvent = ");

this.Write(this.ToStringHelper.ToStringWithCulture(index));

this.Write(";\r\n        var hash_ProcessLeftEvent = ");

this.Write(this.ToStringHelper.ToStringWithCulture(hash));

this.Write(@";

        if (start_ProcessLeftEvent < end_ProcessLeftEvent)
        {
            // Row is a start edge or interval.
            bool isInterval = end_ProcessLeftEvent < StreamEvent.InfinitySyncTime;
            if (isInterval)
            {
                bool isFullyOutputtable = nextRightTime >= end_ProcessLeftEvent;
                if (isFullyOutputtable)
                {
                    // Output full interval.
                    ");

 AddToBatch(start, end, key, batch, index, hash); 
this.Write(@"                }
                else
                {
                    // Insert into map to remember interval.
                    int mapIndex = leftIntervalMap.Insert(hash_ProcessLeftEvent);

                    // Insert into heap to schedule removal at endpoint.
                    int heapIndex = leftEndPointHeap.Insert(end_ProcessLeftEvent, mapIndex);

                    // Set value in map, also remembering heap's index.
                    leftIntervalMap.Values[mapIndex].Initialize(start_ProcessLeftEvent, batch_ProcessLeftEvent, index_ProcessLeftEvent, heapIndex);

                    // Output start edge.
                    ");

 AddToBatch(start, "StreamEvent.InfinitySyncTime", key, batch, index, hash); 
this.Write(@"                }
            }
            else
            {
                int index = leftEdgeMap.Insert(hash_ProcessLeftEvent);
                leftEdgeMap.Values[index].Populate(start_ProcessLeftEvent, batch_ProcessLeftEvent, index_ProcessLeftEvent);

                // Output start edge.
                ");

 AddToBatch(start, "StreamEvent.InfinitySyncTime", key, batch, index, hash); 
this.Write(@"            }
        }
        else
        {
            // Row is an end edge.
            var leftEvents = leftEdgeMap.Find(hash_ProcessLeftEvent);
            int index;
            while (leftEvents.Next(out index))
            {
                var leftEdge = leftEdgeMap.Values[index];
                var areSame =
                    end_ProcessLeftEvent == leftEdge.Start &&
                    //keyComparerEquals(key, active.Key) &&
                    ");

this.Write(this.ToStringHelper.ToStringWithCulture(this.keyComparer("key_ProcessLeftEvent", "leftEdge.Key")));

this.Write(" &&\r\n                    // leftComparerEquals(payload, active.Payload)\r\n        " +
        "            ");

this.Write(this.ToStringHelper.ToStringWithCulture(this.leftComparer("batch_ProcessLeftEvent", "leftEdge.Payload")));

this.Write(";\r\n                if (areSame)\r\n                {\r\n                    // Output" +
        " end edge.\r\n                    ");

 AddToBatch(start, end, key, batch, index, hash); 
this.Write("\r\n                    // Remove from leftMap.\r\n                    leftEvents.Rem" +
        "ove();\r\n                    break;\r\n                }\r\n            }\r\n        }\r" +
        "\n    } // end ProcessLeftEvent\r\n");


    }

//    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(string start, string end, string key, string batch, string batchIndex, string hash)
    {

this.Write("    { // begin AddToBatch\r\n        int index_AddToBatch = output.Count++;\r\n      " +
        "  output.vsync.col[index_AddToBatch] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(start));

this.Write(";\r\n        output.vother.col[index_AddToBatch] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(end));

this.Write(";\r\n        output.key.col[index_AddToBatch] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write(";\r\n");

     foreach (var f in this.leftFields) {
          if (f.OptimizeString()) { 
this.Write("\r\n        output.");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(".AddString(");

this.Write(this.ToStringHelper.ToStringWithCulture(batch));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write("[");

this.Write(this.ToStringHelper.ToStringWithCulture(batchIndex));

this.Write("]);\r\n");

       } else { 
this.Write("        output.");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(".col[index_AddToBatch] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(batch));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(".col[");

this.Write(this.ToStringHelper.ToStringWithCulture(batchIndex));

this.Write("];\r\n");

       }
        } 
this.Write("        output.hash.col[index_AddToBatch] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(hash));

this.Write(";\r\n\r\n        if (output.Count == Config.DataBatchSize)\r\n        {\r\n            ou" +
        "tput.Seal();\r\n            this.Observer.OnNext(output);\r\n            ");

 GetOutputBatch(); 
this.Write("        }\r\n    } // end AddToBatch\r\n");


    }

//    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void AddToBatch(string start, string end, string key, string leftInterval, string hash)
    {

this.Write("    { // begin AddToBatch\r\n        int index_AddToBatch = output.Count++;\r\n      " +
        "  output.vsync.col[index_AddToBatch] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(start));

this.Write(";\r\n        output.vother.col[index_AddToBatch] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(end));

this.Write(";\r\n        output.key.col[index_AddToBatch] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write(";\r\n");

     foreach (var f in this.leftFields) {
         var sourceName = leftInterval + ".Payload";
         if (!noFields) sourceName += "." + f.OriginalName;
          if (f.OptimizeString()) { 
this.Write("\r\n        output.");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(".AddString(");

this.Write(this.ToStringHelper.ToStringWithCulture(sourceName));

this.Write(");\r\n");

       } else { 
this.Write("        output.");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(".col[index_AddToBatch] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(sourceName));

this.Write(";\r\n");

       }
        } 
this.Write("        output.hash.col[index_AddToBatch] = ");

this.Write(this.ToStringHelper.ToStringWithCulture(hash));

this.Write(";\r\n\r\n        if (output.Count == Config.DataBatchSize)\r\n        {\r\n            ou" +
        "tput.Seal();\r\n            this.Observer.OnNext(output);\r\n            ");

 GetOutputBatch(); 
this.Write("        }\r\n    } // end AddToBatch\r\n");


    }

    private void GetOutputBatch() { 
this.Write("  pool.Get(out genericOutputBatch);\r\n  genericOutputBatch.Allocate();\r\n  output =" +
        " (");

this.Write(this.ToStringHelper.ToStringWithCulture(Transformer.GetBatchClassName(this.keyType, this.leftType)));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(this.TKeyTLeftGenericParameters));

this.Write(")genericOutputBatch;\r\n");

 foreach (var f in this.leftFields.Where(fld => fld.OptimizeString())) {  
this.Write("  output.");

this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));

this.Write(".Initialize();\r\n");

 }

    } 
    }
}
