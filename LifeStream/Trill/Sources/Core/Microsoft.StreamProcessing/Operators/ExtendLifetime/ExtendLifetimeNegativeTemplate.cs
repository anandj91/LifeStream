// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System.Reflection;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class ExtendLifetimeNegativeTemplate : ExtendLifetimeBaseTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;

[DataContract]
internal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" : UnaryPipe<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">\r\n{\r\n    private readonly MemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> pool;\r\n    private readonly Func<PlanNode, IQueryObject, PlanNode> queryPlanGen" +
                    "erator;\r\n\r\n    [SchemaSerialization]\r\n    private readonly long duration;\r\n\r\n   " +
                    " private StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> genericOutputBatch;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(@" output;

    [DataMember]
    private long lastSyncTime = long.MinValue;
    [DataMember]
    private FastMap<ActiveEvent> syncTimeMap = new FastMap<ActiveEvent>();
    [DataMember]
    private EndPointHeap endPointHeap = new EndPointHeap();
    [DataMember]
    private Dictionary<long, List<ActiveEvent>> contractedToZero = new Dictionary<long, List<ActiveEvent>>();

");
 if (useCompiledKeyComparer) { 
            this.Write("    [SchemaSerialization]\r\n    private readonly Expression<Func<TKey, TKey, bool>" +
                    "> keyComparerExpr;\r\n    private readonly Func<TKey, TKey, bool> keyComparer;\r\n");
 } 
 if (useCompiledPayloadComparer) { 
            this.Write("    [SchemaSerialization]\r\n    private readonly Expression<Func<TPayload, TPayloa" +
                    "d, bool>> payloadComparerExpr;\r\n    private readonly Func<TPayload, TPayload, bo" +
                    "ol> payloadComparer;\r\n");
 } 
            this.Write("\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    [Obsolete(\"Used only by serialization. Do not call directly.\")]\r\n    publ" +
                    "ic ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> observer,\r\n        Func<PlanNode, IQueryObject, PlanNode> queryPlanGenerator,\r\n" +
                    "        long duration)\r\n        : base(stream, observer)\r\n    {\r\n        this.du" +
                    "ration = duration;\r\n        this.queryPlanGenerator = queryPlanGenerator;\r\n\r\n");
 if (useCompiledKeyComparer) { 
            this.Write("        keyComparerExpr = stream.Properties.KeyEqualityComparer.GetEqualsExpr();\r" +
                    "\n        keyComparer = keyComparerExpr.Compile();\r\n");
 } 
            this.Write("\r\n");
 if (useCompiledPayloadComparer) { 
            this.Write("        payloadComparerExpr = stream.Properties.PayloadEqualityComparer.GetEquals" +
                    "Expr();\r\n        payloadComparer = payloadComparerExpr.Compile();\r\n");
 } 
            this.Write("\r\n        pool = MemoryManager.GetMemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">(true /*stream.Properties.IsColumnar*/);\r\n        GetOutputBatch();\r\n    }\r\n\r\n  " +
                    "  private void GetOutputBatch()\r\n    {\r\n        pool.Get(out genericOutputBatch)" +
                    ";\r\n        genericOutputBatch.Allocate();\r\n        output = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(")genericOutputBatch;\r\n");
 foreach (var f in this.fields.Where(fld => fld.OptimizeString())) {  
            this.Write("\r\n        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Initialize();\r\n");
 } 
            this.Write(@"   }

    public override void ProduceQueryPlan(PlanNode previous)
    {
        Observer.ProduceQueryPlan(queryPlanGenerator(previous, this));
    }

    private void ReachTime(long timestamp)
    {
        long endPointTime;
        int index;
        while (endPointHeap.TryGetNextExclusive(timestamp, out endPointTime, out index))
        {
            List<ActiveEvent> found;
            bool sendToOutput = true;
            if (this.contractedToZero.TryGetValue(endPointTime, out found))
            {
                for (int i = 0; i < found.Count; i++)
                {
                    var activeEvent = syncTimeMap.Values[index];
                    if (activeEvent.Other != StreamEvent.InfinitySyncTime) continue;
                    var f = found[i];
                    if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(payloadComparer("f", "activeEvent.Payload")));
            this.Write("\r\n                        && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyComparer("f.Key", "activeEvent.Key")));
            this.Write(@"
                        && f.Other == activeEvent.Sync)
                    {
                        // We have a start edge that has been marked for deletion
                        found.RemoveAt(i);
                        if (found.Count == 0) this.contractedToZero.Remove(endPointTime);
                        sendToOutput = false;
                        break;
                    }
                }
            }

            if (!sendToOutput) continue;
            int ind = output.Count++;
            {
                var activeEvent = syncTimeMap.Values[index];
                output.vsync.col[ind] = activeEvent.Sync;
                output.vother.col[ind] = activeEvent.Other;
                output.key.col[ind] = activeEvent.Key;
");
     foreach (var f in this.fields) { 
       if (f.OptimizeString()) { 
            this.Write("\r\n                output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(activeEvent.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(");\r\n");
       } else { 
            this.Write("                output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[ind] = activeEvent.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(";\r\n");
       } 
     } 
            this.Write(@"                output.hash.col[ind] = activeEvent.Hash;
            }

            if (output.Count == Config.DataBatchSize) FlushContents();
            syncTimeMap.Remove(index);
        }
        lastSyncTime = timestamp;
    }

    public override unsafe void OnNext(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> genericBatch)\r\n    {\r\n        var batch = genericBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(";\r\n        var count = batch.Count;\r\n\r\n        fixed (long* bv = batch.bitvector." +
                    "col)\r\n        {\r\n            for (int i = 0; i < count; i++)\r\n            {\r\n   " +
                    "             if ((bv[i >> 6] & (1L << (i & 0x3f))) == 0)\r\n                {\r\n   " +
                    "                 if (batch.vsync.col[i] >= StreamEvent.MinSyncTime + duration) R" +
                    "eachTime(batch.vsync.col[i] - duration);\r\n\r\n                    if (batch.vother" +
                    ".col[i] == StreamEvent.InfinitySyncTime)\r\n                    {\r\n               " +
                    "         // For start events, we queue them up\r\n                        // until" +
                    " we are [duration] time past to make sure that\r\n                        // no en" +
                    "d edges have been moved earlier\r\n                        int index = syncTimeMap" +
                    ".Insert(batch.hash.col[i]);\r\n                        syncTimeMap.Values[index].P" +
                    "opulate(batch.key.col[i], batch, i, batch.vsync.col[i], StreamEvent.InfinitySync" +
                    "Time, batch.hash.col[i]);\r\n                        endPointHeap.Insert(batch.vsy" +
                    "nc.col[i], index);\r\n                    }\r\n                    else if (batch.vo" +
                    "ther.col[i] > batch.vsync.col[i])\r\n                    {\r\n                      " +
                    "  // For intervals, we clip the duration as well before queueing\r\n              " +
                    "          // Events with durations of zero or less are dropped\r\n                " +
                    "        var sync = batch.vsync.col[i];\r\n                        var other = batc" +
                    "h.vother.col[i] - duration;\r\n                        if (other <= sync) continue" +
                    ";\r\n\r\n                        int index = syncTimeMap.Insert(batch.hash.col[i]);\r" +
                    "\n                        syncTimeMap.Values[index].Populate(batch.key.col[i], ba" +
                    "tch, i, sync, other, batch.hash.col[i]);\r\n                        endPointHeap.I" +
                    "nsert(batch.vsync.col[i], index);\r\n                    }\r\n                    el" +
                    "se\r\n                    {\r\n                        var sync = batch.vsync.col[i]" +
                    " - duration;\r\n                        var other = batch.vother.col[i];\r\n\r\n      " +
                    "                  if (other >= sync)\r\n                        {\r\n               " +
                    "             // If we have a contracted event, do not add the end edge to the ba" +
                    "tch.\r\n                            // Also, add the payload to a list of events t" +
                    "o be purged.\r\n                            var activeEvent = new ActiveEvent();\r\n" +
                    "                            activeEvent.Populate(batch.key.col[i], batch, i, syn" +
                    "c, other, batch.hash.col[i]);\r\n                            this.contractedToZero" +
                    ".Add(other, activeEvent);\r\n                        }\r\n                        el" +
                    "se\r\n                        {\r\n                            int ind = output.Coun" +
                    "t++;\r\n                            output.vsync.col[ind] = sync;\r\n               " +
                    "             output.vother.col[ind] = other;\r\n                            output" +
                    ".key.col[ind] = batch.key.col[i];\r\n                            output[ind] = bat" +
                    "ch[i];\r\n                            output.hash.col[ind] = batch.hash.col[i];\r\n\r" +
                    "\n                            if (output.Count == Config.DataBatchSize) FlushCont" +
                    "ents();\r\n                        }\r\n                    }\r\n                }\r\n  " +
                    "              else if (batch.vother.col[i] == StreamEvent.PunctuationOtherTime)\r" +
                    "\n                {\r\n                    long syncTime = (batch.vsync.col[i] == S" +
                    "treamEvent.InfinitySyncTime ? StreamEvent.InfinitySyncTime : batch.vsync.col[i] " +
                    "- duration);\r\n                    ReachTime(syncTime);\r\n\r\n                    in" +
                    "t ind = output.Count++;\r\n                    output.vsync.col[ind] = syncTime;\r\n" +
                    "                    output.vother.col[ind] = StreamEvent.PunctuationOtherTime;\r\n" +
                    "                    output.key.col[ind] = default;\r\n                    output[i" +
                    "nd] = default;\r\n                    output.hash.col[ind] = batch.hash.col[i];\r\n " +
                    "                   output.bitvector.col[ind >> 6] |= (1L << (ind & 0x3f));\r\n\r\n  " +
                    "                  if (output.Count == Config.DataBatchSize) FlushContents();\r\n  " +
                    "              }\r\n            }\r\n        }\r\n        batch.Free();\r\n    }\r\n\r\n    p" +
                    "rotected override void FlushContents()\r\n    {\r\n        if (output.Count == 0) re" +
                    "turn;\r\n        output.Seal();\r\n        this.Observer.OnNext(output);\r\n        Ge" +
                    "tOutputBatch();\r\n    }\r\n\r\n    protected override void DisposeState() => output.F" +
                    "ree();\r\n\r\n    public override int CurrentlyBufferedOutputCount => output.Count;\r" +
                    "\n\r\n    public override int CurrentlyBufferedInputCount => syncTimeMap.Count + co" +
                    "ntractedToZero.Values.Select(o => o.Count).Sum();\r\n\r\n");
 if (!noFields && !this.payloadType.GetTypeInfo().IsValueType) { 
            this.Write("    [DataContract]\r\n    private struct ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write("\r\n    {\r\n        ");
 foreach (var f in this.fields) { 
            this.Write("        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n        ");
 } 
            this.Write("    }\r\n");
 } 
            this.Write("\r\n    [DataContract]\r\n    private struct ActiveEvent\r\n    {\r\n        [DataMember]" +
                    "\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public long Sync;\r\n        [DataMember]\r\n   " +
                    "     public long Other;\r\n        [DataMember]\r\n        public int Hash;\r\n       " +
                    " [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write(" Payload;\r\n\r\n        public void Populate(");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" key, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" batch, int index, long sync, long other, int hash)\r\n        {\r\n            this." +
                    "Key = key;\r\n");
 if (this.noFields) { 
            this.Write("            this.Payload = batch.payload.col[index];\r\n");
 } else { 
     foreach (var f in this.fields) { 
            this.Write("            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n");
 } 
 } 
            this.Write("            this.Sync = sync;\r\n            this.Other = other;\r\n            this." +
                    "Hash = hash;\r\n        }\r\n\r\n        public bool PayloadEquals(ActiveEvent other)\r" +
                    "\n        {\r\n");
 foreach (var f in this.fields) { 
            this.Write("            if (!this.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Equals(other.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(")) return false;\r\n");
 } 
            this.Write("            return true;\r\n        }\r\n\r\n        public override string ToString()\r" +
                    "\n        {\r\n            return \"Key=\'\" + Key + \"\', Payload=\'\"; // + Payload;\r\n  " +
                    "      }\r\n    }\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
}
