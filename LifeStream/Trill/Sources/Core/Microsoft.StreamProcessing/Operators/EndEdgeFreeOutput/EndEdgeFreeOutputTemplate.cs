// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System.Linq;
    using System.Reflection;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "15.0.0.0")]
    internal partial class EndEdgeFreeOutputTemplate : CommonUnaryTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Aggregates;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;
[assembly: IgnoresAccessChecksTo(""Microsoft.StreamProcessing"")]

// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TPayload: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("\r\n\r\n[DataContract]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" : UnaryPipe<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">\r\n{\r\n    private readonly MemoryPool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> pool;\r\n    private readonly Func<PlanNode, IQueryObject, PlanNode> queryPlanGen" +
                    "erator;\r\n\r\n    private StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> genericOutputBatch;\r\n    [DataMember]\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(@" output;

    [DataMember]
    private SortedDictionary<long, FastDictionary2<ActiveEvent, int>> eventMap;
    [DataMember]
    private long lastSyncTime;
    [DataMember]
    private long lastCti;

    private DataStructurePool<FastDictionary2<ActiveEvent, int>> dictPool;

    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    [Obsolete(\"Used only by serialization. Do not call directly.\")]\r\n    publ" +
                    "ic ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("() { }\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> observer,\r\n        Func<PlanNode, IQueryObject, PlanNode> queryPlanGenerator)\r\n" +
                    "        : base(stream, observer)\r\n    {\r\n        pool = MemoryManager.GetMemoryP" +
                    "ool<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(">(true /*stream.Properties.IsColumnar*/);\r\n        this.queryPlanGenerator = quer" +
                    "yPlanGenerator;\r\n\r\n        //(1, EqualityComparerExtensions.GetCompoundEqualityC" +
                    "omparerExpression<ActiveEvent, long, ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(@">(e => e.End, EqualityComparerExpression<long>.Default, e => e.Key, stream.Properties.KeyEqualityComparer, e => e.Payload, stream.Properties.PayloadEqualityComparer)));
        var comparer = new EqualityComparerExpression<ActiveEvent>(
            (ae1, ae2) => ae1.End == ae2.End && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.keyEquals("ae1", "ae2")));
            this.Write(" && ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.payloadEquals("ae1.Payload", "ae2.Payload")));
            this.Write(",\r\n            (ae) => ((int) ae.End) ^ ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.keyHashFunction("ae")));
            this.Write(" ^ ");
            this.Write(this.ToStringHelper.ToStringWithCulture(this.payloadHashFunction("ae.Payload")));
            this.Write(@") ;
        var equals = comparer.GetEqualsExpr().Compile();
        var getHashCode = comparer.GetGetHashCodeExpr().Compile();
        var generator = comparer.CreateFastDictionary2Generator<ActiveEvent,int>(1, equals, getHashCode, stream.Properties.QueryContainer);
        dictPool = new DataStructurePool<FastDictionary2<ActiveEvent,int>>(() => generator.Invoke());
        eventMap = new SortedDictionary<long, FastDictionary2<ActiveEvent, int>>();
        GetOutputBatch();
        lastSyncTime = StreamEvent.MinSyncTime;
        lastCti = StreamEvent.MinSyncTime;
    }

    private void GetOutputBatch()
    {
        pool.Get(out genericOutputBatch);
        genericOutputBatch.Allocate();
        output = (");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(")genericOutputBatch;\r\n");
 foreach (var f in this.fields.Where(fld => fld.OptimizeString())) {  
            this.Write("\r\n        output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".Initialize();\r\n");
 } 
            this.Write("   }\r\n\r\n    protected override void DisposeState()\r\n    {\r\n        this.output.Fr" +
                    "ee();\r\n        this.dictPool.Dispose();\r\n    }\r\n\r\n    private void OutputComplet" +
                    "edIntervals()\r\n    {\r\n        // Output all completed intervals\r\n        List<lo" +
                    "ng> delList = new List<long>();\r\n        foreach (var kvp in eventMap)\r\n        " +
                    "{\r\n            var index = FastDictionary2<ActiveEvent, int>.IteratorStart;\r\n   " +
                    "         while (kvp.Value.Iterate(ref index))\r\n            {\r\n                va" +
                    "r outevt = kvp.Value.entries[index].key;\r\n                if (outevt.End == Stre" +
                    "amEvent.InfinitySyncTime)\r\n                {\r\n                    foreach (var k" +
                    "ey in delList)\r\n                        eventMap.Remove(key);\r\n                 " +
                    "   return;\r\n                }\r\n\r\n                for (int j = 0; j < kvp.Value.e" +
                    "ntries[index].value; j++)\r\n                {\r\n                    AddToBatch(kvp" +
                    ".Key, outevt);\r\n                }\r\n                kvp.Value.Remove(outevt);\r\n  " +
                    "          }\r\n            dictPool.Return(kvp.Value);\r\n            delList.Add(kv" +
                    "p.Key);\r\n        }\r\n        foreach (var key in delList)\r\n            eventMap.R" +
                    "emove(key);\r\n    }\r\n\r\n    private void OutputAllEvents()\r\n    {\r\n        // Outp" +
                    "ut all collected intervals\r\n        foreach (var kvp in eventMap)\r\n        {\r\n  " +
                    "          var index = FastDictionary2<ActiveEvent, int>.IteratorStart;\r\n        " +
                    "    while (kvp.Value.Iterate(ref index))\r\n            {\r\n                var out" +
                    "evt = kvp.Value.entries[index].key;\r\n\r\n                for (int j = 0; j < kvp.V" +
                    "alue.entries[index].value; j++)\r\n                {\r\n                    AddToBat" +
                    "ch(kvp.Key, outevt);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    " +
                    "[MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    private void AddToBatch(" +
                    "long startTime, ActiveEvent outevt)\r\n    {\r\n       int ind = output.Count++;\r\n  " +
                    "     output.vsync.col[ind] = startTime;\r\n       output.vother.col[ind] = outevt." +
                    "End;\r\n       lastSyncTime = startTime;\r\n       output.key.col[ind] = outevt.Key;" +
                    "\r\n\r\n");
     foreach (var f in this.fields) {
         var sourceName = "outevt.Payload";
         if (!noFields) sourceName += "." + f.OriginalName;

            this.Write("\r\n");
       if (f.OptimizeString()) { 
            this.Write("\r\n       output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".AddString(");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceName));
            this.Write(");\r\n");
       } else { 
            this.Write("\r\n       output.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Name));
            this.Write(".col[ind] = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceName));
            this.Write(";\r\n");
       } 
     } 
            this.Write("\r\n       output.hash.col[ind] = outevt.Hash;\r\n\r\n       if (output.Count == Config" +
                    ".DataBatchSize) FlushContents();\r\n    }\r\n\r\n    public override unsafe void OnNex" +
                    "t(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> genericBatch)\r\n    {\r\n        var batch = genericBatch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(";\r\n\r\n        var count = batch.Count;\r\n        batch.bitvector = batch.bitvector." +
                    "MakeWritable(pool.bitvectorPool);\r\n\r\n        fixed (long* vsync = batch.vsync.co" +
                    "l)\r\n        fixed (long* vother = batch.vother.col)\r\n        fixed (long* bv = b" +
                    "atch.bitvector.col)\r\n        {\r\n            for (int i = 0; i < count; i++)\r\n   " +
                    "         {\r\n                if ((bv[i >> 6] & (1L << (i & 0x3f))) == 0 || vother" +
                    "[i] == long.MinValue)\r\n                {\r\n                    if (batch.vother.c" +
                    "ol[i] == long.MinValue) // Punctuation\r\n                    {\r\n                 " +
                    "       if (vsync[i] == StreamEvent.InfinitySyncTime)\r\n                          " +
                    "  OutputAllEvents();\r\n                        else\r\n                            " +
                    "OutputCompletedIntervals();\r\n\r\n                        lastCti = Math.Max(vsync[" +
                    "i], lastCti);\r\n                        lastSyncTime = Math.Max(vsync[i], lastSyn" +
                    "cTime);\r\n                        AddPunctuationToBatch(batch.vsync.col[i]);\r\n   " +
                    "                 }\r\n                    else if (vsync[i] < vother[i]) // Start " +
                    "edge or interval\r\n                    {\r\n                        ActiveEvent evt" +
                    " = new ActiveEvent(batch, i);\r\n\r\n                        FastDictionary2<ActiveE" +
                    "vent, int> entry;\r\n                        if (!eventMap.TryGetValue(vsync[i], o" +
                    "ut entry))\r\n                        {\r\n                            dictPool.Get(" +
                    "out entry);\r\n                            eventMap.Add(vsync[i], entry);\r\n       " +
                    "                 }\r\n                        int index;\r\n                        " +
                    "if (!entry.Lookup(evt, out index))\r\n                        {\r\n                 " +
                    "           entry.Insert(evt, 1);\r\n                        }\r\n                   " +
                    "     else\r\n                        {\r\n                            entry.entries[" +
                    "index].value++;\r\n                        }\r\n                    }\r\n             " +
                    "       else // end edge\r\n                    {\r\n                        // looku" +
                    "p corresponding start edge\r\n                        ActiveEvent lookupevt = new " +
                    "ActiveEvent(batch, i);\r\n                        lookupevt.End = StreamEvent.Infi" +
                    "nitySyncTime;\r\n\r\n                        FastDictionary2<ActiveEvent, int> entry" +
                    ";\r\n                        if (!eventMap.TryGetValue(vother[i], out entry))\r\n   " +
                    "                     {\r\n                            throw new InvalidOperationEx" +
                    "ception(\"Found end edge without corresponding start edge\");\r\n                   " +
                    "     }\r\n\r\n                        int index;\r\n                        if (!entry" +
                    ".Lookup(lookupevt, out index))\r\n                        {\r\n                     " +
                    "       throw new InvalidOperationException(\"Found end edge without corresponding" +
                    " start edge\");\r\n                        }\r\n\r\n                        // Set inte" +
                    "rval payload to the payload of the original start-edge\r\n                        " +
                    "// (in case they are different due to an optimized payload equality comparer)\r\n " +
                    "                       //lookupevt.Payload = entry.entries[index].key.Payload;\r\n" +
                    "                        var startEdgeActiveEvent = entry.entries[index].key;\r\n");
     foreach (var f in this.fields) { 
            this.Write("\r\n                        lookupevt.Payload");
            this.Write(this.ToStringHelper.ToStringWithCulture(noFields ? string.Empty : "." + f.OriginalName));
            this.Write(" = startEdgeActiveEvent.Payload");
            this.Write(this.ToStringHelper.ToStringWithCulture(noFields ? string.Empty : "." + f.OriginalName));
            this.Write(";\r\n");
     } 
            this.Write("\r\n                        // delete the start edge\r\n                        entry" +
                    ".entries[index].value--;\r\n                        if (entry.entries[index].value" +
                    " == 0)\r\n                        {\r\n                            entry.Remove(look" +
                    "upevt);\r\n                        }\r\n\r\n                        // insert interval" +
                    "\r\n                        lookupevt.End = batch.vsync.col[i];\r\n\r\n               " +
                    "         if (!entry.Lookup(lookupevt, out index))\r\n                        {\r\n  " +
                    "                          entry.Insert(lookupevt, 1);\r\n                        }" +
                    "\r\n                        else\r\n                        {\r\n                     " +
                    "       entry.entries[index].value++;\r\n                        }\r\n               " +
                    "         OutputCompletedIntervals(); // Can make this more efficient by trying o" +
                    "nly if the first event in index got completed\r\n                    }\r\n          " +
                    "      }\r\n            }\r\n        }\r\n\r\n        batch.Free();\r\n    }\r\n\r\n    private" +
                    " void AddPunctuationToBatch(long start)\r\n    {\r\n        int index = output.Count" +
                    "++;\r\n        output.vsync.col[index] = start;\r\n        output.vother.col[index] " +
                    "= StreamEvent.PunctuationOtherTime;\r\n        output.key.col[index] = default;\r\n " +
                    "       output[index] = default;\r\n        output.hash.col[index] = 0;\r\n        ou" +
                    "tput.bitvector.col[index >> 6] |= (1L << (index & 0x3f));\r\n\r\n        if (output." +
                    "Count == Config.DataBatchSize) FlushContents();\r\n    }\r\n\r\n    public override vo" +
                    "id ProduceQueryPlan(PlanNode previous)\r\n    {\r\n        Observer.ProduceQueryPlan" +
                    "(queryPlanGenerator(previous, this));\r\n    }\r\n\r\n    protected override void Flus" +
                    "hContents()\r\n    {\r\n        if (output.Count == 0) return;\r\n        output.Seal(" +
                    ");\r\n        this.Observer.OnNext(output);\r\n        GetOutputBatch();\r\n    }\r\n\r\n " +
                    "   public override int CurrentlyBufferedOutputCount => output.Count;\r\n\r\n    publ" +
                    "ic override int CurrentlyBufferedInputCount\r\n    {\r\n        get\r\n        {\r\n    " +
                    "        int count = 0;\r\n            foreach (var tuple in eventMap)\r\n           " +
                    " {\r\n                int iter = FastDictionary2<ActiveEvent, int>.IteratorStart;\r" +
                    "\n                while (tuple.Value.Iterate(ref iter)) count += tuple.Value.entr" +
                    "ies[iter].value;\r\n            }\r\n            return count;\r\n        }\r\n    }\r\n\r\n" +
                    "");
 if (!noFields && !this.payloadType.GetTypeInfo().IsValueType) { 
            this.Write("    [DataContract]\r\n    public struct ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write("\r\n    {\r\n");
 foreach (var f in this.fields) { 
            this.Write("      [DataMember]\r\n      public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.Type.GetCSharpSourceSyntax()));
            this.Write(" ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(";\r\n");
 } 
            this.Write("    }\r\n");
 } 
            this.Write("\r\n    [DataContract]\r\n    public struct ActiveEvent\r\n    {\r\n        [DataMember]\r" +
                    "\n        public long End;\r\n        [DataMember]\r\n        public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(" Key;\r\n        [DataMember]\r\n        public int Hash;\r\n\r\n        [DataMember]\r\n  " +
                    "      public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ActiveEventType));
            this.Write(" Payload;\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        " +
                    "public ActiveEvent(");
            this.Write(this.ToStringHelper.ToStringWithCulture(BatchGeneratedFrom_TKey_TPayload));
            this.Write(this.ToStringHelper.ToStringWithCulture(TKeyTPayloadGenericParameters));
            this.Write(" batch, int index)\r\n        {\r\n            End = batch.vother.col[index];\r\n\r\n");
 if (this.noFields) { 
            this.Write("            this.Payload = batch.payload.col[index];\r\n");
 } else { 
            this.Write("            ");
 foreach (var f in this.fields) { 
            this.Write("\r\n            this.Payload.");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.OriginalName));
            this.Write(" = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(f.AccessExpressionForRowValue("batch", "index")));
            this.Write(";\r\n            ");
 } 
 } 
            this.Write("            Key = batch.key.col[index];\r\n            Hash = batch.hash.col[index]" +
                    ";\r\n        }\r\n\r\n        public override string ToString()\r\n        {\r\n          " +
                    "  return \"[End=\" + End + \", Key=\'\" + Key + \"\', Payload=\'\" + \"\']\";\r\n        }\r\n  " +
                    "  }\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
}
