// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    internal partial class GroupedAfaMultiEventTemplate : AfaTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;

// CompiledGroupedAfaPipe_MultiEvent
// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TPayload: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("\r\n// TRegister: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write("\r\n// TAccumulator: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TAccumulator));
            this.Write("\r\n\r\n[DataContract]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(" : CompiledAfaPipeBase<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TAccumulator));
            this.Write(">\r\n{\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    [DataMember]\r\n    protected FastMap<GroupedActiveStateAccumulator<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TAccumulator));
            this.Write(">> activeStates;\r\n    [DataMember]\r\n    protected FastMap<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("> keyHeads;\r\n\r\n    // Traversers\r\n    protected FastMap<GroupedActiveStateAccumul" +
                    "ator<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TAccumulator));
            this.Write(">>.FindTraverser activeFindTraverser;\r\n    protected FastMap<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(">.FindTraverser keyHeadsFindTraverser;\r\n    protected FastMap<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(">.VisibleTraverser keyHeadsVisibleTraverser;\r\n\r\n    [DataMember]\r\n    protected l" +
                    "ong lastSyncTime;\r\n\r\n    private long[] dest_vsync;\r\n    private long[] dest_vot" +
                    "her;\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("[] destkey;\r\n    private int[] dest_hash;\r\n    private ");
            this.Write(this.ToStringHelper.ToStringWithCulture(resultBatchTypeName));
            this.Write(" resultBatch;\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        IStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write("> observer,\r\n        object afa,\r\n        long MaxDuration)\r\n        : base(strea" +
                    "m, observer, afa, MaxDuration)\r\n    {\r\n        activeStates = new FastMap<Groupe" +
                    "dActiveStateAccumulator<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TAccumulator));
            this.Write(">>(1);\r\n        activeFindTraverser = new FastMap<GroupedActiveStateAccumulator<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TAccumulator));
            this.Write(">>.FindTraverser(activeStates);\r\n\r\n        keyHeads = new FastMap<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(">(1);\r\n        keyHeadsFindTraverser = new FastMap<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(">.FindTraverser(keyHeads);\r\n        keyHeadsVisibleTraverser = new FastMap<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(@">.VisibleTraverser(keyHeads);

        lastSyncTime = -1;
    }

    public override int CurrentlyBufferedInputCount => activeStates.Count;

    private void ProcessCurrentTimestamp()
    {
        keyHeadsVisibleTraverser.currIndex = 0;
        int index, hash;
        bool ended = true;

        while (keyHeadsVisibleTraverser.Next(out index, out hash))
        {
            if (activeFindTraverser.Find(hash))
            {
                int activeFind_index;
                while (activeFindTraverser.Next(out activeFind_index))
                {
                    var state2 = activeStates.Values[activeFind_index];
                    if (!(");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyEqualityComparer("state2.key", "keyHeads.Values[index]")));
            this.Write(")) continue;\r\n\r\n                    var newReg = activeStates.Values[activeFind_i" +
                    "ndex].register;\r\n\r\n                    switch (state2.fromState) {\r\n            " +
                    "            ");
 foreach (var sourceNodeInfo in this.edgeInfos) { 
            this.Write("\r\n                        case ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceNodeInfo.Item1));
            this.Write(":\r\n                            switch (state2.toState) {\r\n                       " +
                    "     ");
 foreach (var edge in sourceNodeInfo.Item2) { 
            this.Write("\r\n                                case ");
            this.Write(this.ToStringHelper.ToStringWithCulture(edge.TargetNode));
            this.Write(":\r\n\r\n                                    // We guarantee by construction that new" +
                    " transitions are the end of the linked list\r\n                                   " +
                    " if ((");
            this.Write(this.ToStringHelper.ToStringWithCulture(edge.fromStartState ? "true" : "false"));
            this.Write(") && !");
            this.Write(this.ToStringHelper.ToStringWithCulture((this.AllowOverlappingInstances ? "true" : "false")));
            this.Write(" && !ended)\r\n                                    {\r\n                             " +
                    "           ");
            this.Write(this.ToStringHelper.ToStringWithCulture(edge.Dispose("activeStates.Values[activeFind_index].accumulator")));
            this.Write(@";
                                        activeFindTraverser.Remove();
                                    }
                                    else
                                    {
                                        // Found tentative entry, complete transition
                                        if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(edge.Fence("lastSyncTime", "state2.accumulator", "state2.register")));
            this.Write(")\r\n                                        {\r\n                                   " +
                    "         ");
 if (edge.Transfer != null) { 
            this.Write("\r\n                                                activeStates.Values[activeFind_" +
                    "index].register = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(edge.Transfer("lastSyncTime", "state2.accumulator", "state2.register")));
            this.Write(";\r\n                                            ");
 } 
            this.Write("\r\n                                            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(edge.Dispose("activeStates.Values[activeFind_index].accumulator")));
            this.Write(";\r\n\r\n                                            // target state: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(edge.TargetNode));
            this.Write(" (");
            this.Write(this.ToStringHelper.ToStringWithCulture(isFinal[edge.TargetNode] ? "final" : "not final"));
            this.Write(")\r\n                                            ");
 IfFinalStateProduceOutput(44, edge.TargetNode, string.Empty, "lastSyncTime", "state2.PatternStartTimestamp", "state2.key", "hash"); 
            this.Write("\r\n                                            ");
 if (hasOutgoingArcs[edge.TargetNode]) { 
            this.Write("\r\n                                            // there are outgoing edges\r\n      " +
                    "                                      ended = false;\r\n                          " +
                    "                  ");
 } else { 
            this.Write("\r\n                                            // there are no outgoing edges\r\n   " +
                    "                                         activeFindTraverser.Remove();\r\n        " +
                    "                                    ");
 } 
            this.Write("\r\n                                        }\r\n                                    " +
                    "    else\r\n                                        {\r\n                           " +
                    "                 ");
            this.Write(this.ToStringHelper.ToStringWithCulture(edge.Dispose("activeStates.Values[activeFind_index].accumulator")));
            this.Write(";\r\n                                            activeFindTraverser.Remove();\r\n   " +
                    "                                     }\r\n                                    }\r\n " +
                    "                                   break;\r\n                            ");
 } 
            this.Write("\r\n                            } // end inner switch\r\n\r\n                          " +
                    "  break;\r\n\r\n                        ");
 } 
            this.Write("\r\n                    } // end outer switch\r\n                }\r\n            }\r\n  " +
                    "      }\r\n        keyHeads.Clear();\r\n    }\r\n\r\n    public override unsafe void OnN" +
                    "ext(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(@"> batch)
    {
        dest_vsync = this.batch.vsync.col;
        dest_vother = this.batch.vother.col;
        destkey = this.batch.key.col;
        dest_hash = this.batch.hash.col;

        var count = batch.Count;

        var srckey = batch.key.col;
        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceBatchTypeName));
            this.Write(" sourceBatch = batch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceBatchTypeName));
            this.Write(";\r\n\r\n        ");
 foreach (var f in this.sourceFields) { 
            this.Write("\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BeginColumnPointerDeclaration(f, "sourceBatch")));
            this.Write("\r\n        ");
 } 
            this.Write(@"
        fixed (long* src_bv = batch.bitvector.col, src_vsync = batch.vsync.col, src_vother = batch.vother.col)
        {
            fixed (int* src_hash = batch.hash.col)
            {
                for (int i = 0; i < count; i++)
                {
                    if ((src_bv[i >> 6] & (1L << (i & 0x3f))) == 0 || src_vother[i] < 0)
                    {
                        long synctime = src_vsync[i];

                        if (synctime > lastSyncTime) // move time forward
                        {
                            ProcessCurrentTimestamp();
                            lastSyncTime = synctime;
                        }

                        if (src_vother[i] < 0)
                        {
                            OnPunctuation(synctime);
                            continue;
                        }

                        int keyHeads_index;
                        bool keyHeadExists = false;
                        if (keyHeadsFindTraverser.Find(src_hash[i]))
                        {
                            while (keyHeadsFindTraverser.Next(out keyHeads_index))
                            {
                                if (!(");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyEqualityComparer("keyHeads.Values[keyHeads_index]", "srckey[i]")));
            this.Write(@")) continue;

                                // Found entry, this key has been processed before
                                keyHeadExists = true;
                                break;
                            }
                        }

                        if (!keyHeadExists)
                        {
                            // Apply new transitions, update existing transitions
                            bool found = activeFindTraverser.Find(src_hash[i]);

                            if (found)
                            {
                                int activeFind_index;
                                while (activeFindTraverser.Next(out activeFind_index))
                                {
                                    var state = activeStates.Values[activeFind_index];
                                    if (!(");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyEqualityComparer("state.key", "srckey[i]")));
            this.Write(@")) continue;

                                    // TODO: Found entry, create and accumulate new tentative transitions from current state
                                    if (state.PatternStartTimestamp + MaxDuration > synctime)
                                    {
                                        switch (state.toState) {
                                            ");
 foreach (var sourceNodeInfo in this.edgeInfos) { 
            this.Write("\r\n                                            case ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceNodeInfo.Item1));
            this.Write(" :\r\n                                                ");
 foreach (var arcinfo in sourceNodeInfo.Item2) { 
            this.Write(@"
                                                if (activeFind_index == -1) activeFind_index = activeStates.Insert(src_hash[i]);
                                                activeStates.Values[activeFind_index].arcinfo = null /*arcinfo*/;
                                                activeStates.Values[activeFind_index].key = state.key;
                                                activeStates.Values[activeFind_index].fromState = state.toState;
                                                activeStates.Values[activeFind_index].toState = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcinfo.TargetNode));
            this.Write(@";
                                                activeStates.Values[activeFind_index].PatternStartTimestamp = state.PatternStartTimestamp;
                                                activeStates.Values[activeFind_index].register = state.register;
                                                activeStates.Values[activeFind_index].accumulator = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcinfo.Initialize("synctime", "state.register")));
            this.Write(";\r\n                                                activeStates.Values[activeFind" +
                    "_index].accumulator = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcinfo.Accumulate("synctime", "batch[i]", "state.register", "activeStates.Values[activeFind_index].accumulator")));
            this.Write(";\r\n                                                activeFind_index = -1;\r\n      " +
                    "                                          ");
 } 
            this.Write("\r\n                                                break;\r\n                       " +
                    "                     ");
 } 
            this.Write(@"
                                        } // end switch
                                    }

                                    // Remove current state
                                    if (activeFind_index != -1) activeFindTraverser.Remove();
                                }
                            }

                            // Insert & accumulate new tentative transitions from start state
                            ");
 foreach (var sourceNodeInfo in this.startEdgeInfos) { 
            this.Write("\r\n                            // start node: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceNodeInfo.Item1));
            this.Write("\r\n                                ");
 foreach (var arcinfo in sourceNodeInfo.Item2) { 
            this.Write(@"
                                {
                                int index = activeFindTraverser.InsertAt(); // have to ensure the new states go to the end of the list
                                activeStates.Values[index].arcinfo = null; /*arcinfo*/;
                                activeStates.Values[index].key = srckey[i];
                                activeStates.Values[index].fromState = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcinfo.SourceNode));
            this.Write(";\r\n                                activeStates.Values[index].toState = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcinfo.TargetNode));
            this.Write(@";
                                activeStates.Values[index].PatternStartTimestamp = synctime;
                                activeStates.Values[index].register = defaultRegister;
                                activeStates.Values[index].accumulator = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcinfo.Initialize("synctime", "defaultRegister")));
            this.Write(";\r\n                                activeStates.Values[index].accumulator = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcinfo.Accumulate("synctime", "batch[i]", "defaultRegister", "activeStates.Values[index].accumulator")));
            this.Write(";\r\n                                }\r\n                                ");
 } 
            this.Write("                            ");
 } 
            this.Write(@"
                            // Update keyHeads to indicate that this key has been inserted
                            keyHeads_index = keyHeads.Insert(src_hash[i]);
                            keyHeads.Values[keyHeads_index] = srckey[i];

                            // Done processing this event
                            continue;
                        }

                        // Not the first insert of this key for this timestamp, perform accumulate for all tentative states
                        if (activeFindTraverser.Find(src_hash[i]))
                        {
                            int activeFind_index;
                            while (activeFindTraverser.Next(out activeFind_index))
                            {
                                var state2 = activeStates.Values[activeFind_index];
                                if (!(");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyEqualityComparer("state2.key", "srckey[i]")));
            this.Write(")) continue;\r\n\r\n                                switch (state2.fromState) {\r\n    " +
                    "                                ");
 foreach (var sourceNodeInfo in this.edgeInfos) { 
            this.Write("\r\n                                    case ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceNodeInfo.Item1));
            this.Write(" /* start state */ :\r\n                                    ");
 foreach (var arcinfo in sourceNodeInfo.Item2) { 
            this.Write("\r\n                                        // end state: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcinfo.TargetNode));
            this.Write(";\r\n                                        // Found tentative entry, accumulate\r\n" +
                    "                                        activeStates.Values[activeFind_index].ac" +
                    "cumulator = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(arcinfo.Accumulate("synctime", "batch[i]", "state2.register", "state2.accumulator")));
            this.Write(";\r\n                                    ");
 } 
            this.Write("\r\n                                    break;\r\n                                   " +
                    " ");
 } 
            this.Write("\r\n                                } // end switch\r\n                            }\r" +
                    "\n                        }\r\n                    }\r\n                }\r\n          " +
                    "  }\r\n        }\r\n        ");
 foreach (var f in this.sourceFields) { 
            this.Write("        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(EndColumnPointerDeclaration(f)));
            this.Write("\r\n        ");
 } 
            this.Write("\r\n        batch.Free();\r\n    }\r\n}");
            return this.GenerationEnvironment.ToString();
        }
    }
}
