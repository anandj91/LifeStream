// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Microsoft.StreamProcessing
{
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    internal partial class GroupedAfaTemplate : AfaTemplate
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(@"// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;
using System.Runtime.Serialization;
using Microsoft.StreamProcessing;
using Microsoft.StreamProcessing.Internal;
using Microsoft.StreamProcessing.Internal.Collections;

// CompiledGroupedAfaPipe
// TKey: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write("\r\n// TPayload: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("\r\n// TRegister: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write("\r\n// TAccumulator: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TAccumulator));
            this.Write("\r\n\r\n[DataContract]\r\ninternal sealed class ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write(" : CompiledAfaPipeBase<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TAccumulator));
            this.Write(">\r\n{\r\n    [DataMember]\r\n    private FastMap<GroupedActiveState<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">> activeStates;\r\n    [DataMember]\r\n    private FastDictionary<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", byte> seenEvent;\r\n    [DataMember]\r\n    private FastMap<OutputEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">> tentativeOutput;\r\n    [DataMember]\r\n    private long lastSyncTime;\r\n\r\n    ");
            this.Write(this.ToStringHelper.ToStringWithCulture(staticCtor));
            this.Write("\r\n\r\n    public ");
            this.Write(this.ToStringHelper.ToStringWithCulture(className));
            this.Write("(\r\n        AfaStreamable<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write("> stream,\r\n        IStreamObserver<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write("> observer,\r\n        object afa,\r\n        long MaxDuration)\r\n        : base(strea" +
                    "m, observer, afa, MaxDuration)\r\n    {\r\n        activeStates = new FastMap<Groupe" +
                    "dActiveState<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">>();\r\n\r\n        ");
 if (!this.isSyncTimeSimultaneityFree) { 
            this.Write(@"            var comparer = stream.Properties.KeyEqualityComparer;
            var equalsFunc = comparer.GetEqualsExpr().Compile();
            var getHashCodeFunc = comparer.GetGetHashCodeExpr().Compile();
            seenEvent = comparer.CreateFastDictionaryGenerator<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", byte>(10, equalsFunc, getHashCodeFunc, stream.Properties.QueryContainer).Invoke" +
                    "();\r\n\r\n            tentativeOutput = new FastMap<OutputEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">>();\r\n            lastSyncTime = -1;\r\n        ");
 } 
            this.Write("    }\r\n\r\n    public override int CurrentlyBufferedInputCount => activeStates.Coun" +
                    "t;\r\n\r\n    public override unsafe void OnNext(StreamMessage<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TPayload));
            this.Write("> batch)\r\n    {\r\n        Stack<int> stack = new Stack<int>();\r\n        var active" +
                    "FindTraverser = new FastMap<GroupedActiveState<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">>.FindTraverser(activeStates);\r\n        var tentativeFindTraverser = new FastMap" +
                    "<OutputEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">>.FindTraverser(tentativeOutput);\r\n        var tentativeVisibleTraverser = new F" +
                    "astMap<OutputEvent<");
            this.Write(this.ToStringHelper.ToStringWithCulture(TKey));
            this.Write(", ");
            this.Write(this.ToStringHelper.ToStringWithCulture(TRegister));
            this.Write(">>.VisibleTraverser(tentativeOutput);\r\n\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceBatchTypeName));
            this.Write(" sourceBatch = batch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceBatchTypeName));
            this.Write(";\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(resultBatchTypeName));
            this.Write(" resultBatch = this.batch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(resultBatchTypeName));
            this.Write(";\r\n\r\n        if (this.batch == null)\r\n        {\r\n            this.pool.Get(out th" +
                    "is.batch);\r\n            this.batch.Allocate();\r\n            this.batch.iter = 0;" +
                    "\r\n            iter = 0;\r\n            resultBatch = this.batch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(resultBatchTypeName));
            this.Write(@";
        }

        var count = batch.Count;

        var dest_vsync = this.batch.vsync.col;
        var dest_vother = this.batch.vother.col;
        var destkey = this.batch.key.col;
        var dest_hash = this.batch.hash.col;

        var srckey = batch.key.col;

        ");
 foreach (var f in this.sourceFields) { 
            this.Write("\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BeginColumnPointerDeclaration(f, "sourceBatch")));
            this.Write("\r\n        ");
 } 
            this.Write("        ");
 foreach (var f in this.resultFields) { 
            this.Write("\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(BeginColumnPointerDeclaration(f, "resultBatch")));
            this.Write("\r\n        ");
 } 
            this.Write(@"
        fixed (long* src_bv = batch.bitvector.col, src_vsync = batch.vsync.col, src_vother = batch.vother.col)
        {
            fixed (int* src_hash = batch.hash.col)
            {
                for (int i = 0; i < count; i++)
                {
                    if ((src_bv[i >> 6] & (1L << (i & 0x3f))) == 0)
                    {
                        long synctime = src_vsync[i];

                        ");
 if (!this.isSyncTimeSimultaneityFree) { 
            this.Write(@"                        {
                            int index, hash;

                            if (synctime > lastSyncTime) // move time forward
                            {
                                seenEvent.Clear();
                                if (tentativeOutput.Count > 0)
                                {
                                    tentativeVisibleTraverser.currIndex = 0;

                                    while (tentativeVisibleTraverser.Next(out index, out hash))
                                    {
                                        var elem = tentativeOutput.Values[index];

                                        dest_vsync[iter] = lastSyncTime;
                                        dest_vother[iter] = elem.other;
                                        this.batch[iter] = elem.payload;
                                        destkey[iter] = elem.key;
                                        dest_hash[iter] = hash;
                                        iter++;

                                        if (iter == Config.DataBatchSize)
                                        {
                                            FlushContents();
                                            resultBatch = this.batch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(resultBatchTypeName));
            this.Write(@";
                                            dest_vsync = this.batch.vsync.col;
                                            dest_vother = this.batch.vother.col;
                                            destkey = this.batch.key.col;
                                            dest_hash = this.batch.hash.col;
                                        }
                                    }
                                    tentativeOutput.Clear(); // Clear the tentative output list
                                }
                                lastSyncTime = synctime;
                            }

                            if (seenEvent.Lookup(srckey[i], out index)) // Incoming event is a simultaneous one
                            {
                                if (seenEvent.entries[index].value == 1) // Detecting first duplicate, need to adjust state
                                {
                                    seenEvent.entries[index].value = 2;

                                    // Delete tentative output for that key
                                    if (tentativeFindTraverser.Find(src_hash[i]))
                                    {
                                        while (tentativeFindTraverser.Next(out index))
                                        {
                                            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyEqualityComparer("tentativeOutput.Values[index].key", "srckey[i]")));
            this.Write(@")
                                            {
                                                tentativeFindTraverser.Remove();
                                            }
                                        }
                                    }

                                    // Delete active states for that key
                                    if (activeFindTraverser.Find(src_hash[i]))
                                    {
                                        while (activeFindTraverser.Next(out index))
                                        {
                                            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyEqualityComparer("activeStates.Values[index].key", "srckey[i]")));
            this.Write(@")
                                            {
                                                activeFindTraverser.Remove();
                                            }
                                        }
                                    }
                                }

                                // Dont process this event
                                continue;
                            }
                            else
                            {
                                seenEvent.Insert(ref index, srckey[i], 1);
                            }
                        }
                        ");
 } 
            this.Write(@"
                        /* (1) Process currently active states */

                        bool ended = true;
                        if (activeFindTraverser.Find(src_hash[i]))
                        {
                            int index, orig_index;

                            while (activeFindTraverser.Next(out index))
                            {
                                orig_index = index;

                                var state = activeStates.Values[index];
                                if (!(");
            this.Write(this.ToStringHelper.ToStringWithCulture(keyEqualityComparer("state.key", "srckey[i]")));
            this.Write(")) continue;\r\n\r\n                                if (state.PatternStartTimestamp +" +
                    " MaxDuration > synctime)\r\n                                {\r\n                   " +
                    "                 switch (state.state) {\r\n                                       " +
                    " ");
 foreach (var sourceNodeInfo in this.currentlyActiveInfo) { 
            this.Write("\r\n                                        case ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceNodeInfo.Item1));
            this.Write(" :\r\n                                            ");
 foreach (var edge in sourceNodeInfo.Item2) { 
            this.Write("\r\n                                            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(edge.Fence("synctime", "batch[i]", "state.register")));
            this.Write(") {\r\n                                                // assign new register value" +
                    "\r\n                                                ");
 UpdateRegisterValue(edge, "state.register", "synctime", "batch[i]", "state.register"); 
            this.Write("                                                // target nodes\r\n                " +
                    "                                ");
 foreach (var ns in edge.EpsilonReachableNodes) { 
            this.Write("\r\n                                                // target state: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ns));
            this.Write(" (");
            this.Write(this.ToStringHelper.ToStringWithCulture(isFinal[ns] ? "final" : "not final"));
            this.Write(")\r\n                                                ");
 IfFinalStateProduceOutput(52, ns, "src_hash[i]", "synctime", "state.PatternStartTimestamp",  "srckey[i]", "src_hash[i]"); 
            this.Write("                                                ");
 if (hasOutgoingArcs[ns]) { 
            this.Write(@"
                                                // target node has outgoing edges
                                                if (index == -1) index = activeStates.Insert(src_hash[i]);
                                                activeStates.Values[index].key = srckey[i];
                                                activeStates.Values[index].state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ns));
            this.Write(@";
                                                activeStates.Values[index].register = newReg;
                                                activeStates.Values[index].PatternStartTimestamp = state.PatternStartTimestamp;

                                                index = -1;
                                                ended = false;
                                                ");
 } else { 
            this.Write("\r\n                                                // target node does not have an" +
                    "y outgoing edges\r\n                                                ");
 } 
            this.Write("                                                ");
 } 
            this.Write("\r\n                                            }\r\n                                " +
                    "            ");
 } 
            this.Write("\r\n                                            break;\r\n\r\n                         " +
                    "               ");
 } 
            this.Write(@"
                                    }

                                }
                                if (index == orig_index) activeFindTraverser.Remove();
                            }
                        }

                        /* (2) Start new activations from the start state(s) */
                        ");
 if (!this.AllowOverlappingInstances) { 
            this.Write("\r\n                        if (!ended) continue;\r\n                        ");
 } 
            this.Write("\r\n                        ");
 foreach (var sourceNodeInfo in this.newActivationInfo) { 
            this.Write("\r\n                            // start node: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(sourceNodeInfo.Item1));
            this.Write("\r\n                            ");
 foreach (var edge in sourceNodeInfo.Item2) { 
            this.Write("\r\n                            if (");
            this.Write(this.ToStringHelper.ToStringWithCulture(edge.Fence("synctime", "batch[i]", "defaultRegister")));
            this.Write(") {\r\n                                // initialize register\r\n                    " +
                    "            ");
 UpdateRegisterValue(edge, "defaultRegister", "synctime", "batch[i]", "defaultRegister"); 
            this.Write("                                // target nodes\r\n                                " +
                    "");
 foreach (var ns in edge.EpsilonReachableNodes) { 
            this.Write("\r\n                                // target state: ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ns));
            this.Write(" (");
            this.Write(this.ToStringHelper.ToStringWithCulture(isFinal[ns] ? "final" : "not final"));
            this.Write(")\r\n                                ");
 IfFinalStateProduceOutput(52, ns, "src_hash[i]", "synctime", "synctime", "srckey[i]", "src_hash[i]"); 
            this.Write("                                ");
 if (hasOutgoingArcs[ns]) { 
            this.Write(@"
                                // target node has outgoing edges
                                {
                                    var index = activeStates.Insert(src_hash[i]);
                                    activeStates.Values[index].key = srckey[i];
                                    activeStates.Values[index].state = ");
            this.Write(this.ToStringHelper.ToStringWithCulture(ns));
            this.Write(";\r\n                                    activeStates.Values[index].register = newR" +
                    "eg;\r\n                                    activeStates.Values[index].PatternStart" +
                    "Timestamp = synctime;\r\n                                }\r\n                      " +
                    "          ");
 } else { 
            this.Write("\r\n                                // target node does not have any outgoing edges" +
                    "\r\n                                ");
 } 
            this.Write("                                ");
 } 
            this.Write("\r\n                            }\r\n                            ");
 } 
            this.Write("                        ");
 } 
            this.Write("\r\n                    }\r\n                    else if (src_vother[i] < 0)\r\n       " +
                    "             {\r\n");
  if (!this.isSyncTimeSimultaneityFree)
{ 
            this.Write(@"                        long synctime = src_vsync[i];
                        if (synctime > lastSyncTime) // move time forward
                        {
                            int index, hash;
                            seenEvent.Clear();

                            if (tentativeOutput.Count > 0)
                            {
                                tentativeVisibleTraverser.currIndex = 0;

                                while (tentativeVisibleTraverser.Next(out index, out hash))
                                {
                                    var elem = tentativeOutput.Values[index];

                                    this.batch.vsync.col[iter] = lastSyncTime;
                                    this.batch.vother.col[iter] = elem.other;
                                    this.batch[iter] = elem.payload;
                                    this.batch.key.col[iter] = elem.key;
                                    this.batch.hash.col[iter] = hash;
                                    iter++;

                                    if (iter == Config.DataBatchSize)
                                    {
                                        FlushContents();
                                        resultBatch = this.batch as ");
            this.Write(this.ToStringHelper.ToStringWithCulture(resultBatchTypeName));
            this.Write(@";
                                    }

                                }
                                tentativeOutput.Clear(); // Clear the tentative output list
                            }
                            lastSyncTime = synctime;
                        }
");
  } 
            this.Write("                        OnPunctuation(synctime);\r\n                    }\r\n        " +
                    "        }\r\n            }\r\n        }\r\n        ");
 foreach (var f in this.sourceFields) { 
            this.Write("            ");
            this.Write(this.ToStringHelper.ToStringWithCulture(EndColumnPointerDeclaration(f)));
            this.Write("\r\n        ");
 } 
            this.Write("        ");
 foreach (var f in this.resultFields) { 
            this.Write("\r\n        ");
            this.Write(this.ToStringHelper.ToStringWithCulture(EndColumnPointerDeclaration(f)));
            this.Write("\r\n        ");
 } 
            this.Write("\r\n        batch.Free();\r\n    }\r\n}\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
}
